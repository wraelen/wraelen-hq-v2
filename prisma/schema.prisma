generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model properties {
  id                String        @id @default(uuid()) @db.Uuid
  property_image_url   String?
  address           String
  city              String
  state             String
  zip_code          String
  property_type     PropertyType?
  bedrooms          Int?
  bathrooms         Float?
  square_feet       Int?
  year_built        Int?
  avm               Float?
  distress_signals  Json?
  owner_occupied    Boolean?
  notes             String?
  metadata          Json?
  address_hash      String        @unique
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  equity            Float?
  listing_price     Decimal?  @db.Decimal(12, 2)
  loan_to_value     Float?
  remaining_balance Float?
  open_loans        Int?
  leads             leads[]

  @@index([address_hash])
}

model leads {
  id                 String      @id @default(uuid()) @db.Uuid
  properties_id      String      @db.Uuid
  lead_type          LeadType?
  first_name         String?
  last_name          String?
  email              String?
  phone              String?
  call_notes         String?   @db.Text
  source             LeadSource?
  status             LeadStatus  @default(new)
  notes              String?
  assigned_to        String?     @db.Uuid
  metadata           Json?
  points_earned      Int         @default(0)
  created_at         DateTime    @default(now())
  updated_at         DateTime    @updatedAt
  realtor_first_name String?
  realtor_last_name  String?
  realtor_email      String?
  email_validated    Boolean   @default(false)
  email_validated_at DateTime?
  realtor_phone      String?
  calls              calls[]
  assigned_profile   profile?    @relation(fields: [assigned_to], references: [id])
  properties         properties  @relation(fields: [properties_id], references: [id], onDelete: Cascade)

  @@index([assigned_to, status])
}

model calls {
  id            String        @id @default(uuid()) @db.Uuid
  direction     CallDirection @default(outbound)
  duration      Int?
  outcome       CallOutcome?
  points_earned Int           @default(0)
  metadata      Json?
  created_at    DateTime      @default(now())
  updated_at    DateTime      @updatedAt
  call_sid      String?
  caller_id     String        @db.Uuid
  leads_id      String        @db.Uuid
  status        String?
  caller        profile       @relation(fields: [caller_id], references: [id], onDelete: SetNull)
  lead          leads         @relation(fields: [leads_id], references: [id], onDelete: Cascade)

  @@index([leads_id, created_at])
  @@index([caller_id, outcome])
}

model profile {
  id                String              @id @db.Uuid
  user_id           String              @unique @db.Uuid
  role              UserRole            @default(novice)
  points            Int                 @default(0)
  badges            String[]            @default([])
  created_at        DateTime            @default(now())
  updated_at        DateTime            @updatedAt
  quests            Quest[]
  calls             calls[]
  leads             leads[]
  quest_completions quest_completions[]

  @@index([user_id])
}

model Quest {
  id          String              @id @default(uuid()) @db.Uuid
  title       String
  description String?
  points      Int
  criteria    Json?
  type        QuestType
  active      Boolean             @default(true)
  profile_id  String?             @db.Uuid
  created_at  DateTime            @default(now())
  updated_at  DateTime            @updatedAt
  profile     profile?            @relation(fields: [profile_id], references: [id])
  completions quest_completions[]

  @@index([type, active])
}

model quest_completions {
  id           String   @id @default(uuid()) @db.Uuid
  quest_id     String   @db.Uuid
  profile_id   String   @db.Uuid
  completed_at DateTime @default(now())
  evidence     Json?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
  profile      profile  @relation(fields: [profile_id], references: [id], onDelete: Cascade)
  quest        Quest    @relation(fields: [quest_id], references: [id], onDelete: Cascade)

  @@unique([quest_id, profile_id])
  @@index([profile_id, completed_at])
}

model badges {
  id           String   @id @default(uuid()) @db.Uuid
  name         String
  description  String
  icon_url     String?
  requirements Json?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
}

model import_batches {
  id              String   @id @default(uuid()) @db.Uuid
  user_id         String   @db.Uuid
  filename        String?
  total_rows      Int
  successful_rows Int
  failed_rows     Int
  points_earned   Int      @default(0)
  lead_ids        String[] @default([])
  property_ids    String[] @default([])
  errors          Json?
  created_at      DateTime @default(now())

  @@index([user_id])
  @@index([created_at])
}

model import_jobs {
  id              String    @id @default(uuid())
  user_id         String
  filename        String
  status          String
  progress        Int       @default(0)
  status_message  String?
  current_row     Int?
  created_at      DateTime  @default(now())
  updated_at      DateTime  @default(now())
  completed_at    DateTime?
  
  @@index([user_id])
  @@index([status])
}

enum PropertyType {
  single_family
  multi_family
  condo
  townhouse
  land
  commercial
  other
}

enum LeadType {
  realtor
  owner
  investor
  other
}

enum LeadStatus {
  new
  contacted
  no_answer
  appointment_set
  contract_signed
  closed
  disqualified
  follow_up
  other
}

enum LeadSource {
  scrape
  referral
  other
  zillow_api
  propstream_import
}

enum CallDirection {
  inbound
  outbound
}

enum CallOutcome {
  connected
  voicemail
  no_answer
  disqualified
  appointment_set
  other
}

enum UserRole {
  novice
  apprentice
  journeyman
  master
  elite
  manager
  admin
}

enum QuestType {
  daily
  weekly
  one_time
}
