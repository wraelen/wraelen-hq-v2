// prisma/schema.prisma – Full DB schema for Wraelen HQ (Supabase/Postgres backend; best practice: Normalized with FKs for merges, enums for safety, jsonb for flexibility – scales for gamified quests/leaderboards; push with `pnpm prisma db push`)
// Logic: Builds on your current schema (keeps Profile with user_id/role/points/badges, Quest basics) + adds core (properties/leads/calls) for extraction/merges + supporting (junctions/view) for game mechanics. Use UUIDs for IDs, auto timestamps. Add RLS in Supabase dashboard (e.g., reps own assigned_to rows).

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")  // Kept: References .env var – fixes errors; keeps creds secure
}

generator client {
  provider = "prisma-client-js"
}

// Enum Definitions (no-brainer for type safety – prevents invalid data; expand as needed; added from your role string for consistency)
enum PropertyType {
  single_family
  multi_family
  condo
  townhouse
  land
  commercial
  other
}

enum LeadType {
  realtor
  owner
  investor
  other
}

enum LeadStatus {
  new
  contacted
  no_answer
  appointment_set
  contract_signed
  closed
  disqualified  // Suggestion: Added for wholesaling nuance (e.g., bad lead)
  follow_up     // Suggestion: Added for ongoing nurture quests
  other
}

enum LeadSource {
  scrape
  referral
  other
  zillow_api    // Suggestion: Specific for extraction tracking/points
  propstream_import
}

enum CallDirection {
  inbound
  outbound
}

enum CallOutcome {
  connected
  voicemail
  no_answer
  disqualified
  appointment_set
  other
}

enum UserRole {
  novice     // Kept/renamed your default for gamification (e.g., >1000 points → apprentice)
  apprentice
  journeyman
  master
  elite      // Suggestion: Unlock via badges/points for "elite roles"
  manager
  admin
}

enum QuestType {
  daily
  weekly
  one_time
}

// Core Table 1: Properties (extracted details from links; merged via upsert on address_hash)
model properties {
  id                   String       @id @default(uuid()) @db.Uuid  // PK: Auto UUID
  address              String                                    // Required: Full address
  city                 String                                    // Required: City
  state                String                                    // Required: 2-letter code
  zip_code             String                                    // Required: ZIP
  property_type        PropertyType?                             // Enum: Type for quests
  bedrooms             Int?                                      // Optional: Beds
  bathrooms            Float?                                    // Optional: Baths (float for halves)
  square_feet          Int?                                      // Optional: Sq ft
  lot_size             Float?                                    // Optional: Lot size
  year_built           Int?                                      // Optional: Build year
  zestimate            Float?                                    // Optional: Zillow value
  avm                  Float?                                    // Optional: Propstream value
  market_value         Float?                                    // Optional: Internal appraisal
  tax_assessed_value   Float?                                    // Optional: Tax value
  distress_signals     Json?                                     // Jsonb: { pre_foreclosure: true, ... }
  owner_occupied       Boolean?                                  // Optional: Owner lives there?
  notes                String?                                   // Optional: Manual/extraction notes
  metadata             Json?                                     // Jsonb: Raw merge { zillow_link: "...", photos: [] }
  address_hash         String       @unique                      // Required: Hash for dedup/merges
  created_at           DateTime     @default(now())              // Auto: Creation time
  updated_at           DateTime     @updatedAt                   // Auto: Last update
  leads                leads[]                                   // Relation: One-to-many with leads (backref)
  calls                calls[]                                   // Relation: One-to-many (if calls tie directly to props)

  @@index([city, state, zip_code])  // Index: For geo searches
  @@index([property_type])          // Index: For type-based quests
}

// Core Table 2: Leads (your draft refined; central merge point with FKs to properties/calls)
model leads {
  id              String      @id @default(uuid()) @db.Uuid  // PK: Auto UUID
  properties_id   String?     @db.Uuid                       // FK: To properties.id (optional initially, but set on extraction)
  lead_type       LeadType?                                  // Enum: Type
  first_name      String?                                    // Optional: Owner first
  last_name       String?                                    // Optional: Owner last
  email           String?                                    // Optional: Added later
  phone           String?                                    // Optional: Key for dialer
  source          LeadSource?                                // Enum: Origin (scrape points)
  status          LeadStatus? @default(new)                  // Enum: Lifecycle (trigger points on change)
  notes           String?                                    // Optional: Post-call edits
  assigned_to     String?     @db.Uuid                       // FK: To profiles.id (rep ownership)
  metadata        Json?                                      // Jsonb: { original_link: "...", extracted_data: {} }
  points_earned   Int         @default(0)                    // Suggestion: Gamification total (auto-increment via triggers)
  created_at      DateTime    @default(now())                // Auto: Creation
  updated_at      DateTime    @updatedAt                     // Auto: Last update
  properties      properties? @relation(fields: [properties_id], references: [id])  // Relation: To properties
  profile         Profile?    @relation(fields: [assigned_to], references: [id])    // Relation: To rep (note: Renamed from profiles for your naming)
  calls           calls[]                                                         // Relation: One-to-many with calls

  @@index([properties_id])  // Index: For joins
  @@index([assigned_to, status])  // Index: Rep-specific lists/quests
  @@index([source])  // Index: For origin tracking
}

// Core Table 3: Calls (detailed logs; many per lead – no-brainer over aggregates in leads)
model calls {
  id               String        @id @default(uuid()) @db.Uuid  // PK: Auto UUID
  lead_id          String?       @db.Uuid                       // FK: To leads.id (most common)
  properties_id    String?       @db.Uuid                       // FK: To properties.id (fallback if no lead)
  callrail_id      String?       @unique                        // Optional: CallRail external ID
  direction        CallDirection?                                // Enum: Inbound/outbound
  duration         Int?                                          // Required-ish: Seconds
  recording_url    String?                                       // Optional: Playback link
  caller_number    String?                                       // Required: Caller phone
  recipient_number String?                                       // Required: Rep phone
  outcome          CallOutcome?                                  // Enum: For points (e.g., +10 connected)
  notes            String?                                       // Optional: Transcription/rep notes
  transcription    String?                                       // Optional: AI text
  made_by          String?       @db.Uuid                        // FK: To profiles.id (rep attribution)
  points_earned    Int           @default(0)                     // Gamification per call (auto)
  metadata         Json?                                         // Jsonb: { tags: ["motivated"], extras: {} }
  created_at       DateTime      @default(now())                 // Auto: Call time
  updated_at       DateTime      @updatedAt                      // Auto: If edited
  lead             leads?        @relation(fields: [lead_id], references: [id])
  property         properties?   @relation(fields: [properties_id], references: [id])
  profile          Profile?      @relation(fields: [made_by], references: [id])

  @@index([lead_id])  // Index: For per-lead history
  @@index([made_by, outcome])  // Index: Rep performance/quests
  @@index([created_at])  // Index: Time-based (e.g., daily quotas)
}

// Supporting Table 1: Profile (your current model refined/expanded; extends auth.users for reps)
model Profile {  // Kept your naming (capital P) for consistency
  id            String       @id @default(uuid()) @db.Uuid  // PK: UUID for direct linking to Supabase user_id (best practice for relations)
  user_id       String       @unique @db.Uuid                // Renamed from userId for snake_case convention; FK to supabase_auth.user_id (enforces 1:1)
  role          UserRole     @default(novice)                // Enum-ified your string default for type safety/gamification (e.g., >1000 points → apprentice)
  points        Int          @default(0)                     // Kept: Increment server-side on quest completion (e.g., Zillow scrape validates → +50)
  badges        String[]     @default([])                    // Kept: Store as array; queryable for badges leaderboard (e.g., most unique badges)
  created_at    DateTime     @default(now())                 // Suggestion: Added auto timestamps for audit
  updated_at    DateTime     @updatedAt                      // Suggestion: Added for last activity
  leads         leads[]                                      // Relation: Assigned leads
  calls         calls[]                                      // Relation: Made calls
  quests        Quest[]                                      // Relation: Your "AssignedQuests" (one-to-many)
  completions   quest_completions[]                          // Relation: Completed quests (many-to-many)

  @@index([points(sort: Desc)])  // Kept/expanded your index for fast sorting on leaderboards (no-brainer optimization for peer challenges)
  @@index([role])                // Suggestion: For role-based filters (e.g., elite access)
}

// Supporting Table 2: Quest (your current model refined; for trackable challenges)
model Quest {  // Kept your naming
  id            String     @id @default(uuid()) @db.Uuid  // PK
  title         String                                   // Kept: e.g., "Scrape 50 Zillow Leads"
  description   String?                                  // Kept: Optional details
  points        Int                                      // Kept: Reward on completion
  criteria      Json?                                    // Kept/expanded: JSON for flexible reqs (e.g., { "log_calls": 10 })
  type          QuestType?                                // Suggestion: Enum for daily/weekly (gamification cadence)
  active        Boolean    @default(true)                // Suggestion: Toggle for seasonal quests
  profile_id    String?    @db.Uuid                      // Renamed from profileId for snake_case; Optional assignment to user
  profile       Profile?   @relation(fields: [profile_id], references: [id], onDelete: SetNull)  // Kept: Loose relation for quest tracking
  completions   quest_completions[]                      // Suggestion: Many-to-many for completions
  created_at    DateTime   @default(now())               // Suggestion: Added auto
  updated_at    DateTime   @updatedAt                    // Suggestion: Added auto

  @@index([type, active])  // Suggestion: For active quests list
}

// Supporting Table 3: Quest Completions (many-to-many junction; no-brainer for tracking without duplication)
model quest_completions {
  id            String     @id @default(uuid()) @db.Uuid  // PK
  quest_id      String     @db.Uuid                        // FK: To quests
  profile_id    String     @db.Uuid                        // FK: To profiles
  completed_at  DateTime   @default(now())                 // Completion time
  evidence      Json?                                      // Jsonb: { linked_calls: ["id1"], points_awarded: 50 }
  quest         Quest      @relation(fields: [quest_id], references: [id])
  profile       Profile    @relation(fields: [profile_id], references: [id])

  @@index([profile_id, completed_at])  // Index: Per-rep history
  @@unique([quest_id, profile_id])     // Unique: No duplicate completions
}

// Supporting Table 4: Badges (earnable unlocks; no-brainer for motivation/elite roles; ties to your Profile badges array)
model badges {
  id             String     @id @default(uuid()) @db.Uuid  // PK
  name           String                                     // e.g., "Lead Closer"
  description    String                                     // Details
  icon_url       String?                                    // Display icon
  requirements   Json?                                      // Jsonb: { min_points: 100, min_quests: 5 }
  created_at     DateTime   @default(now())
  updated_at     DateTime   @updatedAt

  // Note: Link to Profile via badges array (no direct relation needed; push back: Add if you want awarded_badges junction later)
}

// Call Metrics View (computed aggregates from calls; query in Supabase/Prisma raw – no-brainer for dashboards without storage)
// SQL for Supabase (run in editor after tables created): 
// CREATE VIEW call_metrics AS
// SELECT
//   lead_id,
//   COUNT(id) AS total_calls,
//   SUM(CASE WHEN direction = 'outbound' THEN 1 ELSE 0 END) AS total_outbound_calls,
//   SUM(duration) AS total_duration,
//   AVG(duration) AS average_duration,
//   SUM(CASE WHEN outcome = 'connected' THEN 1 ELSE 0 END) AS total_connected_calls,
//   SUM(CASE WHEN outcome = 'voicemail' THEN 1 ELSE 0 END) AS total_voicemails,
//   SUM(CASE WHEN outcome = 'no_answer' THEN 1 ELSE 0 END) AS total_no_answers,
//   MAX(created_at) AS last_call_timestamp,
//   (SELECT outcome FROM calls c2 WHERE c2.lead_id = c.lead_id ORDER BY created_at DESC LIMIT 1) AS last_call_outcome,
//   (SUM(CASE WHEN outcome = 'connected' THEN 1 ELSE 0 END)::float / COUNT(id)) * 100 AS call_success_rate,
//   SUM(points_earned) AS points_earned
// FROM calls c
// GROUP BY lead_id;
// Logic: Aggregates per lead (use in Prisma: await prisma.$queryRaw`SELECT * FROM call_metrics WHERE lead_id = ${leadId}`; real-time via Supabase subs on calls). If Prisma views become native, migrate here.