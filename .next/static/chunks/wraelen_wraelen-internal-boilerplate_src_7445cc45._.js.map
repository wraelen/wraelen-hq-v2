{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/lib/actions.ts"],"sourcesContent":["// src/lib/actions.ts – Server actions for auth (best practice: Centralize mutations – efficient, type-safe; push back: Avoid client auth for cookie sync in Next.js; scales for quests/leaderboards with RLS)\n'use server'; // Logic: Marks as server-only (no client bundle bloat – optimizes for internal app with leads/calls)\nimport { PrismaClient } from '@prisma/client';  // Your DB client (async-safe in actions)\nimport { createServerClient } from '@supabase/ssr'; // SSR package (server-aware – auto-handles cookies via proxy; middleware refreshes post-redirect)\nimport axios from 'axios';  // API/fetch (lightweight – no fetch polyfill needed)\nimport * as cheerio from 'cheerio';  // HTML parse (fast/static – better than Puppeteer for Zillow; handles fallback)\nimport { cookies } from 'next/headers'; // Next utility (dynamic read for session check – set ignored in actions, as middleware handles)\nimport { redirect } from 'next/navigation'; // Server redirect (reliable – no client hacks; best for post-auth flow to dashboard quests)\nimport { z } from 'zod';  // Validation (type-safe inputs – prevents junk data in DB; no-brainer for prod)\nimport crypto from 'crypto';  // Built-in hash (no extra deps – for address_hash dedup)\nimport type { Database } from '../types/database.types'; // Types (autocompletes e.g., session.user.id for Prisma sync – now fixed via your gen)\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!; // Logic: Required env (fail-fast if missing – matches middleware guard)\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n// Action: Server-side login (logic: FormData input for easy <form> binding; validates minimally, mutates, returns error or redirects – middleware syncs cookies on next request)\nexport async function signInAction(formData: FormData) {\n  const email = formData.get('email')?.toString() ?? ''; // Logic: Safe extraction (push back: Add zod here for prod validation – prevents invalid emails in rep onboarding; keeps it server-side for security)\n  const password = formData.get('password')?.toString() ?? '';\n  if (!email || !password) {\n    return { error: 'Email and password are required' }; // Logic: Early validation return (client will display – no redirect/reload; UX-friendly for form feedback)\n  }\n  if (password.length < 6) {\n    return { error: 'Password must be at least 6 characters' }; // Logic: Basic check (expand for strength in gamified app – e.g., tie to \"security quest\" badge)\n  }\n  const cookieStore = cookies(); // Logic: Next headers (dynamic – reads current request cookies for session check)\n  const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {\n    cookies: {\n      getAll: () => cookieStore.getAll(), // Logic: Pass current cookies (enables session read – fixes undefined in middleware)\n      setAll: (cookiesToSet) => {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options)); // Logic: Attempts set (succeeds in components; ignored in actions via catch – middleware refreshes on redirect)\n        } catch {\n          // The `set` method was called from a Server Action. Ignore – middleware will refresh session on next request.\n        }\n      },\n    },\n  });\n  const { error } = await supabase.auth.signInWithPassword({ email, password }); // Logic: Server mutation (hashes/JWT auto – no custom logic; ties to Supabase users table for RLS on quests)\n  if (error) {\n    return { error: error.message }; // Logic: Return error (client handles display – e.g., \"Invalid credentials\"; best for debugging without reload spam)\n  }\n  redirect('/dashboard'); // Logic: Success redirect (middleware now sees session – seamless to game HQ; change to '/hq' or dynamic based on rep level if needed)\n}\n\n// ... (Add the following at the end – new extraction action)\n\n// src/lib/actions.ts (continued) – Add extraction here – best practice: Centralize mutations for scalability; push back: API-first for compliance/TOS, scrape fallback with anti-bot headers – handles single/batch links, merges via Prisma upsert\nconst prisma = new PrismaClient();  // Global instance (efficient in Next.js actions – auto-closes)\n\nconst extractSchema = z.object({\n  links: z.string().min(1),\n  source: z.enum(['zillow', 'propstream', 'both']).default('zillow'),\n});  // Logic: Zod schema (validates formData – quick errors without DB hits)\n\n// Action: Extract and merge from links (logic: Parse batch → per-link extract → upsert properties (merge on hash) → create leads (link FK, award points) – returns results for UX feedback)\nexport async function extractDataAction(formData: FormData) {\n  const validated = extractSchema.safeParse({\n    links: formData.get('links')?.toString() ?? '',\n    source: formData.get('source')?.toString() ?? 'zillow',\n  });  // Logic: Safe parse (returns { success, data } or { error } – client displays errors)\n\n  if (!validated.success) {\n    return { error: validated.error.format() };  // Logic: Return zod errors (e.g., \"Links required\" – no redirect)\n  }\n\n  const { links, source } = validated.data;\n  const linkArray = links.split(',').map(l => l.trim()).filter(Boolean);  // Logic: Batch parse (handle \"url1, url2\" – scalable to 10-20 max for rates)\n  const results = [];  // Aggregate for response (e.g., [{ leadId, success: true }])\n\n  for (const link of linkArray) {  // Logic: Sequential for simplicity (push back: Promise.all for parallel if no rate limits; add try-catch per-link)\n    try {\n      const extracted = await extractFromLink(link, source);  // Helper below (API/scrape merge)\n      const address = extracted.address || '';  // Normalize (fallback to empty – validation later)\n      if (!address) throw new Error('No address extracted');\n\n      const addressHash = crypto.createHash('sha256').update(address.toLowerCase()).digest('hex');  // Logic: Dedup hash (case-insensitive – prevents \"123 Main\" vs \"123 main\" dups)\n\n      // Upsert properties (merge extracted data – no-brainer for updates from re-extracts)\n      const property = await prisma.properties.upsert({\n        where: { address_hash: addressHash },\n        update: {\n          // Logic: Selective merge (overwrite non-null extracted fields – preserves manual edits if needed)\n          city: extracted.city ?? undefined,\n          state: extracted.state ?? undefined,\n          zip_code: extracted.zip_code ?? undefined,\n          property_type: extracted.property_type ?? undefined,\n          bedrooms: extracted.bedrooms ?? undefined,\n          bathrooms: extracted.bathrooms ?? undefined,\n          square_feet: extracted.square_feet ?? undefined,\n          lot_size: extracted.lot_size ?? undefined,\n          year_built: extracted.year_built ?? undefined,\n          zestimate: extracted.zestimate ?? undefined,\n          avm: extracted.avm ?? undefined,\n          tax_assessed_value: extracted.tax_assessed_value ?? undefined,\n          distress_signals: extracted.distress_signals ?? undefined,\n          owner_occupied: extracted.owner_occupied ?? undefined,\n          metadata: extracted.metadata ?? undefined,  // Full raw (jsonb merge)\n        },\n        create: {\n          address,\n          city: extracted.city || '',\n          state: extracted.state || '',\n          zip_code: extracted.zip_code || '',\n          property_type: extracted.property_type || 'other',\n          bedrooms: extracted.bedrooms,\n          bathrooms: extracted.bathrooms,\n          square_feet: extracted.square_feet,\n          lot_size: extracted.lot_size,\n          year_built: extracted.year_built,\n          zestimate: extracted.zestimate,\n          avm: extracted.avm,\n          tax_assessed_value: extracted.tax_assessed_value,\n          distress_signals: extracted.distress_signals,\n          owner_occupied: extracted.owner_occupied,\n          metadata: extracted.metadata,  // e.g., { original_link: link, sources: [source] }\n          address_hash: addressHash,\n        },\n      });\n\n      // Create lead (link to property – assign to current user via session; award base points)\n      const cookieStore = cookies(); // Logic: Reuse your Supabase client setup for session fetch (consistent with signInAction)\n      const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {\n        cookies: {\n          getAll: () => cookieStore.getAll(),\n          setAll: (cookiesToSet) => {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options));\n            } catch {\n              // Ignore set in action\n            }\n          },\n        },\n      });\n      const { data: { session } } = await supabase.auth.getSession(); // Logic: Fetch session (async-safe – gets user ID for assigned_to)\n      if (!session?.user.id) {\n        return { error: 'No active session – login required for assignment' }; // Logic: Guard (push back: Or default to admin UUID for testing)\n      }\n\n      const lead = await prisma.leads.create({\n        data: {\n          properties_id: property.id,\n          lead_type: extracted.lead_type || 'owner',  // Infer from extract (e.g., seller lead)\n          first_name: extracted.first_name,\n          last_name: extracted.last_name,\n          phone: extracted.phone,\n          source: extracted.source || source,  // Track actual (e.g., 'zillow_api')\n          metadata: { original_link: link, extracted_data: extracted },  // Audit trail\n          assigned_to: session.user.id,  // From auth (ties to Profile)\n          points_earned: 10,  // Base for import (trigger more on status changes)\n        },\n      });\n\n      results.push({ leadId: lead.id, success: true });  // For client display (e.g., \"Imported lead X\")\n    } catch (error) {\n      results.push({ link, success: false, error: (error as Error).message });  // Per-link feedback\n    }\n  }\n\n  return { results };  // Logic: Return array (client loops to show success/errors – no full redirect for batch UX)\n}\n\n// Helper: Extract from single link (logic: Source switch → API or scrape → normalize output – expandable for Propstream)\nasync function extractFromLink(link: string, source: 'zillow' | 'propstream' | 'both') {\n  let data: Record<string, any> = { source, metadata: { link } };  // Base output (json-friendly)\n\n  if (source === 'zillow' || source === 'both') {\n    const zillowKey = process.env.ZILLOW_API_KEY;\n    if (zillowKey) {\n      // Logic: API preferred (compliance – e.g., Bridge API for records; adjust endpoint per your key/access)\n      try {\n        const response = await axios.get(`https://api.bridgeapi.io/v1/public-records/property?url=${encodeURIComponent(link)}`, {  // Example endpoint; check Zillow docs\n          headers: { 'X-RapidAPI-Key': zillowKey },  // Auth (rate-limit aware)\n        });\n        data = { ...data, ...response.data };  // Merge (e.g., { address, zestimate, bedrooms, ... })\n        data.source = 'zillow_api';  // Track for points (bonus for API vs scrape)\n      } catch {}  // Fallback to scrape on error\n    }\n\n    if (!data.address) {  // Scrape fallback (push back: Use proxies like BrightData if bans occur – not for prod volume)\n      const { data: html } = await axios.get(link, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' } });  // Anti-bot UA\n      const $ = cheerio.load(html);\n      // Parse selectors (customize per Zillow page – inspect element for stability; e.g., for homedetails page)\n      data.address = $('[data-testid=\"hdp-address\"]').text().trim() || '';\n      data.zestimate = $('.zestimate-value').text().replace(/[^0-9]/g, '') || null;  // Clean $ (parseInt later)\n      data.bedrooms = parseInt($('[data-testid=\"bed-bath-item\"]:first').text()) || null;\n      // ... Add more: bathrooms, square_feet, etc. (expand as needed – test with real links)\n      data.metadata.scrape_time = new Date().toISOString();  // Audit\n    }\n  }\n\n  if (source === 'propstream' || source === 'both') {\n    // Logic: No public API (stub for CSV upload – push back: Implement file input in form if needed; contact Propstream for integration)\n    // For now: Assume manual/link parse if possible (e.g., if link is Propstream export URL – rare)\n    data.avm = 0;  // Mock (replace with real if API unlocked)\n    data.distress_signals = { pre_foreclosure: false };  // Mock\n  }\n\n  return data;  // Normalized (e.g., { address: '123 Main', zestimate: 450000, ... })\n}"],"names":[],"mappings":";;;;;;;IAuDsB,oBAAA,WAAA,GAAA,IAAA,kfAAA,EAAA,8CAAA,ueAAA,EAAA,KAAA,GAAA,6eAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/app/extract/page.tsx"],"sourcesContent":["// src/app/extract/page.tsx – Extraction form (client-side for interactivity; binds server action – best hybrid for Next.js; protected via middleware)\n'use client';  // Logic: Client (hooks for state/form – no SSR overhead; push back: Full server if no batch UX needed)\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useState } from 'react';\nimport { useForm } from 'react-hook-form';  // Dep not added yet? pnpm add react-hook-form @hookform/resolvers/zod (for zod integration)\nimport { z } from 'zod';  // Shared schema (client validation duplicates server for speed – prevents bad submits)\nimport { extractDataAction } from '@/lib/actions';  // Imported action\n\nconst extractSchema = z.object({  // Dupe from action (push back: Extract to shared util if bloat)\n  links: z.string().min(1, 'Enter at least one link'),\n  source: z.enum(['zillow', 'propstream', 'both']),\n});  // Type: Infer for form\ntype FormData = z.infer<typeof extractSchema>;\n\nexport default function ExtractPage() {\n  const [results, setResults] = useState<any[]>([]);  // Post-submit feedback (success/errors)\n  const [error, setError] = useState<string | null>(null);\n  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<FormData>({\n    resolver: zodResolver(extractSchema),\n    defaultValues: { source: 'zillow' },\n  });\n\n  const onSubmit = async (data: FormData) => {\n    setError(null);\n    setResults([]);\n    const formData = new FormData();  // Logic: Native for action (though useForm has data – adaptable)\n    formData.append('links', data.links);\n    formData.append('source', data.source);\n    const result = await extractDataAction(formData);  // Call action\n\n    if (result.error) {\n      setError('Validation failed: ' + JSON.stringify(result.error));  // Display zod\n    } else {\n      setResults(result.results || []);  // Show batch outcomes (e.g., \"Lead X imported\")\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-black text-green-400 font-mono\">\n      <form onSubmit={handleSubmit(onSubmit)} className=\"p-8 border-2 border-green-500 rounded-lg shadow-[0_0_15px_rgba(0,255,0,0.7)] bg-black/80 w-96\">\n        <h2 className=\"text-2xl mb-6 text-center\">Extract Leads Quest</h2>\n        <textarea\n          {...register('links')}\n          placeholder=\"Enter Zillow/Propstream links (comma-separated for batch)\"\n          className=\"w-full mb-4 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\"\n        />\n        {errors.links && <p className=\"text-red-500 mb-4\">{errors.links.message}</p>}\n        <select {...register('source')} className=\"w-full mb-6 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\">\n          <option value=\"zillow\">Zillow</option>\n          <option value=\"propstream\">Propstream</option>\n          <option value=\"both\">Both</option>\n        </select>\n        <button type=\"submit\" disabled={isSubmitting} className=\"w-full p-2 bg-green-500 text-black hover:bg-green-600\">\n          {isSubmitting ? 'Extracting...' : 'Start Extraction'}\n        </button>\n        {error && <p className=\"text-red-500 mt-4\">{error}</p>}\n        {results.length > 0 && (\n          <ul className=\"mt-4\">\n            {results.map((res, i) => (\n              <li key={i} className={res.success ? 'text-green-400' : 'text-red-500'}>\n                {res.success ? `Lead ${res.leadId} imported!` : `Error on link: ${res.error}`}\n              </li>\n            ))}\n          </ul>\n        )}\n      </form>\n    </div>\n  );\n}"],"names":[],"mappings":"AAAA,sJAAsJ;;;;;;AAGtJ;AACA;AACA,8fAA4C,4FAA4F;AACxI,odAA0B,uFAAuF;AACjH,wVAAoD,kBAAkB;;;AANtE,cAAe,uGAAuG;;;;;;AAQtH,MAAM,gBAAgB,uRAAC,CAAC,MAAM,CAAC;IAC7B,OAAO,uRAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACzB,QAAQ,uRAAC,CAAC,IAAI,CAAC;QAAC;QAAU;QAAc;KAAO;AACjD,IAAK,uBAAuB;AAGb,SAAS;;IACtB,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yaAAQ,EAAQ,EAAE,GAAI,wCAAwC;IAC5F,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yaAAQ,EAAgB;IAClD,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,EAAE,EAAE,GAAG,IAAA,sTAAO,EAAW;QACxF,UAAU,IAAA,kWAAW,EAAC;QACtB,eAAe;YAAE,QAAQ;QAAS;IACpC;IAEA,MAAM,WAAW,OAAO;QACtB,SAAS;QACT,WAAW,EAAE;QACb,MAAM,WAAW,IAAI,YAAa,iEAAiE;QACnG,SAAS,MAAM,CAAC,SAAS,KAAK,KAAK;QACnC,SAAS,MAAM,CAAC,UAAU,KAAK,MAAM;QACrC,MAAM,SAAS,MAAM,IAAA,2NAAiB,EAAC,WAAY,cAAc;QAEjE,IAAI,OAAO,KAAK,EAAE;YAChB,SAAS,wBAAwB,KAAK,SAAS,CAAC,OAAO,KAAK,IAAK,cAAc;QACjF,OAAO;YACL,WAAW,OAAO,OAAO,IAAI,EAAE,GAAI,gDAAgD;QACrF;IACF;IAEA,qBACE,6bAAC;QAAI,WAAU;kBACb,cAAA,6bAAC;YAAK,UAAU,aAAa;YAAW,WAAU;;8BAChD,6bAAC;oBAAG,WAAU;8BAA4B;;;;;;8BAC1C,6bAAC;oBACE,GAAG,SAAS,QAAQ;oBACrB,aAAY;oBACZ,WAAU;;;;;;gBAEX,OAAO,KAAK,kBAAI,6bAAC;oBAAE,WAAU;8BAAqB,OAAO,KAAK,CAAC,OAAO;;;;;;8BACvE,6bAAC;oBAAQ,GAAG,SAAS,SAAS;oBAAE,WAAU;;sCACxC,6bAAC;4BAAO,OAAM;sCAAS;;;;;;sCACvB,6bAAC;4BAAO,OAAM;sCAAa;;;;;;sCAC3B,6bAAC;4BAAO,OAAM;sCAAO;;;;;;;;;;;;8BAEvB,6bAAC;oBAAO,MAAK;oBAAS,UAAU;oBAAc,WAAU;8BACrD,eAAe,kBAAkB;;;;;;gBAEnC,uBAAS,6bAAC;oBAAE,WAAU;8BAAqB;;;;;;gBAC3C,QAAQ,MAAM,GAAG,mBAChB,6bAAC;oBAAG,WAAU;8BACX,QAAQ,GAAG,CAAC,CAAC,KAAK,kBACjB,6bAAC;4BAAW,WAAW,IAAI,OAAO,GAAG,mBAAmB;sCACrD,IAAI,OAAO,GAAG,AAAC,QAAkB,OAAX,IAAI,MAAM,EAAC,gBAAc,AAAC,kBAA2B,OAAV,IAAI,KAAK;2BADpE;;;;;;;;;;;;;;;;;;;;;AASvB;GAtDwB;;QAGkD,sTAAO;;;KAHzD","debugId":null}}]
}