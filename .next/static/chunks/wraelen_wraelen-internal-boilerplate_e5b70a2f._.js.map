{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/lib/actions.ts"],"sourcesContent":["// src/lib/actions.ts – Server actions for auth (best practice: Centralize mutations – efficient, type-safe; push back: Avoid client auth for cookie sync in Next.js; scales for quests/leaderboards with RLS)\n'use server'; // Logic: Marks as server-only (no client bundle bloat – optimizes for internal app with leads/calls)\nimport { PrismaClient } from '@prisma/client';  // Your DB client (async-safe in actions)\nimport { createServerClient } from '@supabase/ssr'; // SSR package (server-aware – auto-handles cookies via proxy; middleware refreshes post-redirect)\nimport axios from 'axios';  // API/fetch (lightweight – no fetch polyfill needed)\nimport * as cheerio from 'cheerio';  // HTML parse (fast/static – better than Puppeteer for Zillow; handles fallback)\nimport { cookies } from 'next/headers'; // Next utility (dynamic read for session check – set ignored in actions, as middleware handles)\nimport { redirect } from 'next/navigation'; // Server redirect (reliable – no client hacks; best for post-auth flow to dashboard quests)\nimport { z } from 'zod';  // Validation (type-safe inputs – prevents junk data in DB; no-brainer for prod)\nimport crypto from 'crypto';  // Built-in hash (no extra deps – for address_hash dedup)\nimport type { Database } from '../types/database.types'; // Types (autocompletes e.g., session.user.id for Prisma sync – now fixed via your gen)\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!; // Logic: Required env (fail-fast if missing – matches middleware guard)\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n// Action: Server-side login (logic: FormData input for easy <form> binding; validates minimally, mutates, returns error or redirects – middleware syncs cookies on next request)\nexport async function signInAction(formData: FormData) {\n  const email = formData.get('email')?.toString() ?? ''; // Logic: Safe extraction (push back: Add zod here for prod validation – prevents invalid emails in rep onboarding; keeps it server-side for security)\n  const password = formData.get('password')?.toString() ?? '';\n  if (!email || !password) {\n    return { error: 'Email and password are required' }; // Logic: Early validation return (client will display – no redirect/reload; UX-friendly for form feedback)\n  }\n  if (password.length < 6) {\n    return { error: 'Password must be at least 6 characters' }; // Logic: Basic check (expand for strength in gamified app – e.g., tie to \"security quest\" badge)\n  }\n  const cookieStore = cookies(); // Logic: Next headers (dynamic – reads current request cookies for session check)\n  const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {\n    cookies: {\n      getAll: () => cookieStore.getAll(), // Logic: Pass current cookies (enables session read – fixes undefined in middleware)\n      setAll: (cookiesToSet) => {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options)); // Logic: Attempts set (succeeds in components; ignored in actions via catch – middleware refreshes on redirect)\n        } catch {\n          // The `set` method was called from a Server Action. Ignore – middleware will refresh session on next request.\n        }\n      },\n    },\n  });\n  const { error } = await supabase.auth.signInWithPassword({ email, password }); // Logic: Server mutation (hashes/JWT auto – no custom logic; ties to Supabase users table for RLS on quests)\n  if (error) {\n    return { error: error.message }; // Logic: Return error (client handles display – e.g., \"Invalid credentials\"; best for debugging without reload spam)\n  }\n  redirect('/dashboard'); // Logic: Success redirect (middleware now sees session – seamless to game HQ; change to '/hq' or dynamic based on rep level if needed)\n}\n\n// ... (Add the following at the end – new extraction action)\n\n// src/lib/actions.ts (continued) – Add extraction here – best practice: Centralize mutations for scalability; push back: API-first for compliance/TOS, scrape fallback with anti-bot headers – handles single/batch links, merges via Prisma upsert\nconst prisma = new PrismaClient();  // Global instance (efficient in Next.js actions – auto-closes)\n\nconst extractSchema = z.object({\n  links: z.string().min(1),\n  source: z.enum(['zillow', 'propstream', 'both']).default('zillow'),\n});  // Logic: Zod schema (validates formData – quick errors without DB hits)\n\n// Action: Extract and merge from links (logic: Parse batch → per-link extract → upsert properties (merge on hash) → create leads (link FK, award points) – returns results for UX feedback)\nexport async function extractDataAction(formData: FormData) {\n  const validated = extractSchema.safeParse({\n    links: formData.get('links')?.toString() ?? '',\n    source: formData.get('source')?.toString() ?? 'zillow',\n  });  // Logic: Safe parse (returns { success, data } or { error } – client displays errors)\n\n  if (!validated.success) {\n    return { error: validated.error.format() };  // Logic: Return zod errors (e.g., \"Links required\" – no redirect)\n  }\n\n  const { links, source } = validated.data;\n  const linkArray = links.split(',').map(l => l.trim()).filter(Boolean);  // Logic: Batch parse (handle \"url1, url2\" – scalable to 10-20 max for rates)\n  const results = [];  // Aggregate for response (e.g., [{ leadId, success: true }])\n\n  for (const link of linkArray) {  // Logic: Sequential for simplicity (push back: Promise.all for parallel if no rate limits; add try-catch per-link)\n    try {\n      const extracted = await extractFromLink(link, source);  // Helper below (API/scrape merge)\n      const address = extracted.address || '';  // Normalize (fallback to empty – validation later)\n      if (!address) throw new Error('No address extracted');\n\n      const addressHash = crypto.createHash('sha256').update(address.toLowerCase()).digest('hex');  // Logic: Dedup hash (case-insensitive – prevents \"123 Main\" vs \"123 main\" dups)\n\n      // Upsert properties (merge extracted data – no-brainer for updates from re-extracts)\n      const property = await prisma.properties.upsert({\n        where: { address_hash: addressHash },\n        update: {\n          // Logic: Selective merge (overwrite non-null extracted fields – preserves manual edits if needed)\n          city: extracted.city ?? undefined,\n          state: extracted.state ?? undefined,\n          zip_code: extracted.zip_code ?? undefined,\n          property_type: extracted.property_type ?? undefined,\n          bedrooms: extracted.bedrooms ?? undefined,\n          bathrooms: extracted.bathrooms ?? undefined,\n          square_feet: extracted.square_feet ?? undefined,\n          lot_size: extracted.lot_size ?? undefined,\n          year_built: extracted.year_built ?? undefined,\n          zestimate: extracted.zestimate ?? undefined,\n          avm: extracted.avm ?? undefined,\n          tax_assessed_value: extracted.tax_assessed_value ?? undefined,\n          distress_signals: extracted.distress_signals ?? undefined,\n          owner_occupied: extracted.owner_occupied ?? undefined,\n          metadata: extracted.metadata ?? undefined,  // Full raw (jsonb merge)\n        },\n        create: {\n          address,\n          city: extracted.city || '',\n          state: extracted.state || '',\n          zip_code: extracted.zip_code || '',\n          property_type: extracted.property_type || 'other',\n          bedrooms: extracted.bedrooms,\n          bathrooms: extracted.bathrooms,\n          square_feet: extracted.square_feet,\n          lot_size: extracted.lot_size,\n          year_built: extracted.year_built,\n          zestimate: extracted.zestimate,\n          avm: extracted.avm,\n          tax_assessed_value: extracted.tax_assessed_value,\n          distress_signals: extracted.distress_signals,\n          owner_occupied: extracted.owner_occupied,\n          metadata: extracted.metadata,  // e.g., { original_link: link, sources: [source] }\n          address_hash: addressHash,\n        },\n      });\n\n      // Create lead (link to property – assign to current user via session; award base points)\n      const cookieStore = cookies(); // Logic: Reuse your Supabase client setup for session fetch (consistent with signInAction)\n      const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {\n        cookies: {\n          getAll: () => cookieStore.getAll(),\n          setAll: (cookiesToSet) => {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options));\n            } catch {\n              // Ignore set in action\n            }\n          },\n        },\n      });\n      const { data: { session } } = await supabase.auth.getSession(); // Logic: Fetch session (async-safe – gets user ID for assigned_to)\n      if (!session?.user.id) {\n        return { error: 'No active session – login required for assignment' }; // Logic: Guard (push back: Or default to admin UUID for testing)\n      }\n\n      const lead = await prisma.leads.create({\n        data: {\n          properties_id: property.id,\n          lead_type: extracted.lead_type || 'owner',  // Infer from extract (e.g., seller lead)\n          first_name: extracted.first_name,\n          last_name: extracted.last_name,\n          phone: extracted.phone,\n          source: extracted.source || source,  // Track actual (e.g., 'zillow_api')\n          metadata: { original_link: link, extracted_data: extracted },  // Audit trail\n          assigned_to: session.user.id,  // From auth (ties to Profile)\n          points_earned: 10,  // Base for import (trigger more on status changes)\n        },\n      });\n\n      results.push({ leadId: lead.id, success: true });  // For client display (e.g., \"Imported lead X\")\n    } catch (error) {\n      results.push({ link, success: false, error: (error as Error).message });  // Per-link feedback\n    }\n  }\n\n  return { results };  // Logic: Return array (client loops to show success/errors – no full redirect for batch UX)\n}\n\n// Helper: Extract from single link (logic: Source switch → API or scrape → normalize output – expandable for Propstream)\nasync function extractFromLink(link: string, source: 'zillow' | 'propstream' | 'both') {\n  let data: Record<string, any> = { source, metadata: { link } };  // Base output (json-friendly)\n\n  if (source === 'zillow' || source === 'both') {\n    const zillowKey = process.env.ZILLOW_API_KEY;\n    if (zillowKey) {\n      // Logic: API preferred (compliance – e.g., Bridge API for records; adjust endpoint per your key/access)\n      try {\n        const response = await axios.get(`https://api.bridgeapi.io/v1/public-records/property?url=${encodeURIComponent(link)}`, {  // Example endpoint; check Zillow docs\n          headers: { 'X-RapidAPI-Key': zillowKey },  // Auth (rate-limit aware)\n        });\n        data = { ...data, ...response.data };  // Merge (e.g., { address, zestimate, bedrooms, ... })\n        data.source = 'zillow_api';  // Track for points (bonus for API vs scrape)\n      } catch {}  // Fallback to scrape on error\n    }\n\n    if (!data.address) {  // Scrape fallback (push back: Use proxies like BrightData if bans occur – not for prod volume)\n      const { data: html } = await axios.get(link, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' } });  // Anti-bot UA\n      const $ = cheerio.load(html);\n      // Parse selectors (customize per Zillow page – inspect element for stability; e.g., for homedetails page)\n      data.address = $('[data-testid=\"hdp-address\"]').text().trim() || '';\n      data.zestimate = $('.zestimate-value').text().replace(/[^0-9]/g, '') || null;  // Clean $ (parseInt later)\n      data.bedrooms = parseInt($('[data-testid=\"bed-bath-item\"]:first').text()) || null;\n      // ... Add more: bathrooms, square_feet, etc. (expand as needed – test with real links)\n      data.metadata.scrape_time = new Date().toISOString();  // Audit\n    }\n  }\n\n  if (source === 'propstream' || source === 'both') {\n    // Logic: No public API (stub for CSV upload – push back: Implement file input in form if needed; contact Propstream for integration)\n    // For now: Assume manual/link parse if possible (e.g., if link is Propstream export URL – rare)\n    data.avm = 0;  // Mock (replace with real if API unlocked)\n    data.distress_signals = { pre_foreclosure: false };  // Mock\n  }\n\n  return data;  // Normalized (e.g., { address: '123 Main', zestimate: 450000, ... })\n}"],"names":[],"mappings":";;;;;;;IAesB,eAAA,WAAA,GAAA,IAAA,kfAAA,EAAA,8CAAA,ueAAA,EAAA,KAAA,GAAA,6eAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/app/auth/signin/page.tsx"],"sourcesContent":["// src/app/auth/signin/page.tsx – Login form (client-side for state/UX; binds server action for mutation – best hybrid for Next.js, fixes cookie bug without full server component)\n'use client';  // Logic: Client (enables hooks like useState/useRouter – interactive errors without reload; push back: If no complex state, could go full server for perf)\n\nimport { useRouter } from 'next/navigation';  // Logic: Router for client push/refresh (smooth transition – e.g., to leaderboard; no reload on success; satisfies ESLint by using refresh() fallback)\nimport { useState } from 'react';\nimport { signInAction } from '@/lib/actions';  // Imported server action (executes server-side – handles cookies/redirect; scalable for more forms)\n\nexport default function SignIn() {\n  const router = useRouter();  // Logic: Used for success push + refresh (avoids stale UI post-auth – better for game-like flow; fixes \"assigned but unused\")\n  const [email, setEmail] = useState('');  // Logic: Controlled input (realtime validation if expanded – e.g., email format check for \"quest eligibility\")\n  const [password, setPassword] = useState('');  // Logic: Controlled input (same as above)\n  const [error, setError] = useState<string | null>(null);  // Logic: Local error state (displays without reload – improves rep login experience; fixes \"assigned but unused\" by setting conditionally)\n\n  const handleSignIn = async (e: React.FormEvent<HTMLFormElement>) => {  // Logic: Async handler (waits for action – sets local error if fails)\n    e.preventDefault();\n    if (!email || !password) {  // Logic: Client validation (quick feedback – prevents unnecessary server calls; duplicates server for speed; uses state vars to satisfy ESLint)\n      setError('Email and password are required');\n      return;\n    }\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters');\n      return;\n    }\n\n    const formData = new FormData(e.currentTarget);  // Logic: Native FormData (binds inputs – no manual state sync; efficient)\n    const result = await signInAction(formData);  // Logic: Call server action (runs server-side – returns { error } or redirects on success)\n\n    if (result?.error) {\n      setError(result.error);  // Logic: Display error client-side (no reload – e.g., \"Invalid credentials\"; ties to game theme, like \"Access Denied: Retry Quest\")\n    } else {\n      router.refresh();  // Logic: Optimistic refresh (syncs any server data if dashboard has SSR fetches – e.g., load quests; satisfies ESLint usage)\n      router.push('/dashboard');  // Logic: Client push on success (smooth – cookies sync'd via middleware; fallback if redirect fails)\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-black text-green-400 font-mono\">\n      <form onSubmit={handleSignIn} className=\"p-8 border-2 border-green-500 rounded-lg shadow-[0_0_15px_rgba(0,255,0,0.7)] bg-black/80\">\n        <h2 className=\"text-2xl mb-6 text-center\">Enter Wraelen HQ</h2>\n        {error && <p className=\"text-red-500 mb-4\">{error}</p>}  // Logic: Displays from state (clear feedback – no query params needed)\n        <input\n          name=\"email\"  // Logic: Name attrs (for FormData – kept onChange for controlled inputs/realtime validation if expanded)\n          type=\"email\"\n          placeholder=\"Email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n          className=\"w-full mb-4 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\"\n        />\n        <input\n          name=\"password\"\n          type=\"password\"\n          placeholder=\"Password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          className=\"w-full mb-6 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\"\n        />\n        <button type=\"submit\" className=\"w-full p-2 bg-green-500 text-black hover:bg-green-600\">Login</button>\n      </form>\n    </div>\n  );\n}"],"names":[],"mappings":"AAAA,mLAAmL;;;;;;AAGnL,6pBAA8C,uJAAuJ;AACrM;AACA,wVAA+C,oGAAoG;;;AAJnJ,cAAe,2JAA2J;;;;AAM3J,SAAS;;IACtB,MAAM,SAAS,IAAA,kZAAS,KAAK,8HAA8H;IAC3J,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yaAAQ,EAAC,KAAM,+GAA+G;IACxJ,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yaAAQ,EAAC,KAAM,0CAA0C;IACzF,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yaAAQ,EAAgB,OAAQ,2IAA2I;IAErM,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,SAAS;YACT;QACF;QACA,IAAI,SAAS,MAAM,GAAG,GAAG;YACvB,SAAS;YACT;QACF;QAEA,MAAM,WAAW,IAAI,SAAS,EAAE,aAAa,GAAI,0EAA0E;QAC3H,MAAM,SAAS,MAAM,IAAA,sNAAY,EAAC,WAAY,2FAA2F;QAEzI,IAAI,mBAAA,6BAAA,OAAQ,KAAK,EAAE;YACjB,SAAS,OAAO,KAAK,GAAI,oIAAoI;QAC/J,OAAO;YACL,OAAO,OAAO,IAAK,6HAA6H;YAChJ,OAAO,IAAI,CAAC,eAAgB,qGAAqG;QACnI;IACF;IAEA,qBACE,6bAAC;QAAI,WAAU;kBACb,cAAA,6bAAC;YAAK,UAAU;YAAc,WAAU;;8BACtC,6bAAC;oBAAG,WAAU;8BAA4B;;;;;;gBACzC,uBAAS,6bAAC;oBAAE,WAAU;8BAAqB;;;;;;gBAAW;8BACvD,6bAAC;oBACC,MAAK;oBACL,MAAK;oBACL,aAAY;oBACZ,OAAO;oBACP,UAAU,CAAC,IAAM,SAAS,EAAE,MAAM,CAAC,KAAK;oBACxC,WAAU;;;;;;8BAEZ,6bAAC;oBACC,MAAK;oBACL,MAAK;oBACL,aAAY;oBACZ,OAAO;oBACP,UAAU,CAAC,IAAM,YAAY,EAAE,MAAM,CAAC,KAAK;oBAC3C,WAAU;;;;;;8BAEZ,6bAAC;oBAAO,MAAK;oBAAS,WAAU;8BAAwD;;;;;;;;;;;;;;;;;AAIhG;GArDwB;;QACP,kZAAS;;;KADF","debugId":null}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/next%4015.5.4_%40babel%2Bcore%407.27.1_%40opentelemetry%2Bapi%401.7.0_%40playwright%2Btest%401.52.0_babel-p_68e8c185df7d969f063bfb2ef00a51ed/node_modules/next/navigation.js"],"sourcesContent":["module.exports = require('./dist/client/components/navigation')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/next%4015.5.4_%40babel%2Bcore%407.27.1_%40opentelemetry%2Bapi%401.7.0_%40playwright%2Btest%401.52.0_babel-p_68e8c185df7d969f063bfb2ef00a51ed/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0],"debugId":null}}]
}