{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/dispatcher.js"],"sourcesContent":["'use strict'\nconst EventEmitter = require('node:events')\nconst WrapHandler = require('../handler/wrap-handler')\n\nconst wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler))\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n\n  compose (...args) {\n    // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n    const interceptors = Array.isArray(args[0]) ? args[0] : args\n    let dispatch = this.dispatch.bind(this)\n\n    for (const interceptor of interceptors) {\n      if (interceptor == null) {\n        continue\n      }\n\n      if (typeof interceptor !== 'function') {\n        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`)\n      }\n\n      dispatch = interceptor(dispatch)\n      dispatch = wrapInterceptor(dispatch)\n\n      if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n        throw new TypeError('invalid interceptor')\n      }\n    }\n\n    return new Proxy(this, {\n      get: (target, key) => key === 'dispatch' ? dispatch : target[key]\n    })\n  }\n}\n\nmodule.exports = Dispatcher\n"],"names":[],"mappings":"AACA,MAAM;AACN,MAAM;AAEN,MAAM,kBAAkB,CAAC,WAAa,CAAC,MAAM,UAAY,SAAS,MAAM,YAAY,IAAI,CAAC;AAEzF,MAAM,mBAAmB;IACvB,WAAY;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,QAAS;QACP,MAAM,IAAI,MAAM;IAClB;IAEA,UAAW;QACT,MAAM,IAAI,MAAM;IAClB;IAEA,QAAS,GAAG,IAAI,EAAE;QAChB,+EAA+E;QAC/E,MAAM,eAAe,MAAM,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,EAAE,GAAG;QACxD,IAAI,WAAW,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;QAEtC,KAAK,MAAM,eAAe,aAAc;YACtC,IAAI,eAAe,MAAM;gBACvB;YACF;YAEA,IAAI,OAAO,gBAAgB,YAAY;gBACrC,MAAM,IAAI,UAAU,CAAC,gDAAgD,EAAE,OAAO,aAAa;YAC7F;YAEA,WAAW,YAAY;YACvB,WAAW,gBAAgB;YAE3B,IAAI,YAAY,QAAQ,OAAO,aAAa,cAAc,SAAS,MAAM,KAAK,GAAG;gBAC/E,MAAM,IAAI,UAAU;YACtB;QACF;QAEA,OAAO,IAAI,MAAM,IAAI,EAAE;YACrB,KAAK,CAAC,QAAQ,MAAQ,QAAQ,aAAa,WAAW,MAAM,CAAC,IAAI;QACnE;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/dispatcher-base.js"],"sourcesContent":["'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst UnwrapHandler = require('../handler/unwrap-handler')\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = require('../core/errors')\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = require('../core/symbols')\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\n\nclass DispatcherBase extends Dispatcher {\n  /** @type {boolean} */\n  [kDestroyed] = false;\n\n  /** @type {Array|null} */\n  [kOnDestroyed] = null;\n\n  /** @type {boolean} */\n  [kClosed] = false;\n\n  /** @type {Array} */\n  [kOnClosed] = []\n\n  /** @returns {boolean} */\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  /** @returns {boolean} */\n  get closed () {\n    return this[kClosed]\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    handler = UnwrapHandler.unwrap(handler)\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw err\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM,EACJ,oBAAoB,EACpB,iBAAiB,EACjB,oBAAoB,EACrB;AACD,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE;AAE1D,MAAM,eAAe,OAAO;AAC5B,MAAM,YAAY,OAAO;AAEzB,MAAM,uBAAuB;IAC3B,oBAAoB,GACpB,CAAC,WAAW,GAAG,MAAM;IAErB,uBAAuB,GACvB,CAAC,aAAa,GAAG,KAAK;IAEtB,oBAAoB,GACpB,CAAC,QAAQ,GAAG,MAAM;IAElB,kBAAkB,GAClB,CAAC,UAAU,GAAG,EAAE,CAAA;IAEhB,uBAAuB,GACvB,IAAI,YAAa;QACf,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA,uBAAuB,GACvB,IAAI,SAAU;QACZ,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA,MAAO,QAAQ,EAAE;QACf,IAAI,aAAa,WAAW;YAC1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK;oBACf,OAAO,MAAM,OAAO,OAAO,QAAQ;gBACrC;YACF;QACF;QAEA,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,eAAe,IAAM,SAAS,IAAI,wBAAwB;YAC1D;QACF;QAEA,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,IAAI,CAAC,UAAU,EAAE;gBACnB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YACvB,OAAO;gBACL,eAAe,IAAM,SAAS,MAAM;YACtC;YACA;QACF;QAEA,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QAErB,MAAM,WAAW;YACf,MAAM,YAAY,IAAI,CAAC,UAAU;YACjC,IAAI,CAAC,UAAU,GAAG;YAClB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;gBACzC,SAAS,CAAC,EAAE,CAAC,MAAM;YACrB;QACF;QAEA,oBAAoB;QACpB,IAAI,CAAC,OAAO,GACT,IAAI,CAAC,IAAM,IAAI,CAAC,OAAO,IACvB,IAAI,CAAC;YACJ,eAAe;QACjB;IACJ;IAEA,QAAS,GAAG,EAAE,QAAQ,EAAE;QACtB,IAAI,OAAO,QAAQ,YAAY;YAC7B,WAAW;YACX,MAAM;QACR;QAEA,IAAI,aAAa,WAAW;YAC1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK;oBACtB,OAAO,MAAM,4CAA4C,GAAG,OAAO,OAAO,QAAQ;gBACpF;YACF;QACF;QAEA,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;YAC1B,OAAO;gBACL,eAAe,IAAM,SAAS,MAAM;YACtC;YACA;QACF;QAEA,IAAI,CAAC,KAAK;YACR,MAAM,IAAI;QACZ;QAEA,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,IAAI,EAAE;QAC7C,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;QAExB,MAAM,cAAc;YAClB,MAAM,YAAY,IAAI,CAAC,aAAa;YACpC,IAAI,CAAC,aAAa,GAAG;YACrB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;gBACzC,SAAS,CAAC,EAAE,CAAC,MAAM;YACrB;QACF;QAEA,oBAAoB;QACpB,IAAI,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC;YACvB,eAAe;QACjB;IACF;IAEA,SAAU,IAAI,EAAE,OAAO,EAAE;QACvB,IAAI,CAAC,WAAW,OAAO,YAAY,UAAU;YAC3C,MAAM,IAAI,qBAAqB;QACjC;QAEA,UAAU,cAAc,MAAM,CAAC;QAE/B,IAAI;YACF,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;gBACrC,MAAM,IAAI,qBAAqB;YACjC;YAEA,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,aAAa,EAAE;gBAC1C,MAAM,IAAI;YACZ;YAEA,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,MAAM,IAAI;YACZ;YAEA,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;QAC/B,EAAE,OAAO,KAAK;YACZ,IAAI,OAAO,QAAQ,OAAO,KAAK,YAAY;gBACzC,MAAM;YACR;YAEA,QAAQ,OAAO,CAAC;YAEhB,OAAO;QACT;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/client-h1.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('node:assert')\nconst util = require('../core/util.js')\nconst { channels } = require('../core/diagnostics.js')\nconst timers = require('../util/timers.js')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext,\n  kClosed\n} = require('../core/symbols.js')\n\nconst constants = require('../llhttp/constants.js')\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nfunction lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('../llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n\n  // We disable wasm SIMD on ppc64 as it seems to be broken on Power 9 architectures.\n  let useWasmSIMD = process.arch !== 'ppc64'\n  // The Env Variable UNDICI_NO_WASM_SIMD allows explicitly overriding the default behavior\n  if (process.env.UNDICI_NO_WASM_SIMD === '1') {\n    useWasmSIMD = true\n  } else if (process.env.UNDICI_NO_WASM_SIMD === '0') {\n    useWasmSIMD = false\n  }\n\n  if (useWasmSIMD) {\n    try {\n      mod = new WebAssembly.Module(require('../llhttp/llhttp_simd-wasm.js'))\n      /* istanbul ignore next */\n    } catch {\n    }\n  }\n\n  /* istanbul ignore next */\n  if (!mod) {\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = new WebAssembly.Module(llhttpWasmData || require('../llhttp/llhttp-wasm.js'))\n  }\n\n  return new WebAssembly.Instance(mod, {\n    env: {\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_status: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_begin: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageBegin()\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_field: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_value: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} statusCode\n       * @param {0|1} upgrade\n       * @param {0|1} shouldKeepAlive\n       * @returns {number}\n       */\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1)\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_body: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_complete: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageComplete()\n      }\n\n    }\n  })\n}\n\nlet llhttpInstance = null\n\n/**\n * @type {Parser|null}\n */\nlet currentParser = null\nlet currentBufferRef = null\n/**\n * @type {number}\n */\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst USE_NATIVE_TIMER = 0\nconst USE_FAST_TIMER = 1\n\n// Use fast timers for headers and body to take eventual event loop\n// latency into account.\nconst TIMEOUT_HEADERS = 2 | USE_FAST_TIMER\nconst TIMEOUT_BODY = 4 | USE_FAST_TIMER\n\n// Use native timers to ignore event loop latency for keep-alive\n// handling.\nconst TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER\n\nclass Parser {\n  /**\n     * @param {import('./client.js')} client\n     * @param {import('net').Socket} socket\n     * @param {*} llhttp\n     */\n  constructor (client, socket, { exports }) {\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    /**\n     * @type {import('net').Socket}\n     */\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = 0\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (delay, type) {\n    // If the existing timer and the new timer are of different timer type\n    // (fast or native) or have different delay, we need to clear the existing\n    // timer and set a new one.\n    if (\n      delay !== this.timeoutValue ||\n      (type & USE_FAST_TIMER) ^ (this.timeoutType & USE_FAST_TIMER)\n    ) {\n      // If a timeout is already set, clear it with clearTimeout of the fast\n      // timer implementation, as it can clear fast and native timers.\n      if (this.timeout) {\n        timers.clearTimeout(this.timeout)\n        this.timeout = null\n      }\n\n      if (delay) {\n        if (type & USE_FAST_TIMER) {\n          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this))\n        } else {\n          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this))\n          this.timeout?.unref()\n        }\n      }\n\n      this.timeoutValue = delay\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.timeoutType = type\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser === null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   */\n  execute (chunk) {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    // Allocate a new buffer if the current buffer is too small.\n    if (chunk.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      // Allocate a buffer that is a multiple of 4096 bytes.\n      currentBufferSize = Math.ceil(chunk.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = chunk\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length)\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      if (ret !== constants.ERROR.OK) {\n        const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr)\n\n        if (ret === constants.ERROR.PAUSED_UPGRADE) {\n          this.onUpgrade(data)\n        } else if (ret === constants.ERROR.PAUSED) {\n          this.paused = true\n          socket.unshift(data)\n        } else {\n          const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n          let message = ''\n          /* istanbul ignore else: difficult to make a test case for */\n          if (ptr) {\n            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n            message =\n              'Response does not match the HTTP/1.1 protocol (' +\n              Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n              ')'\n          }\n          throw new HTTPParserError(message, constants.ERROR[ret], data)\n        }\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    this.timeout && timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {0}\n   */\n  onStatus (buf) {\n    this.statusText = buf.toString()\n    return 0\n  }\n\n  /**\n   * @returns {0|-1}\n   */\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {number} len\n   */\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  /**\n   * @param {Buffer} head\n   */\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n    assert(client[kSocket] === socket)\n    assert(!socket.destroyed)\n    assert(!this.paused)\n    assert((headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.shouldKeepAlive = false\n\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {number} statusCode\n   * @param {boolean} upgrade\n   * @param {boolean} shouldKeepAlive\n   * @returns {number}\n   */\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert(this.timeoutType === TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert((this.headers.length & 1) === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n\n    return 0\n  }\n\n  /**\n   * @returns {number}\n   */\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return 0\n    }\n\n    assert(statusCode >= 100)\n    assert((this.headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return 0\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert(client[kRunning] === 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(client[kResume])\n    } else {\n      client[kResume]()\n    }\n\n    return 0\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client, paused } = parser.deref()\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\n/**\n * @param {import ('./client.js')} client\n * @param {import('net').Socket} socket\n * @returns\n */\nfunction connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = lazyllhttp()\n  }\n\n  if (socket.errored) {\n    throw socket.errored\n  }\n\n  if (socket.destroyed) {\n    throw new SocketError('destroyed')\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  util.addListener(socket, 'error', onHttpSocketError)\n  util.addListener(socket, 'readable', onHttpSocketReadable)\n  util.addListener(socket, 'end', onHttpSocketEnd)\n  util.addListener(socket, 'close', onHttpSocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (request) {\n      return writeH1(client, request)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    /**\n     * @param {Error|undefined} err\n     * @param {() => void} callback\n     */\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.on('close', callback)\n        socket.destroy(err)\n      }\n    },\n    /**\n     * @returns {boolean}\n     */\n    get destroyed () {\n      return socket.destroyed\n    },\n    /**\n     * @param {import('../core/request.js')} request\n     * @returns {boolean}\n     */\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction onHttpSocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  const parser = this[kParser]\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttpSocketReadable () {\n  this[kParser]?.readMore()\n}\n\nfunction onHttpSocketEnd () {\n  const parser = this[kParser]\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onHttpSocketClose () {\n  const parser = this[kParser]\n\n  if (parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    util.errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n/**\n * @param {import('./client.js')} client\n */\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\n/**\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @returns\n */\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH' ||\n    method === 'QUERY' ||\n    method === 'PROPFIND' ||\n    method === 'PROPPATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = require('../web/fetch/body.js').extractBody\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {import('stream').Stream} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n */\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  /**\n   * @param {Buffer} chunk\n   * @returns {void}\n   */\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns\n   */\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(onFinished, body.errored)\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(onFinished, null)\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\n/**\n * @typedef AbortCallback\n * @type {Function}\n * @param {Error} [err]\n * @returns {void}\n */\n\n/**\n * @param {AbortCallback} abort\n * @param {Uint8Array|null} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {void}\n */\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Blob} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload && request.reset !== false) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Iterable} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  /**\n   *\n   * @param {object} arg\n   * @param {AbortCallback} arg.abort\n   * @param {import('net').Socket} arg.socket\n   * @param {import('../core/request.js')} arg.request\n   * @param {number} arg.contentLength\n   * @param {import('./client.js')} arg.client\n   * @param {boolean} arg.expectsPayload\n   * @param {string} arg.header\n   */\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @returns\n   */\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  /**\n   * @returns {void}\n   */\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n"],"names":[],"mappings":"AAEA,sBAAsB,GAEtB,MAAM;AACN,MAAM;AACN,MAAM,EAAE,QAAQ,EAAE;AAClB,MAAM;AACN,MAAM,EACJ,iCAAiC,EACjC,kCAAkC,EAClC,mBAAmB,EACnB,mBAAmB,EACnB,oBAAoB,EACpB,WAAW,EACX,kBAAkB,EAClB,gBAAgB,EAChB,eAAe,EACf,4BAA4B,EAC7B;AACD,MAAM,EACJ,IAAI,EACJ,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,KAAK,EACL,QAAQ,EACR,MAAM,EACN,MAAM,EACN,wBAAwB,EACxB,WAAW,EACX,WAAW,EACX,WAAW,EACX,MAAM,EACN,WAAW,EACX,OAAO,EACP,sBAAsB,EACtB,eAAe,EACf,oBAAoB,EACpB,0BAA0B,EAC1B,eAAe,EACf,YAAY,EACZ,oBAAoB,EACpB,YAAY,EACZ,QAAQ,EACR,gBAAgB,EAChB,QAAQ,EACR,OAAO,EACP,YAAY,EACZ,OAAO,EACR;AAED,MAAM;AACN,MAAM,YAAY,OAAO,KAAK,CAAC;AAC/B,MAAM,aAAa,MAAM,CAAC,OAAO,OAAO,CAAC;AACzC,MAAM,qBAAqB,KAAK,kBAAkB;AAElD,IAAI;AAEJ,SAAS;IACP,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,qLAAyC;IAE1F,IAAI;IAEJ,mFAAmF;IACnF,IAAI,cAAc,QAAQ,IAAI,KAAK;IACnC,yFAAyF;IACzF,IAAI,QAAQ,GAAG,CAAC,mBAAmB,KAAK,KAAK;QAC3C,cAAc;IAChB,OAAO,IAAI,QAAQ,GAAG,CAAC,mBAAmB,KAAK,KAAK;QAClD,cAAc;IAChB;IAEA,IAAI,aAAa;QACf,IAAI;YACF,MAAM,IAAI,YAAY,MAAM;QAC5B,wBAAwB,GAC1B,EAAE,OAAM,CACR;IACF;IAEA,wBAAwB,GACxB,IAAI,CAAC,KAAK;QACR,gEAAgE;QAChE,uDAAuD;QACvD,+DAA+D;QAC/D,yDAAyD;QACzD,MAAM,IAAI,YAAY,MAAM,CAAC;IAC/B;IAEA,OAAO,IAAI,YAAY,QAAQ,CAAC,KAAK;QACnC,KAAK;YACH;;;;;OAKC,GACD,aAAa,CAAC,GAAG,IAAI;gBACnB,wBAAwB,GACxB,OAAO;YACT;YACA;;;;;OAKC,GACD,gBAAgB,CAAC,GAAG,IAAI;gBACtB,OAAO,cAAc,GAAG,KAAK;gBAC7B,MAAM,QAAQ,KAAK,mBAAmB,iBAAiB,UAAU;gBACjE,OAAO,cAAc,QAAQ,CAAC,IAAI,WAAW,iBAAiB,MAAM,EAAE,OAAO;YAC/E;YACA;;;OAGC,GACD,uBAAuB,CAAC;gBACtB,OAAO,cAAc,GAAG,KAAK;gBAC7B,OAAO,cAAc,cAAc;YACrC;YACA;;;;;OAKC,GACD,sBAAsB,CAAC,GAAG,IAAI;gBAC5B,OAAO,cAAc,GAAG,KAAK;gBAC7B,MAAM,QAAQ,KAAK,mBAAmB,iBAAiB,UAAU;gBACjE,OAAO,cAAc,aAAa,CAAC,IAAI,WAAW,iBAAiB,MAAM,EAAE,OAAO;YACpF;YACA;;;;;OAKC,GACD,sBAAsB,CAAC,GAAG,IAAI;gBAC5B,OAAO,cAAc,GAAG,KAAK;gBAC7B,MAAM,QAAQ,KAAK,mBAAmB,iBAAiB,UAAU;gBACjE,OAAO,cAAc,aAAa,CAAC,IAAI,WAAW,iBAAiB,MAAM,EAAE,OAAO;YACpF;YACA;;;;;;OAMC,GACD,0BAA0B,CAAC,GAAG,YAAY,SAAS;gBACjD,OAAO,cAAc,GAAG,KAAK;gBAC7B,OAAO,cAAc,iBAAiB,CAAC,YAAY,YAAY,GAAG,oBAAoB;YACxF;YACA;;;;;OAKC,GACD,cAAc,CAAC,GAAG,IAAI;gBACpB,OAAO,cAAc,GAAG,KAAK;gBAC7B,MAAM,QAAQ,KAAK,mBAAmB,iBAAiB,UAAU;gBACjE,OAAO,cAAc,MAAM,CAAC,IAAI,WAAW,iBAAiB,MAAM,EAAE,OAAO;YAC7E;YACA;;;OAGC,GACD,0BAA0B,CAAC;gBACzB,OAAO,cAAc,GAAG,KAAK;gBAC7B,OAAO,cAAc,iBAAiB;YACxC;QAEF;IACF;AACF;AAEA,IAAI,iBAAiB;AAErB;;CAEC,GACD,IAAI,gBAAgB;AACpB,IAAI,mBAAmB;AACvB;;CAEC,GACD,IAAI,oBAAoB;AACxB,IAAI,mBAAmB;AAEvB,MAAM,mBAAmB;AACzB,MAAM,iBAAiB;AAEvB,mEAAmE;AACnE,wBAAwB;AACxB,MAAM,kBAAkB,IAAI;AAC5B,MAAM,eAAe,IAAI;AAEzB,gEAAgE;AAChE,YAAY;AACZ,MAAM,qBAAqB,IAAI;AAE/B,MAAM;IACJ;;;;KAIG,GACH,YAAa,MAAM,EAAE,MAAM,EAAE,EAAE,OAAO,EAAE,CAAE;QACxC,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,IAAI,CAAC,QAAQ;QAC3D,IAAI,CAAC,MAAM,GAAG;QACd;;KAEC,GACD,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG,EAAE;QACjB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,gBAAgB;QAC7C,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI;QAEnC,IAAI,CAAC,SAAS,GAAG;QAEjB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,iBAAiB;IACjD;IAEA,WAAY,KAAK,EAAE,IAAI,EAAE;QACvB,sEAAsE;QACtE,0EAA0E;QAC1E,2BAA2B;QAC3B,IACE,UAAU,IAAI,CAAC,YAAY,IAC3B,AAAC,OAAO,iBAAmB,IAAI,CAAC,WAAW,GAAG,gBAC9C;YACA,sEAAsE;YACtE,gEAAgE;YAChE,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,OAAO,YAAY,CAAC,IAAI,CAAC,OAAO;gBAChC,IAAI,CAAC,OAAO,GAAG;YACjB;YAEA,IAAI,OAAO;gBACT,IAAI,OAAO,gBAAgB;oBACzB,IAAI,CAAC,OAAO,GAAG,OAAO,cAAc,CAAC,iBAAiB,OAAO,IAAI,QAAQ,IAAI;gBAC/E,OAAO;oBACL,IAAI,CAAC,OAAO,GAAG,WAAW,iBAAiB,OAAO,IAAI,QAAQ,IAAI;oBAClE,IAAI,CAAC,OAAO,EAAE;gBAChB;YACF;YAEA,IAAI,CAAC,YAAY,GAAG;QACtB,OAAO,IAAI,IAAI,CAAC,OAAO,EAAE;YACvB,sCAAsC;YACtC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;gBACxB,IAAI,CAAC,OAAO,CAAC,OAAO;YACtB;QACF;QAEA,IAAI,CAAC,WAAW,GAAG;IACrB;IAEA,SAAU;QACR,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACzC;QACF;QAEA,OAAO,IAAI,CAAC,GAAG,IAAI;QACnB,OAAO,kBAAkB;QAEzB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG;QAElC,OAAO,IAAI,CAAC,WAAW,KAAK;QAC5B,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,sCAAsC;YACtC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;gBACxB,IAAI,CAAC,OAAO,CAAC,OAAO;YACtB;QACF;QAEA,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,MAAM,YAAW,gBAAgB;QAC9D,IAAI,CAAC,QAAQ;IACf;IAEA,WAAY;QACV,MAAO,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,CAAE;YAC/B,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI;YAC9B,IAAI,UAAU,MAAM;gBAClB;YACF;YACA,IAAI,CAAC,OAAO,CAAC;QACf;IACF;IAEA;;GAEC,GACD,QAAS,KAAK,EAAE;QACd,OAAO,kBAAkB;QACzB,OAAO,IAAI,CAAC,GAAG,IAAI;QACnB,OAAO,CAAC,IAAI,CAAC,MAAM;QAEnB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI;QAE/B,4DAA4D;QAC5D,IAAI,MAAM,MAAM,GAAG,mBAAmB;YACpC,IAAI,kBAAkB;gBACpB,OAAO,IAAI,CAAC;YACd;YACA,sDAAsD;YACtD,oBAAoB,KAAK,IAAI,CAAC,MAAM,MAAM,GAAG,QAAQ;YACrD,mBAAmB,OAAO,MAAM,CAAC;QACnC;QAEA,IAAI,WAAW,OAAO,MAAM,CAAC,MAAM,EAAE,kBAAkB,mBAAmB,GAAG,CAAC;QAE9E,qCAAqC;QACrC,wFAAwF;QACxF,4CAA4C;QAC5C,6DAA6D;QAC7D,IAAI;YACF,IAAI;YAEJ,IAAI;gBACF,mBAAmB;gBACnB,gBAAgB,IAAI;gBACpB,MAAM,OAAO,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,kBAAkB,MAAM,MAAM;YACtE,SAAU;gBACR,gBAAgB;gBAChB,mBAAmB;YACrB;YAEA,IAAI,QAAQ,UAAU,KAAK,CAAC,EAAE,EAAE;gBAC9B,MAAM,OAAO,MAAM,QAAQ,CAAC,OAAO,oBAAoB,CAAC,IAAI,CAAC,GAAG,IAAI;gBAEpE,IAAI,QAAQ,UAAU,KAAK,CAAC,cAAc,EAAE;oBAC1C,IAAI,CAAC,SAAS,CAAC;gBACjB,OAAO,IAAI,QAAQ,UAAU,KAAK,CAAC,MAAM,EAAE;oBACzC,IAAI,CAAC,MAAM,GAAG;oBACd,OAAO,OAAO,CAAC;gBACjB,OAAO;oBACL,MAAM,MAAM,OAAO,uBAAuB,CAAC,IAAI,CAAC,GAAG;oBACnD,IAAI,UAAU;oBACd,2DAA2D,GAC3D,IAAI,KAAK;wBACP,MAAM,MAAM,IAAI,WAAW,OAAO,MAAM,CAAC,MAAM,EAAE,KAAK,OAAO,CAAC;wBAC9D,UACE,oDACA,OAAO,IAAI,CAAC,OAAO,MAAM,CAAC,MAAM,EAAE,KAAK,KAAK,QAAQ,KACpD;oBACJ;oBACA,MAAM,IAAI,gBAAgB,SAAS,UAAU,KAAK,CAAC,IAAI,EAAE;gBAC3D;YACF;QACF,EAAE,OAAO,KAAK;YACZ,KAAK,OAAO,CAAC,QAAQ;QACvB;IACF;IAEA,UAAW;QACT,OAAO,kBAAkB;QACzB,OAAO,IAAI,CAAC,GAAG,IAAI;QAEnB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG;QAChC,IAAI,CAAC,GAAG,GAAG;QAEX,IAAI,CAAC,OAAO,IAAI,OAAO,YAAY,CAAC,IAAI,CAAC,OAAO;QAChD,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;QAEnB,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA;;;GAGC,GACD,SAAU,GAAG,EAAE;QACb,IAAI,CAAC,UAAU,GAAG,IAAI,QAAQ;QAC9B,OAAO;IACT;IAEA;;GAEC,GACD,iBAAkB;QAChB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI;QAE/B,2DAA2D,GAC3D,IAAI,OAAO,SAAS,EAAE;YACpB,OAAO,CAAC;QACV;QAEA,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QACnD,IAAI,CAAC,SAAS;YACZ,OAAO,CAAC;QACV;QACA,QAAQ,iBAAiB;QAEzB,OAAO;IACT;IAEA;;;GAGC,GACD,cAAe,GAAG,EAAE;QAClB,MAAM,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM;QAE/B,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;YACnB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;QACpB,OAAO;YACL,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,OAAO,MAAM,CAAC;gBAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBAAE;aAAI;QACpE;QAEA,IAAI,CAAC,WAAW,CAAC,IAAI,MAAM;QAE3B,OAAO;IACT;IAEA;;;GAGC,GACD,cAAe,GAAG,EAAE;QAClB,IAAI,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM;QAE7B,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;YACnB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;YAClB,OAAO;QACT,OAAO;YACL,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,OAAO,MAAM,CAAC;gBAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBAAE;aAAI;QACpE;QAEA,MAAM,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QACjC,IAAI,IAAI,MAAM,KAAK,IAAI;YACrB,MAAM,aAAa,KAAK,4BAA4B,CAAC;YACrD,IAAI,eAAe,cAAc;gBAC/B,IAAI,CAAC,SAAS,IAAI,IAAI,QAAQ;YAChC,OAAO,IAAI,eAAe,cAAc;gBACtC,IAAI,CAAC,UAAU,IAAI,IAAI,QAAQ;YACjC;QACF,OAAO,IAAI,IAAI,MAAM,KAAK,MAAM,KAAK,4BAA4B,CAAC,SAAS,kBAAkB;YAC3F,IAAI,CAAC,aAAa,IAAI,IAAI,QAAQ;QACpC;QAEA,IAAI,CAAC,WAAW,CAAC,IAAI,MAAM;QAE3B,OAAO;IACT;IAEA;;GAEC,GACD,YAAa,GAAG,EAAE;QAChB,IAAI,CAAC,WAAW,IAAI;QACpB,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE;YAC3C,KAAK,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI;QAChC;IACF;IAEA;;GAEC,GACD,UAAW,IAAI,EAAE;QACf,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,IAAI;QAE7D,OAAO;QACP,OAAO,MAAM,CAAC,QAAQ,KAAK;QAC3B,OAAO,CAAC,OAAO,SAAS;QACxB,OAAO,CAAC,IAAI,CAAC,MAAM;QACnB,OAAO,CAAC,QAAQ,MAAM,GAAG,CAAC,MAAM;QAEhC,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QACnD,OAAO;QACP,OAAO,QAAQ,OAAO,IAAI,QAAQ,MAAM,KAAK;QAE7C,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,eAAe,GAAG;QAEvB,IAAI,CAAC,OAAO,GAAG,EAAE;QACjB,IAAI,CAAC,WAAW,GAAG;QAEnB,OAAO,OAAO,CAAC;QAEf,MAAM,CAAC,QAAQ,CAAC,OAAO;QACvB,MAAM,CAAC,QAAQ,GAAG;QAElB,MAAM,CAAC,QAAQ,GAAG;QAClB,MAAM,CAAC,OAAO,GAAG;QAEjB,mBAAmB;QAEnB,MAAM,CAAC,QAAQ,GAAG;QAClB,MAAM,CAAC,aAAa,GAAG,MAAK,+BAA+B;QAC3D,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG;QACxC,OAAO,IAAI,CAAC,cAAc,MAAM,CAAC,KAAK,EAAE;YAAC;SAAO,EAAE,IAAI,mBAAmB;QAEzE,IAAI;YACF,QAAQ,SAAS,CAAC,YAAY,SAAS;QACzC,EAAE,OAAO,KAAK;YACZ,KAAK,OAAO,CAAC,QAAQ;QACvB;QAEA,MAAM,CAAC,QAAQ;IACjB;IAEA;;;;;GAKC,GACD,kBAAmB,UAAU,EAAE,OAAO,EAAE,eAAe,EAAE;QACvD,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,IAAI;QAEpD,2DAA2D,GAC3D,IAAI,OAAO,SAAS,EAAE;YACpB,OAAO,CAAC;QACV;QAEA,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QAEnD,2DAA2D,GAC3D,IAAI,CAAC,SAAS;YACZ,OAAO,CAAC;QACV;QAEA,OAAO,CAAC,IAAI,CAAC,OAAO;QACpB,OAAO,IAAI,CAAC,UAAU,GAAG;QAEzB,IAAI,eAAe,KAAK;YACtB,KAAK,OAAO,CAAC,QAAQ,IAAI,YAAY,gBAAgB,KAAK,aAAa,CAAC;YACxE,OAAO,CAAC;QACV;QAEA,iDAAiD,GACjD,IAAI,WAAW,CAAC,QAAQ,OAAO,EAAE;YAC/B,KAAK,OAAO,CAAC,QAAQ,IAAI,YAAY,eAAe,KAAK,aAAa,CAAC;YACvE,OAAO,CAAC;QACV;QAEA,OAAO,IAAI,CAAC,WAAW,KAAK;QAE5B,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,eAAe,GAClB,mBAEC,QAAQ,MAAM,KAAK,UAAU,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,CAAC,WAAW,OAAO;QAGrF,IAAI,IAAI,CAAC,UAAU,IAAI,KAAK;YAC1B,MAAM,cAAc,QAAQ,WAAW,IAAI,OACvC,QAAQ,WAAW,GACnB,MAAM,CAAC,aAAa;YACxB,IAAI,CAAC,UAAU,CAAC,aAAa;QAC/B,OAAO,IAAI,IAAI,CAAC,OAAO,EAAE;YACvB,sCAAsC;YACtC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;gBACxB,IAAI,CAAC,OAAO,CAAC,OAAO;YACtB;QACF;QAEA,IAAI,QAAQ,MAAM,KAAK,WAAW;YAChC,OAAO,MAAM,CAAC,SAAS,KAAK;YAC5B,IAAI,CAAC,OAAO,GAAG;YACf,OAAO;QACT;QAEA,IAAI,SAAS;YACX,OAAO,MAAM,CAAC,SAAS,KAAK;YAC5B,IAAI,CAAC,OAAO,GAAG;YACf,OAAO;QACT;QAEA,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,MAAM;QACrC,IAAI,CAAC,OAAO,GAAG,EAAE;QACjB,IAAI,CAAC,WAAW,GAAG;QAEnB,IAAI,IAAI,CAAC,eAAe,IAAI,MAAM,CAAC,YAAY,EAAE;YAC/C,MAAM,mBAAmB,IAAI,CAAC,SAAS,GAAG,KAAK,qBAAqB,CAAC,IAAI,CAAC,SAAS,IAAI;YAEvF,IAAI,oBAAoB,MAAM;gBAC5B,MAAM,UAAU,KAAK,GAAG,CACtB,mBAAmB,MAAM,CAAC,2BAA2B,EACrD,MAAM,CAAC,qBAAqB;gBAE9B,IAAI,WAAW,GAAG;oBAChB,MAAM,CAAC,OAAO,GAAG;gBACnB,OAAO;oBACL,MAAM,CAAC,uBAAuB,GAAG;gBACnC;YACF,OAAO;gBACL,MAAM,CAAC,uBAAuB,GAAG,MAAM,CAAC,yBAAyB;YACnE;QACF,OAAO;YACL,4CAA4C;YAC5C,MAAM,CAAC,OAAO,GAAG;QACnB;QAEA,MAAM,QAAQ,QAAQ,SAAS,CAAC,YAAY,SAAS,IAAI,CAAC,MAAM,EAAE,gBAAgB;QAElF,IAAI,QAAQ,OAAO,EAAE;YACnB,OAAO,CAAC;QACV;QAEA,IAAI,QAAQ,MAAM,KAAK,QAAQ;YAC7B,OAAO;QACT;QAEA,IAAI,aAAa,KAAK;YACpB,OAAO;QACT;QAEA,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,MAAM,CAAC,UAAU,GAAG;YACpB,MAAM,CAAC,QAAQ;QACjB;QAEA,OAAO,QAAQ,UAAU,KAAK,CAAC,MAAM,GAAG;IAC1C;IAEA;;;GAGC,GACD,OAAQ,GAAG,EAAE;QACX,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,eAAe,EAAE,GAAG,IAAI;QAE5D,IAAI,OAAO,SAAS,EAAE;YACpB,OAAO,CAAC;QACV;QAEA,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QACnD,OAAO;QAEP,OAAO,IAAI,CAAC,WAAW,KAAK;QAC5B,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,sCAAsC;YACtC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;gBACxB,IAAI,CAAC,OAAO,CAAC,OAAO;YACtB;QACF;QAEA,OAAO,cAAc;QAErB,IAAI,kBAAkB,CAAC,KAAK,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,GAAG,iBAAiB;YACzE,KAAK,OAAO,CAAC,QAAQ,IAAI;YACzB,OAAO,CAAC;QACV;QAEA,IAAI,CAAC,SAAS,IAAI,IAAI,MAAM;QAE5B,IAAI,QAAQ,MAAM,CAAC,SAAS,OAAO;YACjC,OAAO,UAAU,KAAK,CAAC,MAAM;QAC/B;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,oBAAqB;QACnB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE,aAAa,EAAE,SAAS,EAAE,eAAe,EAAE,GAAG,IAAI;QAExG,IAAI,OAAO,SAAS,IAAI,CAAC,CAAC,cAAc,eAAe,GAAG;YACxD,OAAO,CAAC;QACV;QAEA,IAAI,SAAS;YACX,OAAO;QACT;QAEA,OAAO,cAAc;QACrB,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,MAAM;QAErC,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QACnD,OAAO;QAEP,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,UAAU,GAAG;QAElB,IAAI,CAAC,OAAO,GAAG,EAAE;QACjB,IAAI,CAAC,WAAW,GAAG;QAEnB,IAAI,aAAa,KAAK;YACpB,OAAO;QACT;QAEA,sDAAsD,GACtD,IAAI,QAAQ,MAAM,KAAK,UAAU,iBAAiB,cAAc,SAAS,eAAe,KAAK;YAC3F,KAAK,OAAO,CAAC,QAAQ,IAAI;YACzB,OAAO,CAAC;QACV;QAEA,QAAQ,UAAU,CAAC;QAEnB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG;QAExC,IAAI,MAAM,CAAC,SAAS,EAAE;YACpB,OAAO,MAAM,CAAC,SAAS,KAAK;YAC5B,qCAAqC;YACrC,KAAK,OAAO,CAAC,QAAQ,IAAI,mBAAmB;YAC5C,OAAO,UAAU,KAAK,CAAC,MAAM;QAC/B,OAAO,IAAI,CAAC,iBAAiB;YAC3B,KAAK,OAAO,CAAC,QAAQ,IAAI,mBAAmB;YAC5C,OAAO,UAAU,KAAK,CAAC,MAAM;QAC/B,OAAO,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,SAAS,KAAK,GAAG;YACnD,mDAAmD;YACnD,qDAAqD;YACrD,sDAAsD;YACtD,+BAA+B;YAC/B,KAAK,OAAO,CAAC,QAAQ,IAAI,mBAAmB;YAC5C,OAAO,UAAU,KAAK,CAAC,MAAM;QAC/B,OAAO,IAAI,MAAM,CAAC,YAAY,IAAI,QAAQ,MAAM,CAAC,YAAY,KAAK,GAAG;YACnE,yEAAyE;YACzE,8EAA8E;YAC9E,mBAAmB;YACnB,aAAa,MAAM,CAAC,QAAQ;QAC9B,OAAO;YACL,MAAM,CAAC,QAAQ;QACjB;QAEA,OAAO;IACT;AACF;AAEA,SAAS,gBAAiB,MAAM;IAC9B,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,KAAK;IAE5D,wBAAwB,GACxB,IAAI,gBAAgB,iBAAiB;QACnC,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,OAAO,iBAAiB,IAAI,MAAM,CAAC,SAAS,GAAG,GAAG;YACzE,OAAO,CAAC,QAAQ;YAChB,KAAK,OAAO,CAAC,QAAQ,IAAI;QAC3B;IACF,OAAO,IAAI,gBAAgB,cAAc;QACvC,IAAI,CAAC,QAAQ;YACX,KAAK,OAAO,CAAC,QAAQ,IAAI;QAC3B;IACF,OAAO,IAAI,gBAAgB,oBAAoB;QAC7C,OAAO,MAAM,CAAC,SAAS,KAAK,KAAK,MAAM,CAAC,uBAAuB;QAC/D,KAAK,OAAO,CAAC,QAAQ,IAAI,mBAAmB;IAC9C;AACF;AAEA;;;;CAIC,GACD,SAAS,UAAW,MAAM,EAAE,MAAM;IAChC,MAAM,CAAC,QAAQ,GAAG;IAElB,IAAI,CAAC,gBAAgB;QACnB,iBAAiB;IACnB;IAEA,IAAI,OAAO,OAAO,EAAE;QAClB,MAAM,OAAO,OAAO;IACtB;IAEA,IAAI,OAAO,SAAS,EAAE;QACpB,MAAM,IAAI,YAAY;IACxB;IAEA,MAAM,CAAC,OAAO,GAAG;IACjB,MAAM,CAAC,SAAS,GAAG;IACnB,MAAM,CAAC,OAAO,GAAG;IACjB,MAAM,CAAC,UAAU,GAAG;IACpB,MAAM,CAAC,QAAQ,GAAG,IAAI,OAAO,QAAQ,QAAQ;IAE7C,KAAK,WAAW,CAAC,QAAQ,SAAS;IAClC,KAAK,WAAW,CAAC,QAAQ,YAAY;IACrC,KAAK,WAAW,CAAC,QAAQ,OAAO;IAChC,KAAK,WAAW,CAAC,QAAQ,SAAS;IAElC,MAAM,CAAC,QAAQ,GAAG;IAClB,OAAO,EAAE,CAAC,SAAS;IAEnB,OAAO;QACL,SAAS;QACT,mBAAmB;QACnB,OAAO,OAAO;YACZ,OAAO,QAAQ,QAAQ;QACzB;QACA;YACE,SAAS;QACX;QACA;;;KAGC,GACD,SAAS,GAAG,EAAE,QAAQ;YACpB,IAAI,MAAM,CAAC,QAAQ,EAAE;gBACnB,eAAe;YACjB,OAAO;gBACL,OAAO,EAAE,CAAC,SAAS;gBACnB,OAAO,OAAO,CAAC;YACjB;QACF;QACA;;KAEC,GACD,IAAI,aAAa;YACf,OAAO,OAAO,SAAS;QACzB;QACA;;;KAGC,GACD,MAAM,OAAO;YACX,IAAI,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,UAAU,EAAE;gBAC3D,OAAO;YACT;YAEA,IAAI,SAAS;gBACX,IAAI,MAAM,CAAC,SAAS,GAAG,KAAK,CAAC,QAAQ,UAAU,EAAE;oBAC/C,4CAA4C;oBAC5C,iDAAiD;oBACjD,uBAAuB;oBACvB,OAAO;gBACT;gBAEA,IAAI,MAAM,CAAC,SAAS,GAAG,KAAK,CAAC,QAAQ,OAAO,IAAI,QAAQ,MAAM,KAAK,SAAS,GAAG;oBAC7E,yEAAyE;oBACzE,yEAAyE;oBACzE,yBAAyB;oBACzB,OAAO;gBACT;gBAEA,IAAI,MAAM,CAAC,SAAS,GAAG,KAAK,KAAK,UAAU,CAAC,QAAQ,IAAI,MAAM,KAC5D,CAAC,KAAK,QAAQ,CAAC,QAAQ,IAAI,KAAK,KAAK,eAAe,CAAC,QAAQ,IAAI,KAAK,KAAK,cAAc,CAAC,QAAQ,IAAI,CAAC,GAAG;oBAC1G,sEAAsE;oBACtE,mDAAmD;oBACnD,qDAAqD;oBACrD,kCAAkC;oBAElC,0DAA0D;oBAC1D,iDAAiD;oBACjD,uBAAuB;oBACvB,OAAO;gBACT;YACF;YAEA,OAAO;QACT;IACF;AACF;AAEA,SAAS,kBAAmB,GAAG;IAC7B,OAAO,IAAI,IAAI,KAAK;IAEpB,MAAM,SAAS,IAAI,CAAC,QAAQ;IAE5B,+EAA+E;IAC/E,eAAe;IACf,IAAI,IAAI,IAAI,KAAK,gBAAgB,OAAO,UAAU,IAAI,CAAC,OAAO,eAAe,EAAE;QAC7E,yDAAyD;QACzD,OAAO,iBAAiB;QACxB;IACF;IAEA,IAAI,CAAC,OAAO,GAAG;IAEf,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;AAC1B;AAEA,SAAS;IACP,IAAI,CAAC,QAAQ,EAAE;AACjB;AAEA,SAAS;IACP,MAAM,SAAS,IAAI,CAAC,QAAQ;IAE5B,IAAI,OAAO,UAAU,IAAI,CAAC,OAAO,eAAe,EAAE;QAChD,yDAAyD;QACzD,OAAO,iBAAiB;QACxB;IACF;IAEA,KAAK,OAAO,CAAC,IAAI,EAAE,IAAI,YAAY,qBAAqB,KAAK,aAAa,CAAC,IAAI;AACjF;AAEA,SAAS;IACP,MAAM,SAAS,IAAI,CAAC,QAAQ;IAE5B,IAAI,QAAQ;QACV,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,UAAU,IAAI,CAAC,OAAO,eAAe,EAAE;YACjE,yDAAyD;YACzD,OAAO,iBAAiB;QAC1B;QAEA,IAAI,CAAC,QAAQ,CAAC,OAAO;QACrB,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,MAAM,MAAM,IAAI,CAAC,OAAO,IAAI,IAAI,YAAY,UAAU,KAAK,aAAa,CAAC,IAAI;IAE7E,MAAM,SAAS,IAAI,CAAC,QAAQ;IAE5B,MAAM,CAAC,QAAQ,GAAG;IAClB,MAAM,CAAC,aAAa,GAAG,MAAK,+BAA+B;IAE3D,IAAI,OAAO,SAAS,EAAE;QACpB,OAAO,MAAM,CAAC,SAAS,KAAK;QAE5B,qBAAqB;QACrB,MAAM,WAAW,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY;QAC1D,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;YACxC,MAAM,UAAU,QAAQ,CAAC,EAAE;YAC3B,KAAK,YAAY,CAAC,QAAQ,SAAS;QACrC;IACF,OAAO,IAAI,MAAM,CAAC,SAAS,GAAG,KAAK,IAAI,IAAI,KAAK,gBAAgB;QAC9D,yBAAyB;QACzB,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;QACnD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG;QAExC,KAAK,YAAY,CAAC,QAAQ,SAAS;IACrC;IAEA,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY;IAEzC,OAAO,MAAM,CAAC,SAAS,KAAK;IAE5B,OAAO,IAAI,CAAC,cAAc,MAAM,CAAC,KAAK,EAAE;QAAC;KAAO,EAAE;IAElD,MAAM,CAAC,QAAQ;AACjB;AAEA,SAAS;IACP,IAAI,CAAC,QAAQ,GAAG;AAClB;AAEA;;CAEC,GACD,SAAS,SAAU,MAAM;IACvB,MAAM,SAAS,MAAM,CAAC,QAAQ;IAE9B,IAAI,UAAU,CAAC,OAAO,SAAS,EAAE;QAC/B,IAAI,MAAM,CAAC,MAAM,KAAK,GAAG;YACvB,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,OAAO,KAAK,EAAE;gBACnC,OAAO,KAAK;gBACZ,MAAM,CAAC,OAAO,GAAG;YACnB;QACF,OAAO,IAAI,MAAM,CAAC,OAAO,IAAI,OAAO,GAAG,EAAE;YACvC,OAAO,GAAG;YACV,MAAM,CAAC,OAAO,GAAG;QACnB;QAEA,IAAI,MAAM,CAAC,MAAM,KAAK,GAAG;YACvB,IAAI,MAAM,CAAC,QAAQ,CAAC,WAAW,KAAK,oBAAoB;gBACtD,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,uBAAuB,EAAE;YAC7D;QACF,OAAO,IAAI,MAAM,CAAC,SAAS,GAAG,KAAK,MAAM,CAAC,QAAQ,CAAC,UAAU,GAAG,KAAK;YACnE,IAAI,MAAM,CAAC,QAAQ,CAAC,WAAW,KAAK,iBAAiB;gBACnD,MAAM,UAAU,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC;gBACnD,MAAM,iBAAiB,QAAQ,cAAc,IAAI,OAC7C,QAAQ,cAAc,GACtB,MAAM,CAAC,gBAAgB;gBAC3B,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,gBAAgB;YAC7C;QACF;IACF;AACF;AAEA,uDAAuD;AACvD,SAAS,wBAAyB,MAAM;IACtC,OAAO,WAAW,SAAS,WAAW,UAAU,WAAW,aAAa,WAAW,WAAW,WAAW;AAC3G;AAEA;;;;CAIC,GACD,SAAS,QAAS,MAAM,EAAE,OAAO;IAC/B,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG;IAEzD,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,aAAa,EAAE,GAAG;IAEvC,oDAAoD;IACpD,oDAAoD;IACpD,oDAAoD;IAEpD,oDAAoD;IACpD,iDAAiD;IACjD,+CAA+C;IAC/C,8CAA8C;IAE9C,MAAM,iBACJ,WAAW,SACX,WAAW,UACX,WAAW,WACX,WAAW,WACX,WAAW,cACX,WAAW;IAGb,IAAI,KAAK,cAAc,CAAC,OAAO;QAC7B,IAAI,CAAC,aAAa;YAChB,cAAc,4KAAgC,WAAW;QAC3D;QAEA,MAAM,CAAC,YAAY,YAAY,GAAG,YAAY;QAC9C,IAAI,QAAQ,WAAW,IAAI,MAAM;YAC/B,QAAQ,IAAI,CAAC,gBAAgB;QAC/B;QACA,OAAO,WAAW,MAAM;QACxB,gBAAgB,WAAW,MAAM;IACnC,OAAO,IAAI,KAAK,UAAU,CAAC,SAAS,QAAQ,WAAW,IAAI,QAAQ,KAAK,IAAI,EAAE;QAC5E,QAAQ,IAAI,CAAC,gBAAgB,KAAK,IAAI;IACxC;IAEA,IAAI,QAAQ,OAAO,KAAK,IAAI,KAAK,YAAY;QAC3C,0CAA0C;QAC1C,KAAK,IAAI,CAAC;IACZ;IAEA,MAAM,aAAa,KAAK,UAAU,CAAC;IAEnC,gBAAgB,cAAc;IAE9B,IAAI,kBAAkB,MAAM;QAC1B,gBAAgB,QAAQ,aAAa;IACvC;IAEA,IAAI,kBAAkB,KAAK,CAAC,gBAAgB;QAC1C,oDAAoD;QACpD,kEAAkE;QAClE,qEAAqE;QACrE,2CAA2C;QAE3C,gBAAgB;IAClB;IAEA,+CAA+C;IAC/C,sFAAsF;IACtF,IAAI,wBAAwB,WAAW,gBAAgB,KAAK,QAAQ,aAAa,KAAK,QAAQ,QAAQ,aAAa,KAAK,eAAe;QACrI,IAAI,MAAM,CAAC,qBAAqB,EAAE;YAChC,KAAK,YAAY,CAAC,QAAQ,SAAS,IAAI;YACvC,OAAO;QACT;QAEA,QAAQ,WAAW,CAAC,IAAI;IAC1B;IAEA,MAAM,SAAS,MAAM,CAAC,QAAQ;IAE9B;;;GAGC,GACD,MAAM,QAAQ,CAAC;QACb,IAAI,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;YACxC;QACF;QAEA,KAAK,YAAY,CAAC,QAAQ,SAAS,OAAO,IAAI;QAE9C,KAAK,OAAO,CAAC;QACb,KAAK,OAAO,CAAC,QAAQ,IAAI,mBAAmB;IAC9C;IAEA,IAAI;QACF,QAAQ,SAAS,CAAC;IACpB,EAAE,OAAO,KAAK;QACZ,KAAK,YAAY,CAAC,QAAQ,SAAS;IACrC;IAEA,IAAI,QAAQ,OAAO,EAAE;QACnB,OAAO;IACT;IAEA,IAAI,WAAW,QAAQ;QACrB,gDAAgD;QAChD,iEAAiE;QACjE,wCAAwC;QAExC,MAAM,CAAC,OAAO,GAAG;IACnB;IAEA,IAAI,WAAW,WAAW,WAAW;QACnC,iEAAiE;QACjE,+BAA+B;QAE/B,MAAM,CAAC,OAAO,GAAG;IACnB;IAEA,IAAI,SAAS,MAAM;QACjB,MAAM,CAAC,OAAO,GAAG;IACnB;IAEA,IAAI,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,SAAS,MAAM,MAAM,CAAC,aAAa,EAAE;QACtE,MAAM,CAAC,OAAO,GAAG;IACnB;IAEA,IAAI,UAAU;QACZ,MAAM,CAAC,UAAU,GAAG;IACtB;IAEA,IAAI,SAAS,GAAG,OAAO,CAAC,EAAE,KAAK,aAAa,CAAC;IAE7C,IAAI,OAAO,SAAS,UAAU;QAC5B,UAAU,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC;IAC/B,OAAO;QACL,UAAU,MAAM,CAAC,YAAY;IAC/B;IAEA,IAAI,SAAS;QACX,UAAU,CAAC,gCAAgC,EAAE,QAAQ,IAAI,CAAC;IAC5D,OAAO,IAAI,MAAM,CAAC,YAAY,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;QACjD,UAAU;IACZ,OAAO;QACL,UAAU;IACZ;IAEA,IAAI,MAAM,OAAO,CAAC,UAAU;QAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,KAAK,EAAG;YAC1C,MAAM,MAAM,OAAO,CAAC,IAAI,EAAE;YAC1B,MAAM,MAAM,OAAO,CAAC,IAAI,EAAE;YAE1B,IAAI,MAAM,OAAO,CAAC,MAAM;gBACtB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;oBACnC,UAAU,GAAG,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC;gBACnC;YACF,OAAO;gBACL,UAAU,GAAG,IAAI,EAAE,EAAE,IAAI,IAAI,CAAC;YAChC;QACF;IACF;IAEA,IAAI,SAAS,WAAW,CAAC,cAAc,EAAE;QACvC,SAAS,WAAW,CAAC,OAAO,CAAC;YAAE;YAAS,SAAS;YAAQ;QAAO;IAClE;IAEA,mCAAmC,GACnC,IAAI,CAAC,QAAQ,eAAe,GAAG;QAC7B,YAAY,OAAO,MAAM,QAAQ,SAAS,QAAQ,eAAe,QAAQ;IAC3E,OAAO,IAAI,KAAK,QAAQ,CAAC,OAAO;QAC9B,YAAY,OAAO,MAAM,QAAQ,SAAS,QAAQ,eAAe,QAAQ;IAC3E,OAAO,IAAI,KAAK,UAAU,CAAC,OAAO;QAChC,IAAI,OAAO,KAAK,MAAM,KAAK,YAAY;YACrC,cAAc,OAAO,KAAK,MAAM,IAAI,QAAQ,SAAS,QAAQ,eAAe,QAAQ;QACtF,OAAO;YACL,UAAU,OAAO,MAAM,QAAQ,SAAS,QAAQ,eAAe,QAAQ;QACzE;IACF,OAAO,IAAI,KAAK,QAAQ,CAAC,OAAO;QAC9B,YAAY,OAAO,MAAM,QAAQ,SAAS,QAAQ,eAAe,QAAQ;IAC3E,OAAO,IAAI,KAAK,UAAU,CAAC,OAAO;QAChC,cAAc,OAAO,MAAM,QAAQ,SAAS,QAAQ,eAAe,QAAQ;IAC7E,OAAO;QACL,OAAO;IACT;IAEA,OAAO;AACT;AAEA;;;;;;;;;CASC,GACD,SAAS,YAAa,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc;IAC/F,OAAO,kBAAkB,KAAK,MAAM,CAAC,SAAS,KAAK,GAAG;IAEtD,IAAI,WAAW;IAEf,MAAM,SAAS,IAAI,YAAY;QAAE;QAAO;QAAQ;QAAS;QAAe;QAAQ;QAAgB;IAAO;IAEvG;;;GAGC,GACD,MAAM,SAAS,SAAU,KAAK;QAC5B,IAAI,UAAU;YACZ;QACF;QAEA,IAAI;YACF,IAAI,CAAC,OAAO,KAAK,CAAC,UAAU,IAAI,CAAC,KAAK,EAAE;gBACtC,IAAI,CAAC,KAAK;YACZ;QACF,EAAE,OAAO,KAAK;YACZ,KAAK,OAAO,CAAC,IAAI,EAAE;QACrB;IACF;IAEA;;GAEC,GACD,MAAM,UAAU;QACd,IAAI,UAAU;YACZ;QACF;QAEA,IAAI,KAAK,MAAM,EAAE;YACf,KAAK,MAAM;QACb;IACF;IAEA;;GAEC,GACD,MAAM,UAAU;QACd,gDAAgD;QAChD,kDAAkD;QAClD,eAAe;YACb,kDAAkD;YAClD,WAAW;YACX,KAAK,cAAc,CAAC,SAAS;QAC/B;QAEA,IAAI,CAAC,UAAU;YACb,MAAM,MAAM,IAAI;YAChB,eAAe,IAAM,WAAW;QAClC;IACF;IAEA;;;GAGC,GACD,MAAM,aAAa,SAAU,GAAG;QAC9B,IAAI,UAAU;YACZ;QACF;QAEA,WAAW;QAEX,OAAO,OAAO,SAAS,IAAK,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,SAAS,IAAI;QAEpE,OACG,GAAG,CAAC,SAAS,SACb,GAAG,CAAC,SAAS;QAEhB,KACG,cAAc,CAAC,QAAQ,QACvB,cAAc,CAAC,OAAO,YACtB,cAAc,CAAC,SAAS;QAE3B,IAAI,CAAC,KAAK;YACR,IAAI;gBACF,OAAO,GAAG;YACZ,EAAE,OAAO,IAAI;gBACX,MAAM;YACR;QACF;QAEA,OAAO,OAAO,CAAC;QAEf,IAAI,OAAO,CAAC,IAAI,IAAI,KAAK,kBAAkB,IAAI,OAAO,KAAK,OAAO,GAAG;YACnE,KAAK,OAAO,CAAC,MAAM;QACrB,OAAO;YACL,KAAK,OAAO,CAAC;QACf;IACF;IAEA,KACG,EAAE,CAAC,QAAQ,QACX,EAAE,CAAC,OAAO,YACV,EAAE,CAAC,SAAS,YACZ,EAAE,CAAC,SAAS;IAEf,IAAI,KAAK,MAAM,EAAE;QACf,KAAK,MAAM;IACb;IAEA,OACG,EAAE,CAAC,SAAS,SACZ,EAAE,CAAC,SAAS;IAEf,IAAI,KAAK,YAAY,IAAI,KAAK,OAAO,EAAE;QACrC,aAAa,YAAY,KAAK,OAAO;IACvC,OAAO,IAAI,KAAK,UAAU,IAAI,KAAK,aAAa,EAAE;QAChD,aAAa,YAAY;IAC3B;IAEA,IAAI,KAAK,YAAY,IAAI,KAAK,MAAM,EAAE;QACpC,aAAa;IACf;AACF;AAEA;;;;;CAKC,GAED;;;;;;;;;;CAUC,GACD,SAAS,YAAa,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc;IAC/F,IAAI;QACF,IAAI,CAAC,MAAM;YACT,IAAI,kBAAkB,GAAG;gBACvB,OAAO,KAAK,CAAC,GAAG,OAAO,yBAAyB,CAAC,EAAE;YACrD,OAAO;gBACL,OAAO,kBAAkB,MAAM;gBAC/B,OAAO,KAAK,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE;YAChC;QACF,OAAO,IAAI,KAAK,QAAQ,CAAC,OAAO;YAC9B,OAAO,kBAAkB,KAAK,UAAU,EAAE;YAE1C,OAAO,IAAI;YACX,OAAO,KAAK,CAAC,GAAG,OAAO,gBAAgB,EAAE,cAAc,QAAQ,CAAC,EAAE;YAClE,OAAO,KAAK,CAAC;YACb,OAAO,MAAM;YACb,QAAQ,UAAU,CAAC;YAEnB,IAAI,CAAC,kBAAkB,QAAQ,KAAK,KAAK,OAAO;gBAC9C,MAAM,CAAC,OAAO,GAAG;YACnB;QACF;QACA,QAAQ,aAAa;QAErB,MAAM,CAAC,QAAQ;IACjB,EAAE,OAAO,KAAK;QACZ,MAAM;IACR;AACF;AAEA;;;;;;;;;;CAUC,GACD,eAAe,UAAW,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc;IACnG,OAAO,kBAAkB,KAAK,IAAI,EAAE;IAEpC,IAAI;QACF,IAAI,iBAAiB,QAAQ,kBAAkB,KAAK,IAAI,EAAE;YACxD,MAAM,IAAI;QACZ;QAEA,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,KAAK,WAAW;QAEjD,OAAO,IAAI;QACX,OAAO,KAAK,CAAC,GAAG,OAAO,gBAAgB,EAAE,cAAc,QAAQ,CAAC,EAAE;QAClE,OAAO,KAAK,CAAC;QACb,OAAO,MAAM;QAEb,QAAQ,UAAU,CAAC;QACnB,QAAQ,aAAa;QAErB,IAAI,CAAC,kBAAkB,QAAQ,KAAK,KAAK,OAAO;YAC9C,MAAM,CAAC,OAAO,GAAG;QACnB;QAEA,MAAM,CAAC,QAAQ;IACjB,EAAE,OAAO,KAAK;QACZ,MAAM;IACR;AACF;AAEA;;;;;;;;;;CAUC,GACD,eAAe,cAAe,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc;IACvG,OAAO,kBAAkB,KAAK,MAAM,CAAC,SAAS,KAAK,GAAG;IAEtD,IAAI,WAAW;IACf,SAAS;QACP,IAAI,UAAU;YACZ,MAAM,KAAK;YACX,WAAW;YACX;QACF;IACF;IAEA,MAAM,eAAe,IAAM,IAAI,QAAQ,CAAC,SAAS;YAC/C,OAAO,aAAa;YAEpB,IAAI,MAAM,CAAC,OAAO,EAAE;gBAClB,OAAO,MAAM,CAAC,OAAO;YACvB,OAAO;gBACL,WAAW;YACb;QACF;IAEA,OACG,EAAE,CAAC,SAAS,SACZ,EAAE,CAAC,SAAS;IAEf,MAAM,SAAS,IAAI,YAAY;QAAE;QAAO;QAAQ;QAAS;QAAe;QAAQ;QAAgB;IAAO;IACvG,IAAI;QACF,2DAA2D;QAC3D,WAAW,MAAM,SAAS,KAAM;YAC9B,IAAI,MAAM,CAAC,OAAO,EAAE;gBAClB,MAAM,MAAM,CAAC,OAAO;YACtB;YAEA,IAAI,CAAC,OAAO,KAAK,CAAC,QAAQ;gBACxB,MAAM;YACR;QACF;QAEA,OAAO,GAAG;IACZ,EAAE,OAAO,KAAK;QACZ,OAAO,OAAO,CAAC;IACjB,SAAU;QACR,OACG,GAAG,CAAC,SAAS,SACb,GAAG,CAAC,SAAS;IAClB;AACF;AAEA,MAAM;IACJ;;;;;;;;;;GAUC,GACD,YAAa,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,CAAE;QACtF,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,KAAK,GAAG;QAEb,MAAM,CAAC,SAAS,GAAG;IACrB;IAEA;;;GAGC,GACD,MAAO,KAAK,EAAE;QACZ,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,MAAM,EAAE,YAAY,EAAE,cAAc,EAAE,MAAM,EAAE,GAAG,IAAI;QAE7F,IAAI,MAAM,CAAC,OAAO,EAAE;YAClB,MAAM,MAAM,CAAC,OAAO;QACtB;QAEA,IAAI,OAAO,SAAS,EAAE;YACpB,OAAO;QACT;QAEA,MAAM,MAAM,OAAO,UAAU,CAAC;QAC9B,IAAI,CAAC,KAAK;YACR,OAAO;QACT;QAEA,kCAAkC;QAClC,IAAI,kBAAkB,QAAQ,eAAe,MAAM,eAAe;YAChE,IAAI,MAAM,CAAC,qBAAqB,EAAE;gBAChC,MAAM,IAAI;YACZ;YAEA,QAAQ,WAAW,CAAC,IAAI;QAC1B;QAEA,OAAO,IAAI;QAEX,IAAI,iBAAiB,GAAG;YACtB,IAAI,CAAC,kBAAkB,QAAQ,KAAK,KAAK,OAAO;gBAC9C,MAAM,CAAC,OAAO,GAAG;YACnB;YAEA,IAAI,kBAAkB,MAAM;gBAC1B,OAAO,KAAK,CAAC,GAAG,OAAO,8BAA8B,CAAC,EAAE;YAC1D,OAAO;gBACL,OAAO,KAAK,CAAC,GAAG,OAAO,gBAAgB,EAAE,cAAc,QAAQ,CAAC,EAAE;YACpE;QACF;QAEA,IAAI,kBAAkB,MAAM;YAC1B,OAAO,KAAK,CAAC,CAAC,IAAI,EAAE,IAAI,QAAQ,CAAC,IAAI,IAAI,CAAC,EAAE;QAC9C;QAEA,IAAI,CAAC,YAAY,IAAI;QAErB,MAAM,MAAM,OAAO,KAAK,CAAC;QAEzB,OAAO,MAAM;QAEb,QAAQ,UAAU,CAAC;QAEnB,IAAI,CAAC,KAAK;YACR,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,WAAW,KAAK,iBAAiB;gBAC9E,sCAAsC;gBACtC,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE;oBACnC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO;gBACjC;YACF;QACF;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAO;QACL,MAAM,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,YAAY,EAAE,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI;QAC7F,QAAQ,aAAa;QAErB,MAAM,CAAC,SAAS,GAAG;QAEnB,IAAI,MAAM,CAAC,OAAO,EAAE;YAClB,MAAM,MAAM,CAAC,OAAO;QACtB;QAEA,IAAI,OAAO,SAAS,EAAE;YACpB;QACF;QAEA,IAAI,iBAAiB,GAAG;YACtB,IAAI,gBAAgB;gBAClB,oDAAoD;gBACpD,sEAAsE;gBACtE,wEAAwE;gBACxE,gCAAgC;gBAEhC,OAAO,KAAK,CAAC,GAAG,OAAO,yBAAyB,CAAC,EAAE;YACrD,OAAO;gBACL,OAAO,KAAK,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE;YAChC;QACF,OAAO,IAAI,kBAAkB,MAAM;YACjC,OAAO,KAAK,CAAC,iBAAiB;QAChC;QAEA,IAAI,kBAAkB,QAAQ,iBAAiB,eAAe;YAC5D,IAAI,MAAM,CAAC,qBAAqB,EAAE;gBAChC,MAAM,IAAI;YACZ,OAAO;gBACL,QAAQ,WAAW,CAAC,IAAI;YAC1B;QACF;QAEA,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,WAAW,KAAK,iBAAiB;YAC9E,sCAAsC;YACtC,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE;gBACnC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO;YACjC;QACF;QAEA,MAAM,CAAC,QAAQ;IACjB;IAEA;;;GAGC,GACD,QAAS,GAAG,EAAE;QACZ,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI;QAEtC,MAAM,CAAC,SAAS,GAAG;QAEnB,IAAI,KAAK;YACP,OAAO,MAAM,CAAC,SAAS,IAAI,GAAG;YAC9B,MAAM;QACR;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1418, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/client-h2.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { pipeline } = require('node:stream')\nconst util = require('../core/util.js')\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume,\n  kSize,\n  kHTTPContext,\n  kClosed,\n  kBodyTimeout\n} = require('../core/symbols.js')\nconst { channels } = require('../core/diagnostics.js')\n\nconst kOpenStreams = Symbol('open streams')\n\nlet extractBody\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = require('node:http2')\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nfunction connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams],\n    settings: {\n      // TODO(metcoder95): add support for PUSH\n      enablePush: false\n    }\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n  session[kHTTP2Session] = null\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHttp2SessionGoAway)\n  util.addListener(session, 'close', onHttp2SessionClose)\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', onHttp2SocketError)\n  util.addListener(socket, 'end', onHttp2SocketEnd)\n  util.addListener(socket, 'close', onHttp2SocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (request) {\n      return writeH2(client, request)\n    },\n    resume () {\n      resumeH2(client)\n    },\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction resumeH2 (client) {\n  const socket = client[kSocket]\n\n  if (socket?.destroyed === false) {\n    if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {\n      socket.unref()\n      client[kHTTP2Session].unref()\n    } else {\n      socket.ref()\n      client[kHTTP2Session].ref()\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n *\n * @this {import('http2').ClientHttp2Session}\n * @param {number} errorCode\n */\nfunction onHttp2SessionGoAway (errorCode) {\n  // TODO(mcollina): Verify if GOAWAY implements the spec correctly:\n  // https://datatracker.ietf.org/doc/html/rfc7540#section-6.8\n  // Specifically, we do not verify the \"valid\" stream id.\n\n  const err = this[kError] || new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]))\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  // this is an HTTP2 session\n  this.close()\n  this[kHTTP2Session] = null\n\n  util.destroy(this[kSocket], err)\n\n  // Fail head of pipeline.\n  if (client[kRunningIdx] < client[kQueue].length) {\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n    util.errorRequest(client, request, err)\n    client[kPendingIdx] = client[kRunningIdx]\n  }\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n  client.emit('connectionError', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SessionClose () {\n  const { [kClient]: client } = this\n  const { [kSocket]: socket } = client\n\n  const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  }\n}\n\nfunction onHttp2SocketClose () {\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kHTTP2Session][kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (this[kHTTP2Session] !== null) {\n    this[kHTTP2Session].destroy(err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2SocketEnd () {\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout]\n  const session = client[kHTTP2Session]\n  const { method, path, host, upgrade, expectContinue, signal, protocol, headers: reqHeaders } = request\n  let { body } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (key === 'cookie') {\n      if (headers[key] != null) {\n        headers[key] = Array.isArray(headers[key]) ? (headers[key].push(val), headers[key]) : [headers[key], val]\n      } else {\n        headers[key] = val\n      }\n\n      continue\n    }\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `, ${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else if (headers[key]) {\n      headers[key] += `, ${val}`\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream = null\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      // Some chunks might still come after abort,\n      // let's ignore them\n      stream.removeAllListeners('data')\n\n      // On Abort, we close the stream to send RST_STREAM frame\n      stream.close()\n\n      // We move the running index to the next request\n      client[kOnError](err)\n      client[kResume]()\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream gets destroyed and the session remains to create new streams\n    util.destroy(body, err)\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (!stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n      client[kQueue][client[kRunningIdx]++] = null\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n        client[kQueue][client[kRunningIdx]++] = null\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n    stream.setTimeout(requestTimeout)\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = protocol === 'http:' ? 'http' : 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (util.isFormDataLike(body)) {\n    extractBody ??= require('../web/fetch/body.js').extractBody\n\n    const [bodyStream, contentType] = extractBody(body)\n    headers['content-type'] = contentType\n\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  }\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  if (channels.sendHeaders.hasSubscribers) {\n    let header = ''\n    for (const key in headers) {\n      header += `${key}: ${headers[key]}\\r\\n`\n    }\n    channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] })\n  }\n\n  // TODO(metcoder95): add support for sending trailers\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n  stream.setTimeout(requestTimeout)\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      stream.removeAllListeners('data')\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', (err) => {\n    stream.removeAllListeners('data')\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      // Do not complete the request if it was aborted\n      // Not prone to happen for as safety net to avoid race conditions with 'trailers'\n      if (!request.aborted && !request.completed) {\n        request.onComplete({})\n      }\n\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kResume]()\n    } else {\n      // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n      // It does not have sense to continue working with the stream as we do not\n      // have yet RST_STREAM support on client-side\n      --session[kOpenStreams]\n      if (session[kOpenStreams] === 0) {\n        session.unref()\n      }\n\n      abort(err ?? new InformationalError('HTTP/2: stream half-closed (remote)'))\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kPendingIdx] = client[kRunningIdx]\n      client[kResume]()\n    }\n  })\n\n  stream.once('close', () => {\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    stream.removeAllListeners('data')\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    stream.removeAllListeners('data')\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  stream.on('aborted', () => {\n    stream.removeAllListeners('data')\n  })\n\n  stream.on('timeout', () => {\n    const err = new InformationalError(`HTTP/2: \"stream timeout after ${requestTimeout}\"`)\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n\n    abort(err)\n  })\n\n  stream.once('trailers', trailers => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    request.onComplete(trailers)\n  })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2005, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/client.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst net = require('node:net')\nconst http = require('node:http')\nconst util = require('../core/util.js')\nconst { ClientStats } = require('../util/stats.js')\nconst { channels } = require('../core/diagnostics.js')\nconst Request = require('../core/request.js')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = require('../core/errors.js')\nconst buildConnector = require('../core/connect.js')\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = require('../core/symbols.js')\nconst connectH1 = require('./client-h1.js')\nconst connectH2 = require('./client-h2.js')\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst getDefaultNodeMaxHeaderSize = http &&\n  http.maxHeaderSize &&\n  Number.isInteger(http.maxHeaderSize) &&\n  http.maxHeaderSize > 0\n  ? () => http.maxHeaderSize\n  : () => { throw new InvalidArgumentError('http module not available or http.maxHeaderSize invalid') }\n\nconst noop = () => {}\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null) {\n      if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {\n        throw new InvalidArgumentError('invalid maxHeaderSize')\n      }\n    } else {\n      // If maxHeaderSize is not provided, use the default value from the http module\n      // or if that is not available, throw an error.\n      maxHeaderSize = getDefaultNodeMaxHeaderSize()\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    super()\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get stats () {\n    return new ClientStats(this)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const request = new Request(this[kUrl].origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\n/**\n * @param {Client} client\n * @returns {void}\n */\nfunction connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIPv6(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  client[kConnector]({\n    host,\n    hostname,\n    protocol,\n    port,\n    servername: client[kServerName],\n    localAddress: client[kLocalAddress]\n  }, (err, socket) => {\n    if (err) {\n      handleConnectError(client, err, { host, hostname, protocol, port })\n      client[kResume]()\n      return\n    }\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', noop), new ClientDestroyedError())\n      client[kResume]()\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? connectH2(client, socket)\n        : connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', noop)\n      handleConnectError(client, err, { host, hostname, protocol, port })\n      client[kResume]()\n      return\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n\n    client.emit('connect', client[kUrl], [client])\n    client[kResume]()\n  })\n}\n\nfunction handleConnectError (client, err, { host, hostname, protocol, port }) {\n  if (client.destroyed) {\n    return\n  }\n\n  client[kConnecting] = false\n\n  if (channels.connectError.hasSubscribers) {\n    channels.connectError.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector],\n      error: err\n    })\n  }\n\n  if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n    assert(client[kRunning] === 0)\n    while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n      const request = client[kQueue][client[kPendingIdx]++]\n      util.errorRequest(client, request, err)\n    }\n  } else {\n    onError(client, err)\n  }\n\n  client.emit('connectionError', client[kUrl], [client], err)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2459, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/fixed-queue.js"],"sourcesContent":["'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048\nconst kMask = kSize - 1\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// | undefined | <-- top       |   item    |                  |   item    |\n// | undefined |               |   item    |                  |   item    |\n// | undefined |               | undefined | <-- top  top --> | undefined |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// | undefined |                               |   item    |\n// | undefined |                               |   item    |\n// |   item    | <-- bottom            top --> | undefined |\n// |   item    |                               | undefined |\n// | undefined | <-- top            bottom --> |   item    |\n// | undefined |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\n/**\n * @type {FixedCircularBuffer}\n * @template T\n */\nclass FixedCircularBuffer {\n  /** @type {number} */\n  bottom = 0\n  /** @type {number} */\n  top = 0\n  /** @type {Array<T|undefined>} */\n  list = new Array(kSize).fill(undefined)\n  /** @type {T|null} */\n  next = null\n\n  /** @returns {boolean} */\n  isEmpty () {\n    return this.top === this.bottom\n  }\n\n  /** @returns {boolean} */\n  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom\n  }\n\n  /**\n   * @param {T} data\n   * @returns {void}\n   */\n  push (data) {\n    this.list[this.top] = data\n    this.top = (this.top + 1) & kMask\n  }\n\n  /** @returns {T|null} */\n  shift () {\n    const nextItem = this.list[this.bottom]\n    if (nextItem === undefined) { return null }\n    this.list[this.bottom] = undefined\n    this.bottom = (this.bottom + 1) & kMask\n    return nextItem\n  }\n}\n\n/**\n * @template T\n */\nmodule.exports = class FixedQueue {\n  constructor () {\n    /** @type {FixedCircularBuffer<T>} */\n    this.head = this.tail = new FixedCircularBuffer()\n  }\n\n  /** @returns {boolean} */\n  isEmpty () {\n    return this.head.isEmpty()\n  }\n\n  /** @param {T} data */\n  push (data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer()\n    }\n    this.head.push(data)\n  }\n\n  /** @returns {T|null} */\n  shift () {\n    const tail = this.tail\n    const next = tail.shift()\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next\n      tail.next = null\n    }\n    return next\n  }\n}\n"],"names":[],"mappings":"AAEA,kDAAkD;AAElD,8EAA8E;AAC9E,MAAM,QAAQ;AACd,MAAM,QAAQ,QAAQ;AAEtB,sEAAsE;AACtE,kDAAkD;AAClD,EAAE;AACF,mEAAmE;AACnE,kEAAkE;AAClE,kEAAkE;AAClE,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,2EAA2E;AAC3E,EAAE;AACF,+DAA+D;AAC/D,wBAAwB;AACxB,EAAE;AACF,2DAA2D;AAC3D,yDAAyD;AACzD,yDAAyD;AACzD,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,EAAE;AACF,mEAAmE;AACnE,oEAAoE;AACpE,gBAAgB;AAChB,EAAE;AACF,4DAA4D;AAC5D,wEAAwE;AACxE,kCAAkC;AAElC;;;CAGC,GACD,MAAM;IACJ,mBAAmB,GACnB,SAAS,EAAC;IACV,mBAAmB,GACnB,MAAM,EAAC;IACP,+BAA+B,GAC/B,OAAO,IAAI,MAAM,OAAO,IAAI,CAAC,WAAU;IACvC,mBAAmB,GACnB,OAAO,KAAI;IAEX,uBAAuB,GACvB,UAAW;QACT,OAAO,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,MAAM;IACjC;IAEA,uBAAuB,GACvB,SAAU;QACR,OAAO,CAAC,AAAC,IAAI,CAAC,GAAG,GAAG,IAAK,KAAK,MAAM,IAAI,CAAC,MAAM;IACjD;IAEA;;;GAGC,GACD,KAAM,IAAI,EAAE;QACV,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;QACtB,IAAI,CAAC,GAAG,GAAG,AAAC,IAAI,CAAC,GAAG,GAAG,IAAK;IAC9B;IAEA,sBAAsB,GACtB,QAAS;QACP,MAAM,WAAW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QACvC,IAAI,aAAa,WAAW;YAAE,OAAO;QAAK;QAC1C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG;QACzB,IAAI,CAAC,MAAM,GAAG,AAAC,IAAI,CAAC,MAAM,GAAG,IAAK;QAClC,OAAO;IACT;AACF;AAEA;;CAEC,GACD,OAAO,OAAO,GAAG,MAAM;IACrB,aAAe;QACb,mCAAmC,GACnC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI;IAC9B;IAEA,uBAAuB,GACvB,UAAW;QACT,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO;IAC1B;IAEA,oBAAoB,GACpB,KAAM,IAAI,EAAE;QACV,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI;YACtB,yEAAyE;YACzE,qCAAqC;YACrC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI;QACnC;QACA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IACjB;IAEA,sBAAsB,GACtB,QAAS;QACP,MAAM,OAAO,IAAI,CAAC,IAAI;QACtB,MAAM,OAAO,KAAK,KAAK;QACvB,IAAI,KAAK,OAAO,MAAM,KAAK,IAAI,KAAK,MAAM;YACxC,oDAAoD;YACpD,IAAI,CAAC,IAAI,GAAG,KAAK,IAAI;YACrB,KAAK,IAAI,GAAG;QACd;QACA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2573, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/pool-base.js"],"sourcesContent":["'use strict'\n\nconst { PoolStats } = require('../util/stats.js')\nconst DispatcherBase = require('./dispatcher-base')\nconst FixedQueue = require('./fixed-queue')\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require('../core/symbols')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\n\nclass PoolBase extends DispatcherBase {\n  [kQueue] = new FixedQueue();\n\n  [kQueued] = 0;\n\n  [kClients] = [];\n\n  [kNeedDrain] = false;\n\n  [kOnDrain] (client, origin, targets) {\n    const queue = this[kQueue]\n\n    let needDrain = false\n\n    while (!needDrain) {\n      const item = queue.shift()\n      if (!item) {\n        break\n      }\n      this[kQueued]--\n      needDrain = !client.dispatch(item.opts, item.handler)\n    }\n\n    client[kNeedDrain] = needDrain\n\n    if (!needDrain && this[kNeedDrain]) {\n      this[kNeedDrain] = false\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    if (this[kClosedResolve] && queue.isEmpty()) {\n      const closeAll = new Array(this[kClients].length)\n      for (let i = 0; i < this[kClients].length; i++) {\n        closeAll[i] = this[kClients][i].close()\n      }\n      Promise.all(closeAll)\n        .then(this[kClosedResolve])\n    }\n  }\n\n  [kOnConnect] = (origin, targets) => {\n    this.emit('connect', origin, [this, ...targets])\n  };\n\n  [kOnDisconnect] = (origin, targets, err) => {\n    this.emit('disconnect', origin, [this, ...targets], err)\n  };\n\n  [kOnConnectionError] = (origin, targets, err) => {\n    this.emit('connectionError', origin, [this, ...targets], err)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    let ret = 0\n    for (const { [kConnected]: connected } of this[kClients]) {\n      ret += connected\n    }\n    return ret\n  }\n\n  get [kFree] () {\n    let ret = 0\n    for (const { [kConnected]: connected, [kNeedDrain]: needDrain } of this[kClients]) {\n      ret += connected && !needDrain\n    }\n    return ret\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return new PoolStats(this)\n  }\n\n  [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      const closeAll = new Array(this[kClients].length)\n      for (let i = 0; i < this[kClients].length; i++) {\n        closeAll[i] = this[kClients][i].close()\n      }\n      return Promise.all(closeAll)\n    } else {\n      return new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const destroyAll = new Array(this[kClients].length)\n    for (let i = 0; i < this[kClients].length; i++) {\n      destroyAll[i] = this[kClients][i].destroy(err)\n    }\n    return Promise.all(destroyAll)\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain].bind(this, client))\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client, client[kUrl], [client, this])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2758, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher,\n  kRemoveClient\n} = require('./pool-base')\nconst Client = require('./client')\nconst {\n  InvalidArgumentError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { kUrl } = require('../core/symbols')\nconst buildConnector = require('../core/connect')\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    clientTtl,\n    ...options\n  } = {}) {\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    super()\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n\n    this.on('connect', (origin, targets) => {\n      if (clientTtl != null && clientTtl > 0) {\n        for (const target of targets) {\n          Object.assign(target, { ttl: Date.now() })\n        }\n      }\n    })\n\n    this.on('connectionError', (origin, targets, error) => {\n      // If a connection error occurs, we remove the client from the pool,\n      // and emit a connectionError event. They will not be re-used.\n      // Fixes https://github.com/nodejs/undici/issues/3895\n      for (const target of targets) {\n        // Do not use kRemoveClient here, as it will close the client,\n        // but the client cannot be closed in this state.\n        const idx = this[kClients].indexOf(target)\n        if (idx !== -1) {\n          this[kClients].splice(idx, 1)\n        }\n      }\n    })\n  }\n\n  [kGetDispatcher] () {\n    const clientTtlOption = this[kOptions].clientTtl\n    for (const client of this[kClients]) {\n      // check ttl of client and if it's stale, remove it from the pool\n      if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && ((Date.now() - client.ttl) > clientTtlOption)) {\n        this[kRemoveClient](client)\n      } else if (!client[kNeedDrain]) {\n        return client\n      }\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = Pool\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2853, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/balanced-pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('../core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl } = require('../core/symbols')\nconst { parseOrigin } = require('../core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2999, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, MaxOriginsReachedError } = require('../core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = require('../core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('../core/util')\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\nconst kOrigins = Symbol('origins')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxOrigins = Infinity, connect, ...options } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof maxOrigins !== 'number' || Number.isNaN(maxOrigins) || maxOrigins <= 0) {\n      throw new InvalidArgumentError('maxOrigins must be a number greater than 0')\n    }\n\n    super()\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), maxOrigins, connect }\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kOrigins] = new Set()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { dispatcher } of this[kClients].values()) {\n      ret += dispatcher[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    if (this[kOrigins].size >= this[kOptions].maxOrigins && !this[kOrigins].has(key)) {\n      throw new MaxOriginsReachedError()\n    }\n\n    const result = this[kClients].get(key)\n    let dispatcher = result && result.dispatcher\n    if (!dispatcher) {\n      const closeClientIfUnused = (connected) => {\n        const result = this[kClients].get(key)\n        if (result) {\n          if (connected) result.count -= 1\n          if (result.count <= 0) {\n            this[kClients].delete(key)\n            result.dispatcher.close()\n          }\n          this[kOrigins].delete(key)\n        }\n      }\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', (origin, targets) => {\n          const result = this[kClients].get(key)\n          if (result) {\n            result.count += 1\n          }\n          this[kOnConnect](origin, targets)\n        })\n        .on('disconnect', (origin, targets, err) => {\n          closeClientIfUnused(true)\n          this[kOnDisconnect](origin, targets, err)\n        })\n        .on('connectionError', (origin, targets, err) => {\n          closeClientIfUnused(false)\n          this[kOnConnectionError](origin, targets, err)\n        })\n\n      this[kClients].set(key, { count: 0, dispatcher })\n      this[kOrigins].add(key)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  [kClose] () {\n    const closePromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      closePromises.push(dispatcher.close())\n    }\n    this[kClients].clear()\n\n    return Promise.all(closePromises)\n  }\n\n  [kDestroy] (err) {\n    const destroyPromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      destroyPromises.push(dispatcher.destroy(err))\n    }\n    this[kClients].clear()\n\n    return Promise.all(destroyPromises)\n  }\n\n  get stats () {\n    const allClientStats = {}\n    for (const { dispatcher } of this[kClients].values()) {\n      if (dispatcher.stats) {\n        allClientStats[dispatcher[kUrl].origin] = dispatcher.stats\n      }\n    }\n    return allClientStats\n  }\n}\n\nmodule.exports = Agent\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3148, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kProxy, kClose, kDestroy, kDispatch } = require('../core/symbols')\nconst Agent = require('./agent')\nconst Pool = require('./pool')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require('../core/errors')\nconst buildConnector = require('../core/connect')\nconst Client = require('./client')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\nconst kTunnelProxy = Symbol('tunnel proxy')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nconst noop = () => {}\n\nfunction defaultAgentFactory (origin, opts) {\n  if (opts.connections === 1) {\n    return new Client(origin, opts)\n  }\n  return new Pool(origin, opts)\n}\n\nclass Http1ProxyWrapper extends DispatcherBase {\n  #client\n\n  constructor (proxyUrl, { headers = {}, connect, factory }) {\n    if (!proxyUrl) {\n      throw new InvalidArgumentError('Proxy URL is mandatory')\n    }\n\n    super()\n\n    this[kProxyHeaders] = headers\n    if (factory) {\n      this.#client = factory(proxyUrl, { connect })\n    } else {\n      this.#client = new Client(proxyUrl, { connect })\n    }\n  }\n\n  [kDispatch] (opts, handler) {\n    const onHeaders = handler.onHeaders\n    handler.onHeaders = function (statusCode, data, resume) {\n      if (statusCode === 407) {\n        if (typeof handler.onError === 'function') {\n          handler.onError(new InvalidArgumentError('Proxy Authentication Required (407)'))\n        }\n        return\n      }\n      if (onHeaders) onHeaders.call(this, statusCode, data, resume)\n    }\n\n    // Rewrite request as an HTTP1 Proxy request, without tunneling.\n    const {\n      origin,\n      path = '/',\n      headers = {}\n    } = opts\n\n    opts.path = origin + path\n\n    if (!('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(origin)\n      headers.host = host\n    }\n    opts.headers = { ...this[kProxyHeaders], ...headers }\n\n    return this.#client[kDispatch](opts, handler)\n  }\n\n  [kClose] () {\n    return this.#client.close()\n  }\n\n  [kDestroy] (err) {\n    return this.#client.destroy(err)\n  }\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const { proxyTunnel = true } = opts\n\n    super()\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n    this[kTunnelProxy] = proxyTunnel\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n\n    const agentFactory = opts.factory || defaultAgentFactory\n    const factory = (origin, options) => {\n      const { protocol } = new URL(origin)\n      if (!this[kTunnelProxy] && protocol === 'http:' && this[kProxy].protocol === 'http:') {\n        return new Http1ProxyWrapper(this[kProxy].uri, {\n          headers: this[kProxyHeaders],\n          connect,\n          factory: agentFactory\n        })\n      }\n      return agentFactory(origin, options)\n    }\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      factory,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host,\n              ...(opts.connections == null || opts.connections > 0 ? { 'proxy-connection': 'keep-alive' } : {})\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', noop).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  [kClose] () {\n    return Promise.all([\n      this[kAgent].close(),\n      this[kClient].close()\n    ])\n  }\n\n  [kDestroy] () {\n    return Promise.all([\n      this[kAgent].destroy(),\n      this[kClient].destroy()\n    ])\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst DispatcherBase = require('./dispatcher-base')\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require('../core/symbols')\nconst ProxyAgent = require('./proxy-agent')\nconst Agent = require('./agent')\n\nconst DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443\n}\n\nclass EnvHttpProxyAgent extends DispatcherBase {\n  #noProxyValue = null\n  #noProxyEntries = null\n  #opts = null\n\n  constructor (opts = {}) {\n    super()\n    this.#opts = opts\n\n    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts\n\n    this[kNoProxyAgent] = new Agent(agentOpts)\n\n    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY\n    if (HTTP_PROXY) {\n      this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY })\n    } else {\n      this[kHttpProxyAgent] = this[kNoProxyAgent]\n    }\n\n    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY\n    if (HTTPS_PROXY) {\n      this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY })\n    } else {\n      this[kHttpsProxyAgent] = this[kHttpProxyAgent]\n    }\n\n    this.#parseNoProxy()\n  }\n\n  [kDispatch] (opts, handler) {\n    const url = new URL(opts.origin)\n    const agent = this.#getProxyAgentForUrl(url)\n    return agent.dispatch(opts, handler)\n  }\n\n  [kClose] () {\n    return Promise.all([\n      this[kNoProxyAgent].close(),\n      !this[kHttpProxyAgent][kClosed] && this[kHttpProxyAgent].close(),\n      !this[kHttpsProxyAgent][kClosed] && this[kHttpsProxyAgent].close()\n    ])\n  }\n\n  [kDestroy] (err) {\n    return Promise.all([\n      this[kNoProxyAgent].destroy(err),\n      !this[kHttpProxyAgent][kDestroyed] && this[kHttpProxyAgent].destroy(err),\n      !this[kHttpsProxyAgent][kDestroyed] && this[kHttpsProxyAgent].destroy(err)\n    ])\n  }\n\n  #getProxyAgentForUrl (url) {\n    let { protocol, host: hostname, port } = url\n\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, '').toLowerCase()\n    port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0\n    if (!this.#shouldProxy(hostname, port)) {\n      return this[kNoProxyAgent]\n    }\n    if (protocol === 'https:') {\n      return this[kHttpsProxyAgent]\n    }\n    return this[kHttpProxyAgent]\n  }\n\n  #shouldProxy (hostname, port) {\n    if (this.#noProxyChanged) {\n      this.#parseNoProxy()\n    }\n\n    if (this.#noProxyEntries.length === 0) {\n      return true // Always proxy if NO_PROXY is not set or empty.\n    }\n    if (this.#noProxyValue === '*') {\n      return false // Never proxy if wildcard is set.\n    }\n\n    for (let i = 0; i < this.#noProxyEntries.length; i++) {\n      const entry = this.#noProxyEntries[i]\n      if (entry.port && entry.port !== port) {\n        continue // Skip if ports don't match.\n      }\n      if (!/^[.*]/.test(entry.hostname)) {\n        // No wildcards, so don't proxy only if there is not an exact match.\n        if (hostname === entry.hostname) {\n          return false\n        }\n      } else {\n        // Don't proxy if the hostname ends with the no_proxy host.\n        if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  #parseNoProxy () {\n    const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv\n    const noProxySplit = noProxyValue.split(/[,\\s]/)\n    const noProxyEntries = []\n\n    for (let i = 0; i < noProxySplit.length; i++) {\n      const entry = noProxySplit[i]\n      if (!entry) {\n        continue\n      }\n      const parsed = entry.match(/^(.+):(\\d+)$/)\n      noProxyEntries.push({\n        hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n        port: parsed ? Number.parseInt(parsed[2], 10) : 0\n      })\n    }\n\n    this.#noProxyValue = noProxyValue\n    this.#noProxyEntries = noProxyEntries\n  }\n\n  get #noProxyChanged () {\n    if (this.#opts.noProxy !== undefined) {\n      return false\n    }\n    return this.#noProxyValue !== this.#noProxyEnv\n  }\n\n  get #noProxyEnv () {\n    return process.env.no_proxy ?? process.env.NO_PROXY ?? ''\n  }\n}\n\nmodule.exports = EnvHttpProxyAgent\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3532, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/retry-agent.js"],"sourcesContent":["'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst RetryHandler = require('../handler/retry-handler')\n\nclass RetryAgent extends Dispatcher {\n  #agent = null\n  #options = null\n  constructor (agent, options = {}) {\n    super(options)\n    this.#agent = agent\n    this.#options = options\n  }\n\n  dispatch (opts, handler) {\n    const retry = new RetryHandler({\n      ...opts,\n      retryOptions: this.#options\n    }, {\n      dispatch: this.#agent.dispatch.bind(this.#agent),\n      handler\n    })\n    return this.#agent.dispatch(opts, retry)\n  }\n\n  close () {\n    return this.#agent.close()\n  }\n\n  destroy () {\n    return this.#agent.destroy()\n  }\n}\n\nmodule.exports = RetryAgent\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,mBAAmB;IACvB,CAAA,KAAM,GAAG,KAAI;IACb,CAAA,OAAQ,GAAG,KAAI;IACf,YAAa,KAAK,EAAE,UAAU,CAAC,CAAC,CAAE;QAChC,KAAK,CAAC;QACN,IAAI,CAAC,CAAA,KAAM,GAAG;QACd,IAAI,CAAC,CAAA,OAAQ,GAAG;IAClB;IAEA,SAAU,IAAI,EAAE,OAAO,EAAE;QACvB,MAAM,QAAQ,IAAI,aAAa;YAC7B,GAAG,IAAI;YACP,cAAc,IAAI,CAAC,CAAA,OAAQ;QAC7B,GAAG;YACD,UAAU,IAAI,CAAC,CAAA,KAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,KAAM;YAC/C;QACF;QACA,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,QAAQ,CAAC,MAAM;IACpC;IAEA,QAAS;QACP,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,KAAK;IAC1B;IAEA,UAAW;QACT,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,OAAO;IAC5B;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3564, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/dispatcher/h2c-client.js"],"sourcesContent":["'use strict'\nconst { connect } = require('node:net')\n\nconst { kClose, kDestroy } = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\nconst util = require('../core/util')\n\nconst Client = require('./client')\nconst DispatcherBase = require('./dispatcher-base')\n\nclass H2CClient extends DispatcherBase {\n  #client = null\n\n  constructor (origin, clientOpts) {\n    if (typeof origin === 'string') {\n      origin = new URL(origin)\n    }\n\n    if (origin.protocol !== 'http:') {\n      throw new InvalidArgumentError(\n        'h2c-client: Only h2c protocol is supported'\n      )\n    }\n\n    const { connect, maxConcurrentStreams, pipelining, ...opts } =\n      clientOpts ?? {}\n    let defaultMaxConcurrentStreams = 100\n    let defaultPipelining = 100\n\n    if (\n      maxConcurrentStreams != null &&\n      Number.isInteger(maxConcurrentStreams) &&\n      maxConcurrentStreams > 0\n    ) {\n      defaultMaxConcurrentStreams = maxConcurrentStreams\n    }\n\n    if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {\n      defaultPipelining = pipelining\n    }\n\n    if (defaultPipelining > defaultMaxConcurrentStreams) {\n      throw new InvalidArgumentError(\n        'h2c-client: pipelining cannot be greater than maxConcurrentStreams'\n      )\n    }\n\n    super()\n\n    this.#client = new Client(origin, {\n      ...opts,\n      connect: this.#buildConnector(connect),\n      maxConcurrentStreams: defaultMaxConcurrentStreams,\n      pipelining: defaultPipelining,\n      allowH2: true\n    })\n  }\n\n  #buildConnector (connectOpts) {\n    return (opts, callback) => {\n      const timeout = connectOpts?.connectOpts ?? 10e3\n      const { hostname, port, pathname } = opts\n      const socket = connect({\n        ...opts,\n        host: hostname,\n        port,\n        pathname\n      })\n\n      // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n      if (opts.keepAlive == null || opts.keepAlive) {\n        const keepAliveInitialDelay =\n          opts.keepAliveInitialDelay == null ? 60e3 : opts.keepAliveInitialDelay\n        socket.setKeepAlive(true, keepAliveInitialDelay)\n      }\n\n      socket.alpnProtocol = 'h2'\n\n      const clearConnectTimeout = util.setupConnectTimeout(\n        new WeakRef(socket),\n        { timeout, hostname, port }\n      )\n\n      socket\n        .setNoDelay(true)\n        .once('connect', function () {\n          queueMicrotask(clearConnectTimeout)\n\n          if (callback) {\n            const cb = callback\n            callback = null\n            cb(null, this)\n          }\n        })\n        .on('error', function (err) {\n          queueMicrotask(clearConnectTimeout)\n\n          if (callback) {\n            const cb = callback\n            callback = null\n            cb(err)\n          }\n        })\n\n      return socket\n    }\n  }\n\n  dispatch (opts, handler) {\n    return this.#client.dispatch(opts, handler)\n  }\n\n  [kClose] () {\n    return this.#client.close()\n  }\n\n  [kDestroy] () {\n    return this.#client.destroy()\n  }\n}\n\nmodule.exports = H2CClient\n"],"names":[],"mappings":"AACA,MAAM,EAAE,OAAO,EAAE;AAEjB,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE;AAC1B,MAAM,EAAE,oBAAoB,EAAE;AAC9B,MAAM;AAEN,MAAM;AACN,MAAM;AAEN,MAAM,kBAAkB;IACtB,CAAA,MAAO,GAAG,KAAI;IAEd,YAAa,MAAM,EAAE,UAAU,CAAE;QAC/B,IAAI,OAAO,WAAW,UAAU;YAC9B,SAAS,IAAI,IAAI;QACnB;QAEA,IAAI,OAAO,QAAQ,KAAK,SAAS;YAC/B,MAAM,IAAI,qBACR;QAEJ;QAEA,MAAM,EAAE,OAAO,EAAE,oBAAoB,EAAE,UAAU,EAAE,GAAG,MAAM,GAC1D,cAAc,CAAC;QACjB,IAAI,8BAA8B;QAClC,IAAI,oBAAoB;QAExB,IACE,wBAAwB,QACxB,OAAO,SAAS,CAAC,yBACjB,uBAAuB,GACvB;YACA,8BAA8B;QAChC;QAEA,IAAI,cAAc,QAAQ,OAAO,SAAS,CAAC,eAAe,aAAa,GAAG;YACxE,oBAAoB;QACtB;QAEA,IAAI,oBAAoB,6BAA6B;YACnD,MAAM,IAAI,qBACR;QAEJ;QAEA,KAAK;QAEL,IAAI,CAAC,CAAA,MAAO,GAAG,IAAI,OAAO,QAAQ;YAChC,GAAG,IAAI;YACP,SAAS,IAAI,CAAC,CAAA,cAAe,CAAC;YAC9B,sBAAsB;YACtB,YAAY;YACZ,SAAS;QACX;IACF;IAEA,CAAA,cAAe,CAAE,WAAW;QAC1B,OAAO,CAAC,MAAM;YACZ,MAAM,UAAU,aAAa,eAAe;YAC5C,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG;YACrC,MAAM,SAAS,QAAQ;gBACrB,GAAG,IAAI;gBACP,MAAM;gBACN;gBACA;YACF;YAEA,6GAA6G;YAC7G,IAAI,KAAK,SAAS,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC5C,MAAM,wBACJ,KAAK,qBAAqB,IAAI,OAAO,OAAO,KAAK,qBAAqB;gBACxE,OAAO,YAAY,CAAC,MAAM;YAC5B;YAEA,OAAO,YAAY,GAAG;YAEtB,MAAM,sBAAsB,KAAK,mBAAmB,CAClD,IAAI,QAAQ,SACZ;gBAAE;gBAAS;gBAAU;YAAK;YAG5B,OACG,UAAU,CAAC,MACX,IAAI,CAAC,WAAW;gBACf,eAAe;gBAEf,IAAI,UAAU;oBACZ,MAAM,KAAK;oBACX,WAAW;oBACX,GAAG,MAAM,IAAI;gBACf;YACF,GACC,EAAE,CAAC,SAAS,SAAU,GAAG;gBACxB,eAAe;gBAEf,IAAI,UAAU;oBACZ,MAAM,KAAK;oBACX,WAAW;oBACX,GAAG;gBACL;YACF;YAEF,OAAO;QACT;IACF;IAEA,SAAU,IAAI,EAAE,OAAO,EAAE;QACvB,OAAO,IAAI,CAAC,CAAA,MAAO,CAAC,QAAQ,CAAC,MAAM;IACrC;IAEA,CAAC,OAAO,GAAI;QACV,OAAO,IAAI,CAAC,CAAA,MAAO,CAAC,KAAK;IAC3B;IAEA,CAAC,SAAS,GAAI;QACZ,OAAO,IAAI,CAAC,CAAA,MAAO,CAAC,OAAO;IAC7B;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}}]
}