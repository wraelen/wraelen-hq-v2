{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/symbols.js"],"sourcesContent":["'use strict'\n\nmodule.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kBody: Symbol('abstracted request body'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kResume: Symbol('resume'),\n  kOnError: Symbol('on error'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n  kConstruct: Symbol('constructable'),\n  kListeners: Symbol('listeners'),\n  kHTTPContext: Symbol('http context'),\n  kMaxConcurrentStreams: Symbol('max concurrent streams'),\n  kNoProxyAgent: Symbol('no proxy agent'),\n  kHttpProxyAgent: Symbol('http proxy agent'),\n  kHttpsProxyAgent: Symbol('https proxy agent')\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;IACf,QAAQ,OAAO;IACf,UAAU,OAAO;IACjB,WAAW,OAAO;IAClB,MAAM,OAAO;IACb,UAAU,OAAO;IACjB,WAAW,OAAO;IAClB,QAAQ,OAAO;IACf,UAAU,OAAO;IACjB,aAAa,OAAO;IACpB,0BAA0B,OAAO;IACjC,sBAAsB,OAAO;IAC7B,4BAA4B,OAAO;IACnC,wBAAwB,OAAO;IAC/B,YAAY,OAAO;IACnB,iBAAiB,OAAO;IACxB,cAAc,OAAO;IACrB,aAAa,OAAO;IACpB,eAAe,OAAO;IACtB,OAAO,OAAO;IACd,QAAQ,OAAO;IACf,WAAW,OAAO;IAClB,OAAO,OAAO;IACd,UAAU,OAAO;IACjB,WAAW,OAAO;IAClB,UAAU,OAAO;IACjB,OAAO,OAAO;IACd,OAAO,OAAO;IACd,SAAS,OAAO;IAChB,OAAO,OAAO;IACd,YAAY,OAAO;IACnB,SAAS,OAAO;IAChB,YAAY,OAAO;IACnB,QAAQ,OAAO;IACf,YAAY,OAAO,GAAG,CAAC;IACvB,SAAS,OAAO;IAChB,UAAU,OAAO;IACjB,iBAAiB,OAAO;IACxB,aAAa,OAAO;IACpB,aAAa,OAAO;IACpB,QAAQ,OAAO;IACf,UAAU,OAAO;IACjB,SAAS,OAAO;IAChB,SAAS,OAAO;IAChB,cAAc,OAAO;IACrB,aAAa,OAAO;IACpB,SAAS,OAAO;IAChB,aAAa,OAAO;IACpB,YAAY,OAAO;IACnB,sBAAsB,OAAO;IAC7B,kBAAkB,OAAO;IACzB,cAAc,OAAO;IACrB,QAAQ,OAAO;IACf,UAAU,OAAO;IACjB,kBAAkB,OAAO;IACzB,eAAe,OAAO;IACtB,oBAAoB,OAAO;IAC3B,2BAA2B,OAAO;IAClC,YAAY,OAAO;IACnB,YAAY,OAAO;IACnB,cAAc,OAAO;IACrB,uBAAuB,OAAO;IAC9B,eAAe,OAAO;IACtB,iBAAiB,OAAO;IACxB,kBAAkB,OAAO;AAC3B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/errors.js"],"sourcesContent":["'use strict'\n\nconst kUndiciError = Symbol.for('undici.error.UND_ERR')\nclass UndiciError extends Error {\n  constructor (message, options) {\n    super(message, options)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kUndiciError] === true\n  }\n\n  get [kUndiciError] () {\n    return true\n  }\n}\n\nconst kConnectTimeoutError = Symbol.for('undici.error.UND_ERR_CONNECT_TIMEOUT')\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kConnectTimeoutError] === true\n  }\n\n  get [kConnectTimeoutError] () {\n    return true\n  }\n}\n\nconst kHeadersTimeoutError = Symbol.for('undici.error.UND_ERR_HEADERS_TIMEOUT')\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHeadersTimeoutError] === true\n  }\n\n  get [kHeadersTimeoutError] () {\n    return true\n  }\n}\n\nconst kHeadersOverflowError = Symbol.for('undici.error.UND_ERR_HEADERS_OVERFLOW')\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHeadersOverflowError] === true\n  }\n\n  get [kHeadersOverflowError] () {\n    return true\n  }\n}\n\nconst kBodyTimeoutError = Symbol.for('undici.error.UND_ERR_BODY_TIMEOUT')\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kBodyTimeoutError] === true\n  }\n\n  get [kBodyTimeoutError] () {\n    return true\n  }\n}\n\nconst kInvalidArgumentError = Symbol.for('undici.error.UND_ERR_INVALID_ARG')\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInvalidArgumentError] === true\n  }\n\n  get [kInvalidArgumentError] () {\n    return true\n  }\n}\n\nconst kInvalidReturnValueError = Symbol.for('undici.error.UND_ERR_INVALID_RETURN_VALUE')\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInvalidReturnValueError] === true\n  }\n\n  get [kInvalidReturnValueError] () {\n    return true\n  }\n}\n\nconst kAbortError = Symbol.for('undici.error.UND_ERR_ABORT')\nclass AbortError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'The operation was aborted'\n    this.code = 'UND_ERR_ABORT'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kAbortError] === true\n  }\n\n  get [kAbortError] () {\n    return true\n  }\n}\n\nconst kRequestAbortedError = Symbol.for('undici.error.UND_ERR_ABORTED')\nclass RequestAbortedError extends AbortError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestAbortedError] === true\n  }\n\n  get [kRequestAbortedError] () {\n    return true\n  }\n}\n\nconst kInformationalError = Symbol.for('undici.error.UND_ERR_INFO')\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kInformationalError] === true\n  }\n\n  get [kInformationalError] () {\n    return true\n  }\n}\n\nconst kRequestContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH')\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestContentLengthMismatchError] === true\n  }\n\n  get [kRequestContentLengthMismatchError] () {\n    return true\n  }\n}\n\nconst kResponseContentLengthMismatchError = Symbol.for('undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH')\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseContentLengthMismatchError] === true\n  }\n\n  get [kResponseContentLengthMismatchError] () {\n    return true\n  }\n}\n\nconst kClientDestroyedError = Symbol.for('undici.error.UND_ERR_DESTROYED')\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kClientDestroyedError] === true\n  }\n\n  get [kClientDestroyedError] () {\n    return true\n  }\n}\n\nconst kClientClosedError = Symbol.for('undici.error.UND_ERR_CLOSED')\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kClientClosedError] === true\n  }\n\n  get [kClientClosedError] () {\n    return true\n  }\n}\n\nconst kSocketError = Symbol.for('undici.error.UND_ERR_SOCKET')\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kSocketError] === true\n  }\n\n  get [kSocketError] () {\n    return true\n  }\n}\n\nconst kNotSupportedError = Symbol.for('undici.error.UND_ERR_NOT_SUPPORTED')\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kNotSupportedError] === true\n  }\n\n  get [kNotSupportedError] () {\n    return true\n  }\n}\n\nconst kBalancedPoolMissingUpstreamError = Symbol.for('undici.error.UND_ERR_BPL_MISSING_UPSTREAM')\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kBalancedPoolMissingUpstreamError] === true\n  }\n\n  get [kBalancedPoolMissingUpstreamError] () {\n    return true\n  }\n}\n\nconst kHTTPParserError = Symbol.for('undici.error.UND_ERR_HTTP_PARSER')\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kHTTPParserError] === true\n  }\n\n  get [kHTTPParserError] () {\n    return true\n  }\n}\n\nconst kResponseExceededMaxSizeError = Symbol.for('undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE')\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseExceededMaxSizeError] === true\n  }\n\n  get [kResponseExceededMaxSizeError] () {\n    return true\n  }\n}\n\nconst kRequestRetryError = Symbol.for('undici.error.UND_ERR_REQ_RETRY')\nclass RequestRetryError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'RequestRetryError'\n    this.message = message || 'Request retry error'\n    this.code = 'UND_ERR_REQ_RETRY'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kRequestRetryError] === true\n  }\n\n  get [kRequestRetryError] () {\n    return true\n  }\n}\n\nconst kResponseError = Symbol.for('undici.error.UND_ERR_RESPONSE')\nclass ResponseError extends UndiciError {\n  constructor (message, code, { headers, body }) {\n    super(message)\n    this.name = 'ResponseError'\n    this.message = message || 'Response error'\n    this.code = 'UND_ERR_RESPONSE'\n    this.statusCode = code\n    this.body = body\n    this.headers = headers\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kResponseError] === true\n  }\n\n  get [kResponseError] () {\n    return true\n  }\n}\n\nconst kSecureProxyConnectionError = Symbol.for('undici.error.UND_ERR_PRX_TLS')\nclass SecureProxyConnectionError extends UndiciError {\n  constructor (cause, message, options = {}) {\n    super(message, { cause, ...options })\n    this.name = 'SecureProxyConnectionError'\n    this.message = message || 'Secure Proxy Connection failed'\n    this.code = 'UND_ERR_PRX_TLS'\n    this.cause = cause\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kSecureProxyConnectionError] === true\n  }\n\n  get [kSecureProxyConnectionError] () {\n    return true\n  }\n}\n\nconst kMaxOriginsReachedError = Symbol.for('undici.error.UND_ERR_MAX_ORIGINS_REACHED')\nclass MaxOriginsReachedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MaxOriginsReachedError'\n    this.message = message || 'Maximum allowed origins reached'\n    this.code = 'UND_ERR_MAX_ORIGINS_REACHED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kMaxOriginsReachedError] === true\n  }\n\n  get [kMaxOriginsReachedError] () {\n    return true\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError,\n  RequestRetryError,\n  ResponseError,\n  SecureProxyConnectionError,\n  MaxOriginsReachedError\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 458, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/constants.js"],"sourcesContent":["'use strict'\n\n/**\n * @see https://developer.mozilla.org/docs/Web/HTTP/Headers\n */\nconst wellknownHeaderNames = /** @type {const} */ ([\n  'Accept',\n  'Accept-Encoding',\n  'Accept-Language',\n  'Accept-Ranges',\n  'Access-Control-Allow-Credentials',\n  'Access-Control-Allow-Headers',\n  'Access-Control-Allow-Methods',\n  'Access-Control-Allow-Origin',\n  'Access-Control-Expose-Headers',\n  'Access-Control-Max-Age',\n  'Access-Control-Request-Headers',\n  'Access-Control-Request-Method',\n  'Age',\n  'Allow',\n  'Alt-Svc',\n  'Alt-Used',\n  'Authorization',\n  'Cache-Control',\n  'Clear-Site-Data',\n  'Connection',\n  'Content-Disposition',\n  'Content-Encoding',\n  'Content-Language',\n  'Content-Length',\n  'Content-Location',\n  'Content-Range',\n  'Content-Security-Policy',\n  'Content-Security-Policy-Report-Only',\n  'Content-Type',\n  'Cookie',\n  'Cross-Origin-Embedder-Policy',\n  'Cross-Origin-Opener-Policy',\n  'Cross-Origin-Resource-Policy',\n  'Date',\n  'Device-Memory',\n  'Downlink',\n  'ECT',\n  'ETag',\n  'Expect',\n  'Expect-CT',\n  'Expires',\n  'Forwarded',\n  'From',\n  'Host',\n  'If-Match',\n  'If-Modified-Since',\n  'If-None-Match',\n  'If-Range',\n  'If-Unmodified-Since',\n  'Keep-Alive',\n  'Last-Modified',\n  'Link',\n  'Location',\n  'Max-Forwards',\n  'Origin',\n  'Permissions-Policy',\n  'Pragma',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'RTT',\n  'Range',\n  'Referer',\n  'Referrer-Policy',\n  'Refresh',\n  'Retry-After',\n  'Sec-WebSocket-Accept',\n  'Sec-WebSocket-Extensions',\n  'Sec-WebSocket-Key',\n  'Sec-WebSocket-Protocol',\n  'Sec-WebSocket-Version',\n  'Server',\n  'Server-Timing',\n  'Service-Worker-Allowed',\n  'Service-Worker-Navigation-Preload',\n  'Set-Cookie',\n  'SourceMap',\n  'Strict-Transport-Security',\n  'Supports-Loading-Mode',\n  'TE',\n  'Timing-Allow-Origin',\n  'Trailer',\n  'Transfer-Encoding',\n  'Upgrade',\n  'Upgrade-Insecure-Requests',\n  'User-Agent',\n  'Vary',\n  'Via',\n  'WWW-Authenticate',\n  'X-Content-Type-Options',\n  'X-DNS-Prefetch-Control',\n  'X-Frame-Options',\n  'X-Permitted-Cross-Domain-Policies',\n  'X-Powered-By',\n  'X-Requested-With',\n  'X-XSS-Protection'\n])\n\n/** @type {Record<typeof wellknownHeaderNames[number]|Lowercase<typeof wellknownHeaderNames[number]>, string>} */\nconst headerNameLowerCasedRecord = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null)\n\n/**\n * @type {Record<Lowercase<typeof wellknownHeaderNames[number]>, Buffer>}\n */\nconst wellknownHeaderNameBuffers = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(wellknownHeaderNameBuffers, null)\n\n/**\n * @param {string} header Lowercased header\n * @returns {Buffer}\n */\nfunction getHeaderNameAsBuffer (header) {\n  let buffer = wellknownHeaderNameBuffers[header]\n\n  if (buffer === undefined) {\n    buffer = Buffer.from(header)\n  }\n\n  return buffer\n}\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = wellknownHeaderNames[i]\n  const lowerCasedKey = key.toLowerCase()\n  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =\n    lowerCasedKey\n}\n\nmodule.exports = {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord,\n  getHeaderNameAsBuffer\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GACD,MAAM,uBAA6C;IACjD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,+GAA+G,GAC/G,MAAM,6BAA6B,CAAC;AAEpC,6FAA6F;AAC7F,OAAO,cAAc,CAAC,4BAA4B;AAElD;;CAEC,GACD,MAAM,6BAA6B,CAAC;AAEpC,6FAA6F;AAC7F,OAAO,cAAc,CAAC,4BAA4B;AAElD;;;CAGC,GACD,SAAS,sBAAuB,MAAM;IACpC,IAAI,SAAS,0BAA0B,CAAC,OAAO;IAE/C,IAAI,WAAW,WAAW;QACxB,SAAS,OAAO,IAAI,CAAC;IACvB;IAEA,OAAO;AACT;AAEA,IAAK,IAAI,IAAI,GAAG,IAAI,qBAAqB,MAAM,EAAE,EAAE,EAAG;IACpD,MAAM,MAAM,oBAAoB,CAAC,EAAE;IACnC,MAAM,gBAAgB,IAAI,WAAW;IACrC,0BAA0B,CAAC,IAAI,GAAG,0BAA0B,CAAC,cAAc,GACzE;AACJ;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/tree.js"],"sourcesContent":["'use strict'\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = require('./constants')\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    /**\n     * @type {TstNode}\n     */\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @returns {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    /**\n     * @type {TstNode|null}\n     */\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @returns {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/util.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = require('./symbols')\nconst { IncomingMessage } = require('node:http')\nconst stream = require('node:stream')\nconst net = require('node:net')\nconst { stringify } = require('node:querystring')\nconst { EventEmitter: EE } = require('node:events')\nconst timers = require('../util/timers')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nconst { headerNameLowerCasedRecord } = require('./constants')\nconst { tree } = require('./tree')\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.', 2).map(v => Number(v))\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nfunction noop () {}\n\n/**\n * @param {*} body\n * @returns {*}\n */\nfunction wrapRequestBody (body) {\n  if (isStream(body)) {\n    // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n    // so that it can be dispatched again?\n    // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n    if (bodyLength(body) === 0) {\n      body\n        .on('data', function () {\n          assert(false)\n        })\n    }\n\n    if (typeof body.readableDidRead !== 'boolean') {\n      body[kBodyUsed] = false\n      EE.prototype.on.call(body, 'data', function () {\n        this[kBodyUsed] = true\n      })\n    }\n\n    return body\n  } else if (body && typeof body.pipeTo === 'function') {\n    // TODO (fix): We can't access ReadableStream internal state\n    // to determine whether or not it has been disturbed. This is just\n    // a workaround.\n    return new BodyAsyncIterable(body)\n  } else if (\n    body &&\n    typeof body !== 'string' &&\n    !ArrayBuffer.isView(body) &&\n    isIterable(body)\n  ) {\n    // TODO: Should we allow re-using iterable if !this.opts.idempotent\n    // or through some other flag?\n    return new BodyAsyncIterable(body)\n  } else {\n    return body\n  }\n}\n\n/**\n * @param {*} obj\n * @returns {obj is import('node:stream').Stream}\n */\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n/**\n * @param {*} object\n * @returns {object is Blob}\n * based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\n */\nfunction isBlobLike (object) {\n  if (object === null) {\n    return false\n  } else if (object instanceof Blob) {\n    return true\n  } else if (typeof object !== 'object') {\n    return false\n  } else {\n    const sTag = object[Symbol.toStringTag]\n\n    return (sTag === 'Blob' || sTag === 'File') && (\n      ('stream' in object && typeof object.stream === 'function') ||\n      ('arrayBuffer' in object && typeof object.arrayBuffer === 'function')\n    )\n  }\n}\n\n/**\n * @param {string} url The path to check for query strings or fragments.\n * @returns {boolean} Returns true if the path contains a query string or fragment.\n */\nfunction pathHasQueryOrFragment (url) {\n  return (\n    url.includes('?') ||\n    url.includes('#')\n  )\n}\n\n/**\n * @param {string} url The URL to add the query params to\n * @param {import('node:querystring').ParsedUrlQueryInput} queryParams The object to serialize into a URL query string\n * @returns {string} The URL with the query params added\n */\nfunction serializePathWithQuery (url, queryParams) {\n  if (pathHasQueryOrFragment(url)) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\n/**\n * @param {number|string|undefined} port\n * @returns {boolean}\n */\nfunction isValidPort (port) {\n  const value = parseInt(port, 10)\n  return (\n    value === Number(port) &&\n    value >= 0 &&\n    value <= 65535\n  )\n}\n\n/**\n * Check if the value is a valid http or https prefixed string.\n *\n * @param {string} value\n * @returns {boolean}\n */\nfunction isHttpOrHttpsPrefixed (value) {\n  return (\n    value != null &&\n    value[0] === 'h' &&\n    value[1] === 't' &&\n    value[2] === 't' &&\n    value[3] === 'p' &&\n    (\n      value[4] === ':' ||\n      (\n        value[4] === 's' &&\n        value[5] === ':'\n      )\n    )\n  )\n}\n\n/**\n * @param {string|URL|Record<string,string>} url\n * @returns {URL}\n */\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    /**\n     * @type {URL}\n     */\n    url = new URL(url)\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol || ''}//${url.hostname || ''}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin[origin.length - 1] === '/') {\n      origin = origin.slice(0, origin.length - 1)\n    }\n\n    if (path && path[0] !== '/') {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    return new URL(`${origin}${path}`)\n  }\n\n  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  return url\n}\n\n/**\n * @param {string|URL|Record<string, string>} url\n * @returns {URL}\n */\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\n/**\n * @param {string} host\n * @returns {string}\n */\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substring(1, idx)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substring(0, idx)\n}\n\n/**\n * IP addresses are not valid server names per RFC6066\n * Currently, the only server names supported are DNS hostnames\n * @param {string|null} host\n * @returns {string|null}\n */\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert(typeof host === 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\n/**\n * @function\n * @template T\n * @param {T} obj\n * @returns {T}\n */\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n/**\n * @param {*} obj\n * @returns {obj is AsyncIterable}\n */\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\n/**\n * @param {*} obj\n * @returns {obj is Iterable}\n */\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\n/**\n * @param {Blob|Buffer|import ('stream').Stream} body\n * @returns {number|null}\n */\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\n/**\n * @param {import ('stream').Stream} body\n * @returns {boolean}\n */\nfunction isDestroyed (body) {\n  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))\n}\n\n/**\n * @param {import ('stream').Stream} stream\n * @param {Error} [err]\n * @returns {void}\n */\nfunction destroy (stream, err) {\n  if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    queueMicrotask(() => {\n      stream.emit('error', err)\n    })\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\n/**\n * @param {string} val\n * @returns {number | null}\n */\nfunction parseKeepAliveTimeout (val) {\n  const m = val.match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */\nfunction headerNameToString (value) {\n  return typeof value === 'string'\n    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()\n    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */\nfunction bufferToLowerCasedHeaderName (value) {\n  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * @param {(Buffer | string)[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */\nfunction parseHeaders (headers, obj) {\n  if (obj === undefined) obj = {}\n\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headerNameToString(headers[i])\n    let val = obj[key]\n\n    if (val) {\n      if (typeof val === 'string') {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('utf8'))\n    } else {\n      const headersValue = headers[i + 1]\n      if (typeof headersValue === 'string') {\n        obj[key] = headersValue\n      } else {\n        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('utf8')) : headersValue.toString('utf8')\n      }\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if ('content-length' in obj && 'content-disposition' in obj) {\n    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')\n  }\n\n  return obj\n}\n\n/**\n * @param {Buffer[]} headers\n * @returns {string[]}\n */\nfunction parseRawHeaders (headers) {\n  const headersLength = headers.length\n  /**\n   * @type {string[]}\n   */\n  const ret = new Array(headersLength)\n\n  let hasContentLength = false\n  let contentDispositionIdx = -1\n  let key\n  let val\n  let kLen = 0\n\n  for (let n = 0; n < headersLength; n += 2) {\n    key = headers[n]\n    val = headers[n + 1]\n\n    typeof key !== 'string' && (key = key.toString())\n    typeof val !== 'string' && (val = val.toString('utf8'))\n\n    kLen = key.length\n    if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n      hasContentLength = true\n    } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n      contentDispositionIdx = n + 1\n    }\n    ret[n] = key\n    ret[n + 1] = val\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if (hasContentLength && contentDispositionIdx !== -1) {\n    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')\n  }\n\n  return ret\n}\n\n/**\n * @param {string[]} headers\n * @param {Buffer[]} headers\n */\nfunction encodeRawHeaders (headers) {\n  if (!Array.isArray(headers)) {\n    throw new TypeError('expected headers to be an array')\n  }\n  return headers.map(x => Buffer.from(x))\n}\n\n/**\n * @param {*} buffer\n * @returns {buffer is Buffer}\n */\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\n/**\n * Asserts that the handler object is a request handler.\n *\n * @param {object} handler\n * @param {string} method\n * @param {string} [upgrade]\n * @returns {asserts handler is import('../api/api-request').RequestHandler}\n */\nfunction assertRequestHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onRequestStart === 'function') {\n    // TODO (fix): More checks...\n    return\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n/**\n * A body is disturbed if it has been read from and it cannot be re-used without\n * losing state or data.\n * @param {import('node:stream').Readable} body\n * @returns {boolean}\n */\nfunction isDisturbed (body) {\n  // TODO (fix): Why is body[kBodyUsed] needed?\n  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))\n}\n\n/**\n * @typedef {object} SocketInfo\n * @property {string} [localAddress]\n * @property {number} [localPort]\n * @property {string} [remoteAddress]\n * @property {number} [remotePort]\n * @property {string} [remoteFamily]\n * @property {number} [timeout]\n * @property {number} bytesWritten\n * @property {number} bytesRead\n */\n\n/**\n * @param {import('net').Socket} socket\n * @returns {SocketInfo}\n */\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\n/**\n * @param {Iterable} iterable\n * @returns {ReadableStream}\n */\nfunction ReadableStreamFrom (iterable) {\n  // We cannot use ReadableStream.from here because it does not return a byte stream.\n\n  let iterator\n  return new ReadableStream(\n    {\n      start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      pull (controller) {\n        return iterator.next().then(({ done, value }) => {\n          if (done) {\n            queueMicrotask(() => {\n              controller.close()\n              controller.byobRequest?.respond(0)\n            })\n          } else {\n            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n            if (buf.byteLength) {\n              controller.enqueue(new Uint8Array(buf))\n            } else {\n              return this.pull(controller)\n            }\n          }\n        })\n      },\n      cancel () {\n        return iterator.return()\n      },\n      type: 'bytes'\n    }\n  )\n}\n\n/**\n * The object should be a FormData instance and contains all the required\n * methods.\n * @param {*} object\n * @returns {object is FormData}\n */\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction addAbortListener (signal, listener) {\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.once('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n * @returns {boolean}\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHeaderValue (characters) {\n  return !headerCharRegex.test(characters)\n}\n\nconst rangeHeaderRegex = /^bytes (\\d+)-(\\d+)\\/(\\d+)?$/\n\n/**\n * @typedef {object} RangeHeader\n * @property {number} start\n * @property {number | null} end\n * @property {number | null} size\n */\n\n/**\n * Parse accordingly to RFC 9110\n * @see https://www.rfc-editor.org/rfc/rfc9110#field.content-range\n * @param {string} [range]\n * @returns {RangeHeader|null}\n */\nfunction parseRangeHeader (range) {\n  if (range == null || range === '') return { start: 0, end: null, size: null }\n\n  const m = range ? range.match(rangeHeaderRegex) : null\n  return m\n    ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n      }\n    : null\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @param {string} name\n * @param {(...args: any[]) => void} listener\n * @returns {T}\n */\nfunction addListener (obj, name, listener) {\n  const listeners = (obj[kListeners] ??= [])\n  listeners.push([name, listener])\n  obj.on(name, listener)\n  return obj\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @returns {T}\n */\nfunction removeAllListeners (obj) {\n  if (obj[kListeners] != null) {\n    for (const [name, listener] of obj[kListeners]) {\n      obj.removeListener(name, listener)\n    }\n    obj[kListeners] = null\n  }\n  return obj\n}\n\n/**\n * @param {import ('../dispatcher/client')} client\n * @param {import ('../core/request')} request\n * @param {Error} err\n */\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\n/**\n * @param {WeakRef<net.Socket>} socketWeakRef\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n * @returns {() => void}\n */\nconst setupConnectTimeout = process.platform === 'win32'\n  ? (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      let s2 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts))\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n        clearImmediate(s2)\n      }\n    }\n  : (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n          onConnectTimeout(socketWeakRef.deref(), opts)\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n      }\n    }\n\n/**\n * @param {net.Socket} socket\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n */\nfunction onConnectTimeout (socket, opts) {\n  // The socket could be already garbage collected\n  if (socket == null) {\n    return\n  }\n\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`\n  } else {\n    message += ` (attempted address: ${opts.hostname}:${opts.port},`\n  }\n\n  message += ` timeout: ${opts.timeout}ms)`\n\n  destroy(socket, new ConnectTimeoutError(message))\n}\n\n/**\n * @param {string} urlString\n * @returns {string}\n */\nfunction getProtocolFromUrlString (urlString) {\n  if (\n    urlString[0] === 'h' &&\n    urlString[1] === 't' &&\n    urlString[2] === 't' &&\n    urlString[3] === 'p'\n  ) {\n    switch (urlString[4]) {\n      case ':':\n        return 'http:'\n      case 's':\n        if (urlString[5] === ':') {\n          return 'https:'\n        }\n    }\n  }\n  // fallback if none of the usual suspects\n  return urlString.slice(0, urlString.indexOf(':') + 1)\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nconst normalizedMethodRecordsBase = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\nconst normalizedMethodRecords = {\n  ...normalizedMethodRecordsBase,\n  patch: 'patch',\n  PATCH: 'PATCH'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null)\nObject.setPrototypeOf(normalizedMethodRecords, null)\n\nmodule.exports = {\n  kEnumerableProperty,\n  isDisturbed,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  headerNameToString,\n  bufferToLowerCasedHeaderName,\n  addListener,\n  removeAllListeners,\n  errorRequest,\n  parseRawHeaders,\n  encodeRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  assertRequestHandler,\n  getSocketInfo,\n  isFormDataLike,\n  pathHasQueryOrFragment,\n  serializePathWithQuery,\n  addAbortListener,\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isTokenCharCode,\n  parseRangeHeader,\n  normalizedMethodRecordsBase,\n  normalizedMethodRecords,\n  isValidPort,\n  isHttpOrHttpsPrefixed,\n  nodeMajor,\n  nodeMinor,\n  safeHTTPMethods: Object.freeze(['GET', 'HEAD', 'OPTIONS', 'TRACE']),\n  wrapRequestBody,\n  setupConnectTimeout,\n  getProtocolFromUrlString\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1488, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/diagnostics.js"],"sourcesContent":["'use strict'\n\nconst diagnosticsChannel = require('node:diagnostics_channel')\nconst util = require('node:util')\n\nconst undiciDebugLog = util.debuglog('undici')\nconst fetchDebuglog = util.debuglog('fetch')\nconst websocketDebuglog = util.debuglog('websocket')\n\nconst channels = {\n  // Client\n  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n  connected: diagnosticsChannel.channel('undici:client:connected'),\n  connectError: diagnosticsChannel.channel('undici:client:connectError'),\n  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n  // Request\n  create: diagnosticsChannel.channel('undici:request:create'),\n  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n  bodyChunkSent: diagnosticsChannel.channel('undici:request:bodyChunkSent'),\n  bodyChunkReceived: diagnosticsChannel.channel('undici:request:bodyChunkReceived'),\n  headers: diagnosticsChannel.channel('undici:request:headers'),\n  trailers: diagnosticsChannel.channel('undici:request:trailers'),\n  error: diagnosticsChannel.channel('undici:request:error'),\n  // WebSocket\n  open: diagnosticsChannel.channel('undici:websocket:open'),\n  close: diagnosticsChannel.channel('undici:websocket:close'),\n  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n  ping: diagnosticsChannel.channel('undici:websocket:ping'),\n  pong: diagnosticsChannel.channel('undici:websocket:pong')\n}\n\nlet isTrackingClientEvents = false\n\nfunction trackClientEvents (debugLog = undiciDebugLog) {\n  if (isTrackingClientEvents) {\n    return\n  }\n\n  isTrackingClientEvents = true\n\n  diagnosticsChannel.subscribe('undici:client:beforeConnect',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connecting to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connected',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connected to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connectError',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host },\n        error\n      } = evt\n      debugLog(\n        'connection to %s%s using %s%s errored - %s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version,\n        error.message\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:sendHeaders',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('sending request to %s %s%s', method, origin, path)\n    })\n}\n\nlet isTrackingRequestEvents = false\n\nfunction trackRequestEvents (debugLog = undiciDebugLog) {\n  if (isTrackingRequestEvents) {\n    return\n  }\n\n  isTrackingRequestEvents = true\n\n  diagnosticsChannel.subscribe('undici:request:headers',\n    evt => {\n      const {\n        request: { method, path, origin },\n        response: { statusCode }\n      } = evt\n      debugLog(\n        'received response to %s %s%s - HTTP %d',\n        method,\n        origin,\n        path,\n        statusCode\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:request:trailers',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('trailers received from %s %s%s', method, origin, path)\n    })\n\n  diagnosticsChannel.subscribe('undici:request:error',\n    evt => {\n      const {\n        request: { method, path, origin },\n        error\n      } = evt\n      debugLog(\n        'request to %s %s%s errored - %s',\n        method,\n        origin,\n        path,\n        error.message\n      )\n    })\n}\n\nlet isTrackingWebSocketEvents = false\n\nfunction trackWebSocketEvents (debugLog = websocketDebuglog) {\n  if (isTrackingWebSocketEvents) {\n    return\n  }\n\n  isTrackingWebSocketEvents = true\n\n  diagnosticsChannel.subscribe('undici:websocket:open',\n    evt => {\n      const {\n        address: { address, port }\n      } = evt\n      debugLog('connection opened %s%s', address, port ? `:${port}` : '')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:close',\n    evt => {\n      const { websocket, code, reason } = evt\n      debugLog(\n        'closed connection to %s - %s %s',\n        websocket.url,\n        code,\n        reason\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:socket_error',\n    err => {\n      debugLog('connection errored - %s', err.message)\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:ping',\n    evt => {\n      debugLog('ping received')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:pong',\n    evt => {\n      debugLog('pong received')\n    })\n}\n\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n  trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n  trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n}\n\nif (websocketDebuglog.enabled) {\n  trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog)\n  trackWebSocketEvents(websocketDebuglog)\n}\n\nmodule.exports = {\n  channels\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/request.js"],"sourcesContent":["'use strict'\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = require('./errors')\nconst assert = require('node:assert')\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  serializePathWithQuery,\n  assertRequestHandler,\n  getServerName,\n  normalizedMethodRecords,\n  getProtocolFromUrlString\n} = require('./util')\nconst { channels } = require('./diagnostics.js')\nconst { headerNameLowerCasedRecord } = require('./constants')\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    expectContinue,\n    servername,\n    throwOnError,\n    maxRedirections\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    if (throwOnError != null) {\n      throw new InvalidArgumentError('invalid throwOnError')\n    }\n\n    if (maxRedirections != null && maxRedirections !== 0) {\n      throw new InvalidArgumentError('maxRedirections is not supported, use the redirect interceptor')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? serializePathWithQuery(path, query) : path\n\n    // TODO: shall we maybe standardize it to an URL object?\n    this.origin = origin\n\n    this.protocol = getProtocolFromUrlString(origin)\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking ?? this.method !== 'HEAD'\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    assertRequestHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host) || null\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (channels.bodyChunkSent.hasSubscribers) {\n      channels.bodyChunkSent.publish({ request: this, chunk })\n    }\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.bodyChunkReceived.hasSubscribers) {\n      channels.bodyChunkReceived.publish({ request: this, chunk })\n    }\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1926, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('node:net')\nconst assert = require('node:assert')\nconst util = require('./util')\nconst { InvalidArgumentError } = require('./errors')\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nconst SessionCache = class WeakSessionCache {\n  constructor (maxCachedSessions) {\n    this._maxCachedSessions = maxCachedSessions\n    this._sessionCache = new Map()\n    this._sessionRegistry = new FinalizationRegistry((key) => {\n      if (this._sessionCache.size < this._maxCachedSessions) {\n        return\n      }\n\n      const ref = this._sessionCache.get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this._sessionCache.delete(key)\n      }\n    })\n  }\n\n  get (sessionKey) {\n    const ref = this._sessionCache.get(sessionKey)\n    return ref ? ref.deref() : null\n  }\n\n  set (sessionKey, session) {\n    if (this._maxCachedSessions === 0) {\n      return\n    }\n\n    this._sessionCache.set(sessionKey, new WeakRef(session))\n    this._sessionRegistry.register(session, sessionKey)\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('node:tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      assert(sessionKey)\n\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      port = port || 443\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n\n      port = port || 80\n\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port })\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nmodule.exports = buildConnector\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,EAAE,oBAAoB,EAAE;AAE9B,IAAI,IAAI,6DAA6D;;AAErE,mDAAmD;AACnD,wDAAwD;AACxD,uDAAuD;AACvD,qBAAqB;AAErB,MAAM,eAAe,MAAM;IACzB,YAAa,iBAAiB,CAAE;QAC9B,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,aAAa,GAAG,IAAI;QACzB,IAAI,CAAC,gBAAgB,GAAG,IAAI,qBAAqB,CAAC;YAChD,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE;gBACrD;YACF;YAEA,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;YACnC,IAAI,QAAQ,aAAa,IAAI,KAAK,OAAO,WAAW;gBAClD,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;YAC5B;QACF;IACF;IAEA,IAAK,UAAU,EAAE;QACf,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;QACnC,OAAO,MAAM,IAAI,KAAK,KAAK;IAC7B;IAEA,IAAK,UAAU,EAAE,OAAO,EAAE;QACxB,IAAI,IAAI,CAAC,kBAAkB,KAAK,GAAG;YACjC;QACF;QAEA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,YAAY,IAAI,QAAQ;QAC/C,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,SAAS;IAC1C;AACF;AAEA,SAAS,eAAgB,EAAE,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,aAAa,EAAE,GAAG,MAAM;IAC3G,IAAI,qBAAqB,QAAQ,CAAC,CAAC,OAAO,SAAS,CAAC,sBAAsB,oBAAoB,CAAC,GAAG;QAChG,MAAM,IAAI,qBAAqB;IACjC;IAEA,MAAM,UAAU;QAAE,MAAM;QAAY,GAAG,IAAI;IAAC;IAC5C,MAAM,eAAe,IAAI,aAAa,qBAAqB,OAAO,MAAM;IACxE,UAAU,WAAW,OAAO,OAAO;IACnC,UAAU,WAAW,OAAO,UAAU;IACtC,OAAO,SAAS,QAAS,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,EAAE,QAAQ;QACzG,IAAI;QACJ,IAAI,aAAa,UAAU;YACzB,IAAI,CAAC,KAAK;gBACR;YACF;YACA,aAAa,cAAc,QAAQ,UAAU,IAAI,KAAK,aAAa,CAAC,SAAS;YAE7E,MAAM,aAAa,cAAc;YACjC,OAAO;YAEP,MAAM,UAAU,iBAAiB,aAAa,GAAG,CAAC,eAAe;YAEjE,OAAO,QAAQ;YAEf,SAAS,IAAI,OAAO,CAAC;gBACnB,eAAe;gBACf,GAAG,OAAO;gBACV;gBACA;gBACA;gBACA,eAAe,UAAU;oBAAC;oBAAY;iBAAK,GAAG;oBAAC;iBAAW;gBAC1D,QAAQ;gBACR;gBACA,MAAM;YACR;YAEA,OACG,EAAE,CAAC,WAAW,SAAU,OAAO;gBAC9B,6EAA6E;gBAC7E,aAAa,GAAG,CAAC,YAAY;YAC/B;QACJ,OAAO;YACL,OAAO,CAAC,YAAY;YAEpB,OAAO,QAAQ;YAEf,SAAS,IAAI,OAAO,CAAC;gBACnB,eAAe,KAAK;gBACpB,GAAG,OAAO;gBACV;gBACA;gBACA,MAAM;YACR;QACF;QAEA,6GAA6G;QAC7G,IAAI,QAAQ,SAAS,IAAI,QAAQ,QAAQ,SAAS,EAAE;YAClD,MAAM,wBAAwB,QAAQ,qBAAqB,KAAK,YAAY,OAAO,QAAQ,qBAAqB;YAChH,OAAO,YAAY,CAAC,MAAM;QAC5B;QAEA,MAAM,sBAAsB,KAAK,mBAAmB,CAAC,IAAI,QAAQ,SAAS;YAAE;YAAS;YAAU;QAAK;QAEpG,OACG,UAAU,CAAC,MACX,IAAI,CAAC,aAAa,WAAW,kBAAkB,WAAW;YACzD,eAAe;YAEf,IAAI,UAAU;gBACZ,MAAM,KAAK;gBACX,WAAW;gBACX,GAAG,MAAM,IAAI;YACf;QACF,GACC,EAAE,CAAC,SAAS,SAAU,GAAG;YACxB,eAAe;YAEf,IAAI,UAAU;gBACZ,MAAM,KAAK;gBACX,WAAW;gBACX,GAAG;YACL;QACF;QAEF,OAAO;IACT;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/util/timers.js"],"sourcesContent":["'use strict'\n\n/**\n * This module offers an optimized timer implementation designed for scenarios\n * where high precision is not critical.\n *\n * The timer achieves faster performance by using a low-resolution approach,\n * with an accuracy target of within 500ms. This makes it particularly useful\n * for timers with delays of 1 second or more, where exact timing is less\n * crucial.\n *\n * It's important to note that Node.js timers are inherently imprecise, as\n * delays can occur due to the event loop being blocked by other operations.\n * Consequently, timers may trigger later than their scheduled time.\n */\n\n/**\n * The fastNow variable contains the internal fast timer clock value.\n *\n * @type {number}\n */\nlet fastNow = 0\n\n/**\n * RESOLUTION_MS represents the target resolution time in milliseconds.\n *\n * @type {number}\n * @default 1000\n */\nconst RESOLUTION_MS = 1e3\n\n/**\n * TICK_MS defines the desired interval in milliseconds between each tick.\n * The target value is set to half the resolution time, minus 1 ms, to account\n * for potential event loop overhead.\n *\n * @type {number}\n * @default 499\n */\nconst TICK_MS = (RESOLUTION_MS >> 1) - 1\n\n/**\n * fastNowTimeout is a Node.js timer used to manage and process\n * the FastTimers stored in the `fastTimers` array.\n *\n * @type {NodeJS.Timeout}\n */\nlet fastNowTimeout\n\n/**\n * The kFastTimer symbol is used to identify FastTimer instances.\n *\n * @type {Symbol}\n */\nconst kFastTimer = Symbol('kFastTimer')\n\n/**\n * The fastTimers array contains all active FastTimers.\n *\n * @type {FastTimer[]}\n */\nconst fastTimers = []\n\n/**\n * These constants represent the various states of a FastTimer.\n */\n\n/**\n * The `NOT_IN_LIST` constant indicates that the FastTimer is not included\n * in the `fastTimers` array. Timers with this status will not be processed\n * during the next tick by the `onTick` function.\n *\n * A FastTimer can be re-added to the `fastTimers` array by invoking the\n * `refresh` method on the FastTimer instance.\n *\n * @type {-2}\n */\nconst NOT_IN_LIST = -2\n\n/**\n * The `TO_BE_CLEARED` constant indicates that the FastTimer is scheduled\n * for removal from the `fastTimers` array. A FastTimer in this state will\n * be removed in the next tick by the `onTick` function and will no longer\n * be processed.\n *\n * This status is also set when the `clear` method is called on the FastTimer instance.\n *\n * @type {-1}\n */\nconst TO_BE_CLEARED = -1\n\n/**\n * The `PENDING` constant signifies that the FastTimer is awaiting processing\n * in the next tick by the `onTick` function. Timers with this status will have\n * their `_idleStart` value set and their status updated to `ACTIVE` in the next tick.\n *\n * @type {0}\n */\nconst PENDING = 0\n\n/**\n * The `ACTIVE` constant indicates that the FastTimer is active and waiting\n * for its timer to expire. During the next tick, the `onTick` function will\n * check if the timer has expired, and if so, it will execute the associated callback.\n *\n * @type {1}\n */\nconst ACTIVE = 1\n\n/**\n * The onTick function processes the fastTimers array.\n *\n * @returns {void}\n */\nfunction onTick () {\n  /**\n   * Increment the fastNow value by the TICK_MS value, despite the actual time\n   * that has passed since the last tick. This approach ensures independence\n   * from the system clock and delays caused by a blocked event loop.\n   *\n   * @type {number}\n   */\n  fastNow += TICK_MS\n\n  /**\n   * The `idx` variable is used to iterate over the `fastTimers` array.\n   * Expired timers are removed by replacing them with the last element in the array.\n   * Consequently, `idx` is only incremented when the current element is not removed.\n   *\n   * @type {number}\n   */\n  let idx = 0\n\n  /**\n   * The len variable will contain the length of the fastTimers array\n   * and will be decremented when a FastTimer should be removed from the\n   * fastTimers array.\n   *\n   * @type {number}\n   */\n  let len = fastTimers.length\n\n  while (idx < len) {\n    /**\n     * @type {FastTimer}\n     */\n    const timer = fastTimers[idx]\n\n    // If the timer is in the ACTIVE state and the timer has expired, it will\n    // be processed in the next tick.\n    if (timer._state === PENDING) {\n      // Set the _idleStart value to the fastNow value minus the TICK_MS value\n      // to account for the time the timer was in the PENDING state.\n      timer._idleStart = fastNow - TICK_MS\n      timer._state = ACTIVE\n    } else if (\n      timer._state === ACTIVE &&\n      fastNow >= timer._idleStart + timer._idleTimeout\n    ) {\n      timer._state = TO_BE_CLEARED\n      timer._idleStart = -1\n      timer._onTimeout(timer._timerArg)\n    }\n\n    if (timer._state === TO_BE_CLEARED) {\n      timer._state = NOT_IN_LIST\n\n      // Move the last element to the current index and decrement len if it is\n      // not the only element in the array.\n      if (--len !== 0) {\n        fastTimers[idx] = fastTimers[len]\n      }\n    } else {\n      ++idx\n    }\n  }\n\n  // Set the length of the fastTimers array to the new length and thus\n  // removing the excess FastTimers elements from the array.\n  fastTimers.length = len\n\n  // If there are still active FastTimers in the array, refresh the Timer.\n  // If there are no active FastTimers, the timer will be refreshed again\n  // when a new FastTimer is instantiated.\n  if (fastTimers.length !== 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  // If the fastNowTimeout is already set and the Timer has the refresh()-\n  // method available, call it to refresh the timer.\n  // Some timer objects returned by setTimeout may not have a .refresh()\n  // method (e.g. mocked timers in tests).\n  if (fastNowTimeout?.refresh) {\n    fastNowTimeout.refresh()\n    // fastNowTimeout is not instantiated yet or refresh is not availabe,\n    // create a new Timer.\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTick, TICK_MS)\n    // If the Timer has an unref method, call it to allow the process to exit,\n    // if there are no other active handles. When using fake timers or mocked\n    // environments (like Jest), .unref() may not be defined,\n    fastNowTimeout?.unref()\n  }\n}\n\n/**\n * The `FastTimer` class is a data structure designed to store and manage\n * timer information.\n */\nclass FastTimer {\n  [kFastTimer] = true\n\n  /**\n   * The state of the timer, which can be one of the following:\n   * - NOT_IN_LIST (-2)\n   * - TO_BE_CLEARED (-1)\n   * - PENDING (0)\n   * - ACTIVE (1)\n   *\n   * @type {-2|-1|0|1}\n   * @private\n   */\n  _state = NOT_IN_LIST\n\n  /**\n   * The number of milliseconds to wait before calling the callback.\n   *\n   * @type {number}\n   * @private\n   */\n  _idleTimeout = -1\n\n  /**\n   * The time in milliseconds when the timer was started. This value is used to\n   * calculate when the timer should expire.\n   *\n   * @type {number}\n   * @default -1\n   * @private\n   */\n  _idleStart = -1\n\n  /**\n   * The function to be executed when the timer expires.\n   * @type {Function}\n   * @private\n   */\n  _onTimeout\n\n  /**\n   * The argument to be passed to the callback when the timer expires.\n   *\n   * @type {*}\n   * @private\n   */\n  _timerArg\n\n  /**\n   * @constructor\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should wait\n   * before the specified function or code is executed.\n   * @param {*} arg\n   */\n  constructor (callback, delay, arg) {\n    this._onTimeout = callback\n    this._idleTimeout = delay\n    this._timerArg = arg\n\n    this.refresh()\n  }\n\n  /**\n   * Sets the timer's start time to the current time, and reschedules the timer\n   * to call its callback at the previously specified duration adjusted to the\n   * current time.\n   * Using this on a timer that has already called its callback will reactivate\n   * the timer.\n   *\n   * @returns {void}\n   */\n  refresh () {\n    // In the special case that the timer is not in the list of active timers,\n    // add it back to the array to be processed in the next tick by the onTick\n    // function.\n    if (this._state === NOT_IN_LIST) {\n      fastTimers.push(this)\n    }\n\n    // If the timer is the only active timer, refresh the fastNowTimeout for\n    // better resolution.\n    if (!fastNowTimeout || fastTimers.length === 1) {\n      refreshTimeout()\n    }\n\n    // Setting the state to PENDING will cause the timer to be reset in the\n    // next tick by the onTick function.\n    this._state = PENDING\n  }\n\n  /**\n   * The `clear` method cancels the timer, preventing it from executing.\n   *\n   * @returns {void}\n   * @private\n   */\n  clear () {\n    // Set the state to TO_BE_CLEARED to mark the timer for removal in the next\n    // tick by the onTick function.\n    this._state = TO_BE_CLEARED\n\n    // Reset the _idleStart value to -1 to indicate that the timer is no longer\n    // active.\n    this._idleStart = -1\n  }\n}\n\n/**\n * This module exports a setTimeout and clearTimeout function that can be\n * used as a drop-in replacement for the native functions.\n */\nmodule.exports = {\n  /**\n   * The setTimeout() method sets a timer which executes a function once the\n   * timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {NodeJS.Timeout|FastTimer}\n   */\n  setTimeout (callback, delay, arg) {\n    // If the delay is less than or equal to the RESOLUTION_MS value return a\n    // native Node.js Timer instance.\n    return delay <= RESOLUTION_MS\n      ? setTimeout(callback, delay, arg)\n      : new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated Timer previously created\n   * by calling setTimeout.\n   *\n   * @param {NodeJS.Timeout|FastTimer} timeout\n   */\n  clearTimeout (timeout) {\n    // If the timeout is a FastTimer, call its own clear method.\n    if (timeout[kFastTimer]) {\n      /**\n       * @type {FastTimer}\n       */\n      timeout.clear()\n      // Otherwise it is an instance of a native NodeJS.Timeout, so call the\n      // Node.js native clearTimeout function.\n    } else {\n      clearTimeout(timeout)\n    }\n  },\n  /**\n   * The setFastTimeout() method sets a fastTimer which executes a function once\n   * the timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {FastTimer}\n   */\n  setFastTimeout (callback, delay, arg) {\n    return new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated FastTimer previously\n   * created by calling setFastTimeout.\n   *\n   * @param {FastTimer} timeout\n   */\n  clearFastTimeout (timeout) {\n    timeout.clear()\n  },\n  /**\n   * The now method returns the value of the internal fast timer clock.\n   *\n   * @returns {number}\n   */\n  now () {\n    return fastNow\n  },\n  /**\n   * Trigger the onTick function to process the fastTimers array.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   * @param {number} [delay=0] The delay in milliseconds to add to the now value.\n   */\n  tick (delay = 0) {\n    fastNow += delay - RESOLUTION_MS + 1\n    onTick()\n    onTick()\n  },\n  /**\n   * Reset FastTimers.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  reset () {\n    fastNow = 0\n    fastTimers.length = 0\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = null\n  },\n  /**\n   * Exporting for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  kFastTimer\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/util/stats.js"],"sourcesContent":["'use strict'\n\nconst {\n  kConnected,\n  kPending,\n  kRunning,\n  kSize,\n  kFree,\n  kQueued\n} = require('../core/symbols')\n\nclass ClientStats {\n  constructor (client) {\n    this.connected = client[kConnected]\n    this.pending = client[kPending]\n    this.running = client[kRunning]\n    this.size = client[kSize]\n  }\n}\n\nclass PoolStats {\n  constructor (pool) {\n    this.connected = pool[kConnected]\n    this.free = pool[kFree]\n    this.pending = pool[kPending]\n    this.queued = pool[kQueued]\n    this.running = pool[kRunning]\n    this.size = pool[kSize]\n  }\n}\n\nmodule.exports = { ClientStats, PoolStats }\n"],"names":[],"mappings":"AAEA,MAAM,EACJ,UAAU,EACV,QAAQ,EACR,QAAQ,EACR,KAAK,EACL,KAAK,EACL,OAAO,EACR;AAED,MAAM;IACJ,YAAa,MAAM,CAAE;QACnB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,WAAW;QACnC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,SAAS;QAC/B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,SAAS;QAC/B,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM;IAC3B;AACF;AAEA,MAAM;IACJ,YAAa,IAAI,CAAE;QACjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM;QACvB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS;QAC7B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS;QAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM;IACzB;AACF;AAEA,OAAO,OAAO,GAAG;IAAE;IAAa;AAAU","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2426, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/util/promise.js"],"sourcesContent":["'use strict'\n\n/**\n * @template {*} T\n * @typedef {Object} DeferredPromise\n * @property {Promise<T>} promise\n * @property {(value?: T) => void} resolve\n * @property {(reason?: any) => void} reject\n */\n\n/**\n * @template {*} T\n * @returns {DeferredPromise<T>} An object containing a promise and its resolve/reject methods.\n */\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nmodule.exports = {\n  createDeferredPromise\n}\n"],"names":[],"mappings":"AAEA;;;;;;CAMC,GAED;;;CAGC,GACD,SAAS;IACP,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;QACpC,MAAM;QACN,MAAM;IACR;IAEA,OAAO;QAAE;QAAS,SAAS;QAAK,QAAQ;IAAI;AAC9C;AAEA,OAAO,OAAO,GAAG;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2455, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/util/cache.js"],"sourcesContent":["'use strict'\n\nconst {\n  safeHTTPMethods,\n  pathHasQueryOrFragment\n} = require('../core/util')\n\nconst { serializePathWithQuery } = require('../core/util')\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchOptions} opts\n */\nfunction makeCacheKey (opts) {\n  if (!opts.origin) {\n    throw new Error('opts.origin is undefined')\n  }\n\n  let fullPath = opts.path || '/'\n\n  if (opts.query && !pathHasQueryOrFragment(opts.path)) {\n    fullPath = serializePathWithQuery(fullPath, opts.query)\n  }\n\n  return {\n    origin: opts.origin.toString(),\n    method: opts.method,\n    path: fullPath,\n    headers: opts.headers\n  }\n}\n\n/**\n * @param {Record<string, string[] | string>}\n * @returns {Record<string, string[] | string>}\n */\nfunction normalizeHeaders (opts) {\n  let headers\n  if (opts.headers == null) {\n    headers = {}\n  } else if (typeof opts.headers[Symbol.iterator] === 'function') {\n    headers = {}\n    for (const x of opts.headers) {\n      if (!Array.isArray(x)) {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      const [key, val] = x\n      if (typeof key !== 'string' || typeof val !== 'string') {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      headers[key.toLowerCase()] = val\n    }\n  } else if (typeof opts.headers === 'object') {\n    headers = {}\n\n    for (const key of Object.keys(opts.headers)) {\n      headers[key.toLowerCase()] = opts.headers[key]\n    }\n  } else {\n    throw new Error('opts.headers is not an object')\n  }\n\n  return headers\n}\n\n/**\n * @param {any} key\n */\nfunction assertCacheKey (key) {\n  if (typeof key !== 'object') {\n    throw new TypeError(`expected key to be object, got ${typeof key}`)\n  }\n\n  for (const property of ['origin', 'method', 'path']) {\n    if (typeof key[property] !== 'string') {\n      throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`)\n    }\n  }\n\n  if (key.headers !== undefined && typeof key.headers !== 'object') {\n    throw new TypeError(`expected headers to be object, got ${typeof key}`)\n  }\n}\n\n/**\n * @param {any} value\n */\nfunction assertCacheValue (value) {\n  if (typeof value !== 'object') {\n    throw new TypeError(`expected value to be object, got ${typeof value}`)\n  }\n\n  for (const property of ['statusCode', 'cachedAt', 'staleAt', 'deleteAt']) {\n    if (typeof value[property] !== 'number') {\n      throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`)\n    }\n  }\n\n  if (typeof value.statusMessage !== 'string') {\n    throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`)\n  }\n\n  if (value.headers != null && typeof value.headers !== 'object') {\n    throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`)\n  }\n\n  if (value.vary !== undefined && typeof value.vary !== 'object') {\n    throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`)\n  }\n\n  if (value.etag !== undefined && typeof value.etag !== 'string') {\n    throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-cache-control\n * @see https://www.iana.org/assignments/http-cache-directives/http-cache-directives.xhtml\n\n * @param {string | string[]} header\n * @returns {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n */\nfunction parseCacheControlHeader (header) {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n   */\n  const output = {}\n\n  let directives\n  if (Array.isArray(header)) {\n    directives = []\n\n    for (const directive of header) {\n      directives.push(...directive.split(','))\n    }\n  } else {\n    directives = header.split(',')\n  }\n\n  for (let i = 0; i < directives.length; i++) {\n    const directive = directives[i].toLowerCase()\n    const keyValueDelimiter = directive.indexOf('=')\n\n    let key\n    let value\n    if (keyValueDelimiter !== -1) {\n      key = directive.substring(0, keyValueDelimiter).trimStart()\n      value = directive.substring(keyValueDelimiter + 1)\n    } else {\n      key = directive.trim()\n    }\n\n    switch (key) {\n      case 'min-fresh':\n      case 'max-stale':\n      case 'max-age':\n      case 's-maxage':\n      case 'stale-while-revalidate':\n      case 'stale-if-error': {\n        if (value === undefined || value[0] === ' ') {\n          continue\n        }\n\n        if (\n          value.length >= 2 &&\n          value[0] === '\"' &&\n          value[value.length - 1] === '\"'\n        ) {\n          value = value.substring(1, value.length - 1)\n        }\n\n        const parsedValue = parseInt(value, 10)\n        // eslint-disable-next-line no-self-compare\n        if (parsedValue !== parsedValue) {\n          continue\n        }\n\n        if (key === 'max-age' && key in output && output[key] >= parsedValue) {\n          continue\n        }\n\n        output[key] = parsedValue\n\n        break\n      }\n      case 'private':\n      case 'no-cache': {\n        if (value) {\n          // The private and no-cache directives can be unqualified (aka just\n          //  `private` or `no-cache`) or qualified (w/ a value). When they're\n          //  qualified, it's a list of headers like `no-cache=header1`,\n          //  `no-cache=\"header1\"`, or `no-cache=\"header1, header2\"`\n          // If we're given multiple headers, the comma messes us up since\n          //  we split the full header by commas. So, let's loop through the\n          //  remaining parts in front of us until we find one that ends in a\n          //  quote. We can then just splice all of the parts in between the\n          //  starting quote and the ending quote out of the directives array\n          //  and continue parsing like normal.\n          // https://www.rfc-editor.org/rfc/rfc9111.html#name-no-cache-2\n          if (value[0] === '\"') {\n            // Something like `no-cache=\"some-header\"` OR `no-cache=\"some-header, another-header\"`.\n\n            // Add the first header on and cut off the leading quote\n            const headers = [value.substring(1)]\n\n            let foundEndingQuote = value[value.length - 1] === '\"'\n            if (!foundEndingQuote) {\n              // Something like `no-cache=\"some-header, another-header\"`\n              //  This can still be something invalid, e.g. `no-cache=\"some-header, ...`\n              for (let j = i + 1; j < directives.length; j++) {\n                const nextPart = directives[j]\n                const nextPartLength = nextPart.length\n\n                headers.push(nextPart.trim())\n\n                if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '\"') {\n                  foundEndingQuote = true\n                  break\n                }\n              }\n            }\n\n            if (foundEndingQuote) {\n              let lastHeader = headers[headers.length - 1]\n              if (lastHeader[lastHeader.length - 1] === '\"') {\n                lastHeader = lastHeader.substring(0, lastHeader.length - 1)\n                headers[headers.length - 1] = lastHeader\n              }\n\n              if (key in output) {\n                output[key] = output[key].concat(headers)\n              } else {\n                output[key] = headers\n              }\n            }\n          } else {\n            // Something like `no-cache=\"some-header\"`\n            if (key in output) {\n              output[key] = output[key].concat(value)\n            } else {\n              output[key] = [value]\n            }\n          }\n\n          break\n        }\n      }\n      // eslint-disable-next-line no-fallthrough\n      case 'public':\n      case 'no-store':\n      case 'must-revalidate':\n      case 'proxy-revalidate':\n      case 'immutable':\n      case 'no-transform':\n      case 'must-understand':\n      case 'only-if-cached':\n        if (value) {\n          // These are qualified (something like `public=...`) when they aren't\n          //  allowed to be, skip\n          continue\n        }\n\n        output[key] = true\n        break\n      default:\n        // Ignore unknown directives as per https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.3-1\n        continue\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string | string[]} varyHeader Vary header from the server\n * @param {Record<string, string | string[]>} headers Request headers\n * @returns {Record<string, string | string[]>}\n */\nfunction parseVaryHeader (varyHeader, headers) {\n  if (typeof varyHeader === 'string' && varyHeader.includes('*')) {\n    return headers\n  }\n\n  const output = /** @type {Record<string, string | string[] | null>} */ ({})\n\n  const varyingHeaders = typeof varyHeader === 'string'\n    ? varyHeader.split(',')\n    : varyHeader\n\n  for (const header of varyingHeaders) {\n    const trimmedHeader = header.trim().toLowerCase()\n\n    output[trimmedHeader] = headers[trimmedHeader] ?? null\n  }\n\n  return output\n}\n\n/**\n * Note: this deviates from the spec a little. Empty etags (\"\", W/\"\") are valid,\n *  however, including them in cached resposnes serves little to no purpose.\n *\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-etag\n *\n * @param {string} etag\n * @returns {boolean}\n */\nfunction isEtagUsable (etag) {\n  if (etag.length <= 2) {\n    // Shortest an etag can be is two chars (just \"\"). This is where we deviate\n    //  from the spec requiring a min of 3 chars however\n    return false\n  }\n\n  if (etag[0] === '\"' && etag[etag.length - 1] === '\"') {\n    // ETag: \"\"asd123\"\" or ETag: \"W/\"asd123\"\", kinda undefined behavior in the\n    //  spec. Some servers will accept these while others don't.\n    // ETag: \"asd123\"\n    return !(etag[1] === '\"' || etag.startsWith('\"W/'))\n  }\n\n  if (etag.startsWith('W/\"') && etag[etag.length - 1] === '\"') {\n    // ETag: W/\"\", also where we deviate from the spec & require a min of 3\n    //  chars\n    // ETag: for W/\"\", W/\"asd123\"\n    return etag.length !== 4\n  }\n\n  // Anything else\n  return false\n}\n\n/**\n * @param {unknown} store\n * @returns {asserts store is import('../../types/cache-interceptor.d.ts').default.CacheStore}\n */\nfunction assertCacheStore (store, name = 'CacheStore') {\n  if (typeof store !== 'object' || store === null) {\n    throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? 'null' : typeof store}`)\n  }\n\n  for (const fn of ['get', 'createWriteStream', 'delete']) {\n    if (typeof store[fn] !== 'function') {\n      throw new TypeError(`${name} needs to have a \\`${fn}()\\` function`)\n    }\n  }\n}\n/**\n * @param {unknown} methods\n * @returns {asserts methods is import('../../types/cache-interceptor.d.ts').default.CacheMethods[]}\n */\nfunction assertCacheMethods (methods, name = 'CacheMethods') {\n  if (!Array.isArray(methods)) {\n    throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? 'null' : typeof methods}`)\n  }\n\n  if (methods.length === 0) {\n    throw new TypeError(`${name} needs to have at least one method`)\n  }\n\n  for (const method of methods) {\n    if (!safeHTTPMethods.includes(method)) {\n      throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(', ')}, got ${method}`)\n    }\n  }\n}\n\nmodule.exports = {\n  makeCacheKey,\n  normalizeHeaders,\n  assertCacheKey,\n  assertCacheValue,\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable,\n  assertCacheMethods,\n  assertCacheStore\n}\n"],"names":[],"mappings":"AAEA,MAAM,EACJ,eAAe,EACf,sBAAsB,EACvB;AAED,MAAM,EAAE,sBAAsB,EAAE;AAEhC;;CAEC,GACD,SAAS,aAAc,IAAI;IACzB,IAAI,CAAC,KAAK,MAAM,EAAE;QAChB,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,WAAW,KAAK,IAAI,IAAI;IAE5B,IAAI,KAAK,KAAK,IAAI,CAAC,uBAAuB,KAAK,IAAI,GAAG;QACpD,WAAW,uBAAuB,UAAU,KAAK,KAAK;IACxD;IAEA,OAAO;QACL,QAAQ,KAAK,MAAM,CAAC,QAAQ;QAC5B,QAAQ,KAAK,MAAM;QACnB,MAAM;QACN,SAAS,KAAK,OAAO;IACvB;AACF;AAEA;;;CAGC,GACD,SAAS,iBAAkB,IAAI;IAC7B,IAAI;IACJ,IAAI,KAAK,OAAO,IAAI,MAAM;QACxB,UAAU,CAAC;IACb,OAAO,IAAI,OAAO,KAAK,OAAO,CAAC,OAAO,QAAQ,CAAC,KAAK,YAAY;QAC9D,UAAU,CAAC;QACX,KAAK,MAAM,KAAK,KAAK,OAAO,CAAE;YAC5B,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI;gBACrB,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,CAAC,KAAK,IAAI,GAAG;YACnB,IAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;gBACtD,MAAM,IAAI,MAAM;YAClB;YACA,OAAO,CAAC,IAAI,WAAW,GAAG,GAAG;QAC/B;IACF,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,UAAU;QAC3C,UAAU,CAAC;QAEX,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAK,OAAO,EAAG;YAC3C,OAAO,CAAC,IAAI,WAAW,GAAG,GAAG,KAAK,OAAO,CAAC,IAAI;QAChD;IACF,OAAO;QACL,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,eAAgB,GAAG;IAC1B,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,IAAI,UAAU,CAAC,+BAA+B,EAAE,OAAO,KAAK;IACpE;IAEA,KAAK,MAAM,YAAY;QAAC;QAAU;QAAU;KAAO,CAAE;QACnD,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,UAAU;YACrC,MAAM,IAAI,UAAU,CAAC,aAAa,EAAE,SAAS,mBAAmB,EAAE,OAAO,GAAG,CAAC,SAAS,EAAE;QAC1F;IACF;IAEA,IAAI,IAAI,OAAO,KAAK,aAAa,OAAO,IAAI,OAAO,KAAK,UAAU;QAChE,MAAM,IAAI,UAAU,CAAC,mCAAmC,EAAE,OAAO,KAAK;IACxE;AACF;AAEA;;CAEC,GACD,SAAS,iBAAkB,KAAK;IAC9B,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,IAAI,UAAU,CAAC,iCAAiC,EAAE,OAAO,OAAO;IACxE;IAEA,KAAK,MAAM,YAAY;QAAC;QAAc;QAAY;QAAW;KAAW,CAAE;QACxE,IAAI,OAAO,KAAK,CAAC,SAAS,KAAK,UAAU;YACvC,MAAM,IAAI,UAAU,CAAC,eAAe,EAAE,SAAS,mBAAmB,EAAE,OAAO,KAAK,CAAC,SAAS,EAAE;QAC9F;IACF;IAEA,IAAI,OAAO,MAAM,aAAa,KAAK,UAAU;QAC3C,MAAM,IAAI,UAAU,CAAC,+CAA+C,EAAE,OAAO,MAAM,aAAa,EAAE;IACpG;IAEA,IAAI,MAAM,OAAO,IAAI,QAAQ,OAAO,MAAM,OAAO,KAAK,UAAU;QAC9D,MAAM,IAAI,UAAU,CAAC,4CAA4C,EAAE,OAAO,MAAM,OAAO,EAAE;IAC3F;IAEA,IAAI,MAAM,IAAI,KAAK,aAAa,OAAO,MAAM,IAAI,KAAK,UAAU;QAC9D,MAAM,IAAI,UAAU,CAAC,sCAAsC,EAAE,OAAO,MAAM,IAAI,EAAE;IAClF;IAEA,IAAI,MAAM,IAAI,KAAK,aAAa,OAAO,MAAM,IAAI,KAAK,UAAU;QAC9D,MAAM,IAAI,UAAU,CAAC,sCAAsC,EAAE,OAAO,MAAM,IAAI,EAAE;IAClF;AACF;AAEA;;;;;;CAMC,GACD,SAAS,wBAAyB,MAAM;IACtC;;GAEC,GACD,MAAM,SAAS,CAAC;IAEhB,IAAI;IACJ,IAAI,MAAM,OAAO,CAAC,SAAS;QACzB,aAAa,EAAE;QAEf,KAAK,MAAM,aAAa,OAAQ;YAC9B,WAAW,IAAI,IAAI,UAAU,KAAK,CAAC;QACrC;IACF,OAAO;QACL,aAAa,OAAO,KAAK,CAAC;IAC5B;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;QAC1C,MAAM,YAAY,UAAU,CAAC,EAAE,CAAC,WAAW;QAC3C,MAAM,oBAAoB,UAAU,OAAO,CAAC;QAE5C,IAAI;QACJ,IAAI;QACJ,IAAI,sBAAsB,CAAC,GAAG;YAC5B,MAAM,UAAU,SAAS,CAAC,GAAG,mBAAmB,SAAS;YACzD,QAAQ,UAAU,SAAS,CAAC,oBAAoB;QAClD,OAAO;YACL,MAAM,UAAU,IAAI;QACtB;QAEA,OAAQ;YACN,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBAAkB;oBACrB,IAAI,UAAU,aAAa,KAAK,CAAC,EAAE,KAAK,KAAK;wBAC3C;oBACF;oBAEA,IACE,MAAM,MAAM,IAAI,KAChB,KAAK,CAAC,EAAE,KAAK,OACb,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAAK,KAC5B;wBACA,QAAQ,MAAM,SAAS,CAAC,GAAG,MAAM,MAAM,GAAG;oBAC5C;oBAEA,MAAM,cAAc,SAAS,OAAO;oBACpC,2CAA2C;oBAC3C,IAAI,gBAAgB,aAAa;wBAC/B;oBACF;oBAEA,IAAI,QAAQ,aAAa,OAAO,UAAU,MAAM,CAAC,IAAI,IAAI,aAAa;wBACpE;oBACF;oBAEA,MAAM,CAAC,IAAI,GAAG;oBAEd;gBACF;YACA,KAAK;YACL,KAAK;gBAAY;oBACf,IAAI,OAAO;wBACT,mEAAmE;wBACnE,oEAAoE;wBACpE,8DAA8D;wBAC9D,0DAA0D;wBAC1D,gEAAgE;wBAChE,kEAAkE;wBAClE,mEAAmE;wBACnE,kEAAkE;wBAClE,mEAAmE;wBACnE,qCAAqC;wBACrC,8DAA8D;wBAC9D,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK;4BACpB,uFAAuF;4BAEvF,wDAAwD;4BACxD,MAAM,UAAU;gCAAC,MAAM,SAAS,CAAC;6BAAG;4BAEpC,IAAI,mBAAmB,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAAK;4BACnD,IAAI,CAAC,kBAAkB;gCACrB,0DAA0D;gCAC1D,0EAA0E;gCAC1E,IAAK,IAAI,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;oCAC9C,MAAM,WAAW,UAAU,CAAC,EAAE;oCAC9B,MAAM,iBAAiB,SAAS,MAAM;oCAEtC,QAAQ,IAAI,CAAC,SAAS,IAAI;oCAE1B,IAAI,mBAAmB,KAAK,QAAQ,CAAC,iBAAiB,EAAE,KAAK,KAAK;wCAChE,mBAAmB;wCACnB;oCACF;gCACF;4BACF;4BAEA,IAAI,kBAAkB;gCACpB,IAAI,aAAa,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE;gCAC5C,IAAI,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE,KAAK,KAAK;oCAC7C,aAAa,WAAW,SAAS,CAAC,GAAG,WAAW,MAAM,GAAG;oCACzD,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,GAAG;gCAChC;gCAEA,IAAI,OAAO,QAAQ;oCACjB,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gCACnC,OAAO;oCACL,MAAM,CAAC,IAAI,GAAG;gCAChB;4BACF;wBACF,OAAO;4BACL,0CAA0C;4BAC1C,IAAI,OAAO,QAAQ;gCACjB,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;4BACnC,OAAO;gCACL,MAAM,CAAC,IAAI,GAAG;oCAAC;iCAAM;4BACvB;wBACF;wBAEA;oBACF;gBACF;YACA,0CAA0C;YAC1C,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAI,OAAO;oBAGT;gBACF;gBAEA,MAAM,CAAC,IAAI,GAAG;gBACd;YACF;gBAEE;QACJ;IACF;IAEA,OAAO;AACT;AAEA;;;;CAIC,GACD,SAAS,gBAAiB,UAAU,EAAE,OAAO;IAC3C,IAAI,OAAO,eAAe,YAAY,WAAW,QAAQ,CAAC,MAAM;QAC9D,OAAO;IACT;IAEA,MAAM,SAAkE,CAAC;IAEzE,MAAM,iBAAiB,OAAO,eAAe,WACzC,WAAW,KAAK,CAAC,OACjB;IAEJ,KAAK,MAAM,UAAU,eAAgB;QACnC,MAAM,gBAAgB,OAAO,IAAI,GAAG,WAAW;QAE/C,MAAM,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,IAAI;IACpD;IAEA,OAAO;AACT;AAEA;;;;;;;;CAQC,GACD,SAAS,aAAc,IAAI;IACzB,IAAI,KAAK,MAAM,IAAI,GAAG;QACpB,2EAA2E;QAC3E,oDAAoD;QACpD,OAAO;IACT;IAEA,IAAI,IAAI,CAAC,EAAE,KAAK,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,KAAK,KAAK;QACpD,0EAA0E;QAC1E,4DAA4D;QAC5D,iBAAiB;QACjB,OAAO,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,OAAO,KAAK,UAAU,CAAC,MAAM;IACpD;IAEA,IAAI,KAAK,UAAU,CAAC,UAAU,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,KAAK,KAAK;QAC3D,uEAAuE;QACvE,SAAS;QACT,6BAA6B;QAC7B,OAAO,KAAK,MAAM,KAAK;IACzB;IAEA,gBAAgB;IAChB,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,iBAAkB,KAAK,EAAE,OAAO,YAAY;IACnD,IAAI,OAAO,UAAU,YAAY,UAAU,MAAM;QAC/C,MAAM,IAAI,UAAU,CAAC,iBAAiB,EAAE,KAAK,yBAAyB,EAAE,UAAU,OAAO,SAAS,OAAO,OAAO;IAClH;IAEA,KAAK,MAAM,MAAM;QAAC;QAAO;QAAqB;KAAS,CAAE;QACvD,IAAI,OAAO,KAAK,CAAC,GAAG,KAAK,YAAY;YACnC,MAAM,IAAI,UAAU,GAAG,KAAK,mBAAmB,EAAE,GAAG,aAAa,CAAC;QACpE;IACF;AACF;AACA;;;CAGC,GACD,SAAS,mBAAoB,OAAO,EAAE,OAAO,cAAc;IACzD,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU;QAC3B,MAAM,IAAI,UAAU,CAAC,iBAAiB,EAAE,KAAK,2BAA2B,EAAE,YAAY,OAAO,SAAS,OAAO,SAAS;IACxH;IAEA,IAAI,QAAQ,MAAM,KAAK,GAAG;QACxB,MAAM,IAAI,UAAU,GAAG,KAAK,kCAAkC,CAAC;IACjE;IAEA,KAAK,MAAM,UAAU,QAAS;QAC5B,IAAI,CAAC,gBAAgB,QAAQ,CAAC,SAAS;YACrC,MAAM,IAAI,UAAU,CAAC,WAAW,EAAE,KAAK,4CAA4C,EAAE,gBAAgB,IAAI,CAAC,MAAM,MAAM,EAAE,QAAQ;QAClI;IACF;AACF;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2779, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/util/date.js"],"sourcesContent":["'use strict'\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-date-time-formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseHttpDate (date) {\n  // Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate\n  // Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format\n  // Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format\n\n  switch (date[3]) {\n    case ',': return parseImfDate(date)\n    case ' ': return parseAscTimeDate(date)\n    default: return parseRfc850Date(date)\n  }\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#preferred.date.format\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseImfDate (date) {\n  if (\n    date.length !== 29 ||\n    date[4] !== ' ' ||\n    date[7] !== ' ' ||\n    date[11] !== ' ' ||\n    date[16] !== ' ' ||\n    date[19] !== ':' ||\n    date[22] !== ':' ||\n    date[25] !== ' ' ||\n    date[26] !== 'G' ||\n    date[27] !== 'M' ||\n    date[28] !== 'T'\n  ) {\n    return undefined\n  }\n\n  let weekday = -1\n  if (date[0] === 'S' && date[1] === 'u' && date[2] === 'n') { // Sunday\n    weekday = 0\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n') { // Monday\n    weekday = 1\n  } else if (date[0] === 'T' && date[1] === 'u' && date[2] === 'e') { // Tuesday\n    weekday = 2\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd') { // Wednesday\n    weekday = 3\n  } else if (date[0] === 'T' && date[1] === 'h' && date[2] === 'u') { // Thursday\n    weekday = 4\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i') { // Friday\n    weekday = 5\n  } else if (date[0] === 'S' && date[1] === 'a' && date[2] === 't') { // Saturday\n    weekday = 6\n  } else {\n    return undefined // Not a valid day of the week\n  }\n\n  let day = 0\n  if (date[5] === '0') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(6)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(5)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(6)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let monthIdx = -1\n  if (\n    (date[8] === 'J' && date[9] === 'a' && date[10] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[8] === 'F' && date[9] === 'e' && date[10] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[8] === 'M' && date[9] === 'a')\n  ) {\n    if (date[10] === 'r') {\n      monthIdx = 2 // Mar\n    } else if (date[10] === 'y') {\n      monthIdx = 4 // May\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'J')\n  ) {\n    if (date[9] === 'a' && date[10] === 'n') {\n      monthIdx = 0 // Jan\n    } else if (date[9] === 'u') {\n      if (date[10] === 'n') {\n        monthIdx = 5 // Jun\n      } else if (date[10] === 'l') {\n        monthIdx = 6 // Jul\n      } else {\n        return undefined // Invalid month\n      }\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'A')\n  ) {\n    if (date[9] === 'p' && date[10] === 'r') {\n      monthIdx = 3 // Apr\n    } else if (date[9] === 'u' && date[10] === 'g') {\n      monthIdx = 7 // Aug\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[8] === 'S' && date[9] === 'e' && date[10] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[8] === 'O' && date[9] === 'c' && date[10] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[8] === 'N' && date[9] === 'o' && date[10] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[8] === 'D' && date[9] === 'e' && date[10] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  const yearDigit1 = date.charCodeAt(12)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(13)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit3 = date.charCodeAt(14)\n  if (yearDigit3 < 48 || yearDigit3 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit4 = date.charCodeAt(15)\n  if (yearDigit4 < 48 || yearDigit4 > 57) {\n    return undefined // Not a digit\n  }\n  const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48)\n\n  let hour = 0\n  if (date[17] === '0') {\n    const code = date.charCodeAt(18)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(17)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(18)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[20] === '0') {\n    const code = date.charCodeAt(21)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(20)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(21)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[23] === '0') {\n    const code = date.charCodeAt(24)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(23)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(24)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseAscTimeDate (date) {\n  // This is assumed to be in UTC\n\n  if (\n    date.length !== 24 ||\n    date[7] !== ' ' ||\n    date[10] !== ' ' ||\n    date[19] !== ' '\n  ) {\n    return undefined\n  }\n\n  let weekday = -1\n  if (date[0] === 'S' && date[1] === 'u' && date[2] === 'n') { // Sunday\n    weekday = 0\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n') { // Monday\n    weekday = 1\n  } else if (date[0] === 'T' && date[1] === 'u' && date[2] === 'e') { // Tuesday\n    weekday = 2\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd') { // Wednesday\n    weekday = 3\n  } else if (date[0] === 'T' && date[1] === 'h' && date[2] === 'u') { // Thursday\n    weekday = 4\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i') { // Friday\n    weekday = 5\n  } else if (date[0] === 'S' && date[1] === 'a' && date[2] === 't') { // Saturday\n    weekday = 6\n  } else {\n    return undefined // Not a valid day of the week\n  }\n\n  let monthIdx = -1\n  if (\n    (date[4] === 'J' && date[5] === 'a' && date[6] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[4] === 'F' && date[5] === 'e' && date[6] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[4] === 'M' && date[5] === 'a')\n  ) {\n    if (date[6] === 'r') {\n      monthIdx = 2 // Mar\n    } else if (date[6] === 'y') {\n      monthIdx = 4 // May\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'J')\n  ) {\n    if (date[5] === 'a' && date[6] === 'n') {\n      monthIdx = 0 // Jan\n    } else if (date[5] === 'u') {\n      if (date[6] === 'n') {\n        monthIdx = 5 // Jun\n      } else if (date[6] === 'l') {\n        monthIdx = 6 // Jul\n      } else {\n        return undefined // Invalid month\n      }\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'A')\n  ) {\n    if (date[5] === 'p' && date[6] === 'r') {\n      monthIdx = 3 // Apr\n    } else if (date[5] === 'u' && date[6] === 'g') {\n      monthIdx = 7 // Aug\n    } else {\n      return undefined // Invalid month\n    }\n  } else if (\n    (date[4] === 'S' && date[5] === 'e' && date[6] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[4] === 'O' && date[5] === 'c' && date[6] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[4] === 'N' && date[5] === 'o' && date[6] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[4] === 'D' && date[5] === 'e' && date[6] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  let day = 0\n  if (date[8] === ' ') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(9)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(8)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(9)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let hour = 0\n  if (date[11] === '0') {\n    const code = date.charCodeAt(12)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(11)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(12)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[14] === '0') {\n    const code = date.charCodeAt(15)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(14)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(15)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[17] === '0') {\n    const code = date.charCodeAt(18)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(17)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(18)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const yearDigit1 = date.charCodeAt(20)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(21)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit3 = date.charCodeAt(22)\n  if (yearDigit3 < 48 || yearDigit3 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit4 = date.charCodeAt(23)\n  if (yearDigit4 < 48 || yearDigit4 > 57) {\n    return undefined // Not a digit\n  }\n  const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48)\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseRfc850Date (date) {\n  let commaIndex = -1\n\n  let weekday = -1\n  if (date[0] === 'S') {\n    if (date[1] === 'u' && date[2] === 'n' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n      weekday = 0 // Sunday\n      commaIndex = 6\n    } else if (date[1] === 'a' && date[2] === 't' && date[3] === 'u' && date[4] === 'r' && date[5] === 'd' && date[6] === 'a' && date[7] === 'y') {\n      weekday = 6 // Saturday\n      commaIndex = 8\n    }\n  } else if (date[0] === 'M' && date[1] === 'o' && date[2] === 'n' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n    weekday = 1 // Monday\n    commaIndex = 6\n  } else if (date[0] === 'T') {\n    if (date[1] === 'u' && date[2] === 'e' && date[3] === 's' && date[4] === 'd' && date[5] === 'a' && date[6] === 'y') {\n      weekday = 2 // Tuesday\n      commaIndex = 7\n    } else if (date[1] === 'h' && date[2] === 'u' && date[3] === 'r' && date[4] === 's' && date[5] === 'd' && date[6] === 'a' && date[7] === 'y') {\n      weekday = 4 // Thursday\n      commaIndex = 8\n    }\n  } else if (date[0] === 'W' && date[1] === 'e' && date[2] === 'd' && date[3] === 'n' && date[4] === 'e' && date[5] === 's' && date[6] === 'd' && date[7] === 'a' && date[8] === 'y') {\n    weekday = 3 // Wednesday\n    commaIndex = 9\n  } else if (date[0] === 'F' && date[1] === 'r' && date[2] === 'i' && date[3] === 'd' && date[4] === 'a' && date[5] === 'y') {\n    weekday = 5 // Friday\n    commaIndex = 6\n  } else {\n    // Not a valid day name\n    return undefined\n  }\n\n  if (\n    date[commaIndex] !== ',' ||\n    (date.length - commaIndex - 1) !== 23 ||\n    date[commaIndex + 1] !== ' ' ||\n    date[commaIndex + 4] !== '-' ||\n    date[commaIndex + 8] !== '-' ||\n    date[commaIndex + 11] !== ' ' ||\n    date[commaIndex + 14] !== ':' ||\n    date[commaIndex + 17] !== ':' ||\n    date[commaIndex + 20] !== ' ' ||\n    date[commaIndex + 21] !== 'G' ||\n    date[commaIndex + 22] !== 'M' ||\n    date[commaIndex + 23] !== 'T'\n  ) {\n    return undefined\n  }\n\n  let day = 0\n  if (date[commaIndex + 2] === '0') {\n    // Single digit day, e.g. \"Sun Nov 6 08:49:37 1994\"\n    const code = date.charCodeAt(commaIndex + 3)\n    if (code < 49 || code > 57) {\n      return undefined // Not a digit\n    }\n    day = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 2)\n    if (code1 < 49 || code1 > 51) {\n      return undefined // Not a digit between 1 and 3\n    }\n    const code2 = date.charCodeAt(commaIndex + 3)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    day = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let monthIdx = -1\n  if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'n')\n  ) {\n    monthIdx = 0 // Jan\n  } else if (\n    (date[commaIndex + 5] === 'F' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'b')\n  ) {\n    monthIdx = 1 // Feb\n  } else if (\n    (date[commaIndex + 5] === 'M' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'r')\n  ) {\n    monthIdx = 2 // Mar\n  } else if (\n    (date[commaIndex + 5] === 'A' && date[commaIndex + 6] === 'p' && date[commaIndex + 7] === 'r')\n  ) {\n    monthIdx = 3 // Apr\n  } else if (\n    (date[commaIndex + 5] === 'M' && date[commaIndex + 6] === 'a' && date[commaIndex + 7] === 'y')\n  ) {\n    monthIdx = 4 // May\n  } else if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'n')\n  ) {\n    monthIdx = 5 // Jun\n  } else if (\n    (date[commaIndex + 5] === 'J' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'l')\n  ) {\n    monthIdx = 6 // Jul\n  } else if (\n    (date[commaIndex + 5] === 'A' && date[commaIndex + 6] === 'u' && date[commaIndex + 7] === 'g')\n  ) {\n    monthIdx = 7 // Aug\n  } else if (\n    (date[commaIndex + 5] === 'S' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'p')\n  ) {\n    monthIdx = 8 // Sep\n  } else if (\n    (date[commaIndex + 5] === 'O' && date[commaIndex + 6] === 'c' && date[commaIndex + 7] === 't')\n  ) {\n    monthIdx = 9 // Oct\n  } else if (\n    (date[commaIndex + 5] === 'N' && date[commaIndex + 6] === 'o' && date[commaIndex + 7] === 'v')\n  ) {\n    monthIdx = 10 // Nov\n  } else if (\n    (date[commaIndex + 5] === 'D' && date[commaIndex + 6] === 'e' && date[commaIndex + 7] === 'c')\n  ) {\n    monthIdx = 11 // Dec\n  } else {\n    // Not a valid month\n    return undefined\n  }\n\n  const yearDigit1 = date.charCodeAt(commaIndex + 9)\n  if (yearDigit1 < 48 || yearDigit1 > 57) {\n    return undefined // Not a digit\n  }\n  const yearDigit2 = date.charCodeAt(commaIndex + 10)\n  if (yearDigit2 < 48 || yearDigit2 > 57) {\n    return undefined // Not a digit\n  }\n\n  let year = (yearDigit1 - 48) * 10 + (yearDigit2 - 48) // Convert ASCII codes to number\n\n  // RFC 6265 states that the year is in the range 1970-2069.\n  // @see https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.1\n  //\n  // 3. If the year-value is greater than or equal to 70 and less than or\n  //    equal to 99, increment the year-value by 1900.\n  // 4. If the year-value is greater than or equal to 0 and less than or\n  //    equal to 69, increment the year-value by 2000.\n  year += year < 70 ? 2000 : 1900\n\n  let hour = 0\n  if (date[commaIndex + 12] === '0') {\n    const code = date.charCodeAt(commaIndex + 13)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    hour = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 12)\n    if (code1 < 48 || code1 > 50) {\n      return undefined // Not a digit between 0 and 2\n    }\n    const code2 = date.charCodeAt(commaIndex + 13)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    if (code1 === 50 && code2 > 51) {\n      return undefined // Hour cannot be greater than 23\n    }\n    hour = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let minute = 0\n  if (date[commaIndex + 15] === '0') {\n    const code = date.charCodeAt(commaIndex + 16)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    minute = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 15)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(commaIndex + 16)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    minute = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  let second = 0\n  if (date[commaIndex + 18] === '0') {\n    const code = date.charCodeAt(commaIndex + 19)\n    if (code < 48 || code > 57) {\n      return undefined // Not a digit\n    }\n    second = code - 48 // Convert ASCII code to number\n  } else {\n    const code1 = date.charCodeAt(commaIndex + 18)\n    if (code1 < 48 || code1 > 53) {\n      return undefined // Not a digit between 0 and 5\n    }\n    const code2 = date.charCodeAt(commaIndex + 19)\n    if (code2 < 48 || code2 > 57) {\n      return undefined // Not a digit\n    }\n    second = (code1 - 48) * 10 + (code2 - 48) // Convert ASCII codes to number\n  }\n\n  const result = new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n  return result.getUTCDay() === weekday ? result : undefined\n}\n\nmodule.exports = {\n  parseHttpDate\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3370, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/wrap-handler.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('../core/errors')\n\nmodule.exports = class WrapHandler {\n  #handler\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static wrap (handler) {\n    // TODO (fix): More checks...\n    return handler.onRequestStart ? handler : new WrapHandler(handler)\n  }\n\n  // Unwrap Interface\n\n  onConnect (abort, context) {\n    return this.#handler.onConnect?.(abort, context)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onData (data) {\n    return this.#handler.onData?.(data)\n  }\n\n  onComplete (trailers) {\n    return this.#handler.onComplete?.(trailers)\n  }\n\n  onError (err) {\n    if (!this.#handler.onError) {\n      throw err\n    }\n\n    return this.#handler.onError?.(err)\n  }\n\n  // Wrap Interface\n\n  onRequestStart (controller, context) {\n    this.#handler.onConnect?.((reason) => controller.abort(reason), context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseData (controller, data) {\n    if (this.#handler.onData?.(data) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    const rawTrailers = []\n    for (const [key, val] of Object.entries(trailers)) {\n      rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onComplete?.(rawTrailers)\n  }\n\n  onResponseError (controller, err) {\n    if (!this.#handler.onError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onError?.(err)\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,oBAAoB,EAAE;AAE9B,OAAO,OAAO,GAAG,MAAM;IACrB,CAAA,OAAQ,CAAA;IAER,YAAa,OAAO,CAAE;QACpB,IAAI,CAAC,CAAA,OAAQ,GAAG;IAClB;IAEA,OAAO,KAAM,OAAO,EAAE;QACpB,6BAA6B;QAC7B,OAAO,QAAQ,cAAc,GAAG,UAAU,IAAI,YAAY;IAC5D;IAEA,mBAAmB;IAEnB,UAAW,KAAK,EAAE,OAAO,EAAE;QACzB,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,OAAO;IAC1C;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,aAAa,EAAE;QACxD,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,YAAY,YAAY,QAAQ;IACnE;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE;QACzC,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,YAAY,YAAY;IAC3D;IAEA,OAAQ,IAAI,EAAE;QACZ,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,MAAM,GAAG;IAChC;IAEA,WAAY,QAAQ,EAAE;QACpB,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,UAAU,GAAG;IACpC;IAEA,QAAS,GAAG,EAAE;QACZ,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,CAAC,OAAO,EAAE;YAC1B,MAAM;QACR;QAEA,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,OAAO,GAAG;IACjC;IAEA,iBAAiB;IAEjB,eAAgB,UAAU,EAAE,OAAO,EAAE;QACnC,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,CAAC,SAAW,WAAW,KAAK,CAAC,SAAS;IAClE;IAEA,iBAAkB,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE;QACzD,MAAM,aAAa,EAAE;QACrB,KAAK,MAAM,CAAC,KAAK,IAAI,IAAI,OAAO,OAAO,CAAC,SAAU;YAChD,WAAW,IAAI,CAAC,OAAO,IAAI,CAAC,MAAM,MAAM,OAAO,CAAC,OAAO,IAAI,GAAG,CAAC,CAAA,IAAK,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC;QACpG;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,YAAY,YAAY;IACpD;IAEA,gBAAiB,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,aAAa,EAAE;QAC/D,MAAM,aAAa,EAAE;QACrB,KAAK,MAAM,CAAC,KAAK,IAAI,IAAI,OAAO,OAAO,CAAC,SAAU;YAChD,WAAW,IAAI,CAAC,OAAO,IAAI,CAAC,MAAM,MAAM,OAAO,CAAC,OAAO,IAAI,GAAG,CAAC,CAAA,IAAK,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC;QACpG;QAEA,IAAI,IAAI,CAAC,CAAA,OAAQ,CAAC,SAAS,GAAG,YAAY,YAAY,IAAM,WAAW,MAAM,IAAI,mBAAmB,OAAO;YACzG,WAAW,KAAK;QAClB;IACF;IAEA,eAAgB,UAAU,EAAE,IAAI,EAAE;QAChC,IAAI,IAAI,CAAC,CAAA,OAAQ,CAAC,MAAM,GAAG,UAAU,OAAO;YAC1C,WAAW,KAAK;QAClB;IACF;IAEA,cAAe,UAAU,EAAE,QAAQ,EAAE;QACnC,MAAM,cAAc,EAAE;QACtB,KAAK,MAAM,CAAC,KAAK,IAAI,IAAI,OAAO,OAAO,CAAC,UAAW;YACjD,YAAY,IAAI,CAAC,OAAO,IAAI,CAAC,MAAM,MAAM,OAAO,CAAC,OAAO,IAAI,GAAG,CAAC,CAAA,IAAK,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC;QACrG;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,UAAU,GAAG;IAC7B;IAEA,gBAAiB,UAAU,EAAE,GAAG,EAAE;QAChC,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,CAAC,OAAO,EAAE;YAC1B,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,OAAO,GAAG;IAC1B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3445, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/unwrap-handler.js"],"sourcesContent":["'use strict'\n\nconst { parseHeaders } = require('../core/util')\nconst { InvalidArgumentError } = require('../core/errors')\n\nconst kResume = Symbol('resume')\n\nclass UnwrapController {\n  #paused = false\n  #reason = null\n  #aborted = false\n  #abort\n\n  [kResume] = null\n\n  constructor (abort) {\n    this.#abort = abort\n  }\n\n  pause () {\n    this.#paused = true\n  }\n\n  resume () {\n    if (this.#paused) {\n      this.#paused = false\n      this[kResume]?.()\n    }\n  }\n\n  abort (reason) {\n    if (!this.#aborted) {\n      this.#aborted = true\n      this.#reason = reason\n      this.#abort(reason)\n    }\n  }\n\n  get aborted () {\n    return this.#aborted\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  get paused () {\n    return this.#paused\n  }\n}\n\nmodule.exports = class UnwrapHandler {\n  #handler\n  #controller\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static unwrap (handler) {\n    // TODO (fix): More checks...\n    return !handler.onRequestStart ? handler : new UnwrapHandler(handler)\n  }\n\n  onConnect (abort, context) {\n    this.#controller = new UnwrapController(abort)\n    this.#handler.onRequestStart?.(this.#controller, context)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    this.#controller[kResume] = resume\n    this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage)\n    return !this.#controller.paused\n  }\n\n  onData (data) {\n    this.#handler.onResponseData?.(this.#controller, data)\n    return !this.#controller.paused\n  }\n\n  onComplete (rawTrailers) {\n    this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers))\n  }\n\n  onError (err) {\n    if (!this.#handler.onResponseError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onResponseError?.(this.#controller, err)\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,YAAY,EAAE;AACtB,MAAM,EAAE,oBAAoB,EAAE;AAE9B,MAAM,UAAU,OAAO;AAEvB,MAAM;IACJ,CAAA,MAAO,GAAG,MAAK;IACf,CAAA,MAAO,GAAG,KAAI;IACd,CAAA,OAAQ,GAAG,MAAK;IAChB,CAAA,KAAM,CAAA;IAEN,CAAC,QAAQ,GAAG,KAAI;IAEhB,YAAa,KAAK,CAAE;QAClB,IAAI,CAAC,CAAA,KAAM,GAAG;IAChB;IAEA,QAAS;QACP,IAAI,CAAC,CAAA,MAAO,GAAG;IACjB;IAEA,SAAU;QACR,IAAI,IAAI,CAAC,CAAA,MAAO,EAAE;YAChB,IAAI,CAAC,CAAA,MAAO,GAAG;YACf,IAAI,CAAC,QAAQ;QACf;IACF;IAEA,MAAO,MAAM,EAAE;QACb,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,EAAE;YAClB,IAAI,CAAC,CAAA,OAAQ,GAAG;YAChB,IAAI,CAAC,CAAA,MAAO,GAAG;YACf,IAAI,CAAC,CAAA,KAAM,CAAC;QACd;IACF;IAEA,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,CAAA,OAAQ;IACtB;IAEA,IAAI,SAAU;QACZ,OAAO,IAAI,CAAC,CAAA,MAAO;IACrB;IAEA,IAAI,SAAU;QACZ,OAAO,IAAI,CAAC,CAAA,MAAO;IACrB;AACF;AAEA,OAAO,OAAO,GAAG,MAAM;IACrB,CAAA,OAAQ,CAAA;IACR,CAAA,UAAW,CAAA;IAEX,YAAa,OAAO,CAAE;QACpB,IAAI,CAAC,CAAA,OAAQ,GAAG;IAClB;IAEA,OAAO,OAAQ,OAAO,EAAE;QACtB,6BAA6B;QAC7B,OAAO,CAAC,QAAQ,cAAc,GAAG,UAAU,IAAI,cAAc;IAC/D;IAEA,UAAW,KAAK,EAAE,OAAO,EAAE;QACzB,IAAI,CAAC,CAAA,UAAW,GAAG,IAAI,iBAAiB;QACxC,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE;IACnD;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE;QACzC,IAAI,CAAC,CAAA,OAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE,YAAY,aAAa,aAAa;IAC3F;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,aAAa,EAAE;QACxD,IAAI,CAAC,CAAA,UAAW,CAAC,QAAQ,GAAG;QAC5B,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE,YAAY,aAAa,aAAa;QACxF,OAAO,CAAC,IAAI,CAAC,CAAA,UAAW,CAAC,MAAM;IACjC;IAEA,OAAQ,IAAI,EAAE;QACZ,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE;QACjD,OAAO,CAAC,IAAI,CAAC,CAAA,UAAW,CAAC,MAAM;IACjC;IAEA,WAAY,WAAW,EAAE;QACvB,IAAI,CAAC,CAAA,OAAQ,CAAC,aAAa,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE,aAAa;IAC/D;IAEA,QAAS,GAAG,EAAE;QACZ,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,EAAE;YAClC,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,CAAA,UAAW,EAAE;IACpD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3523, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/retry-handler.js"],"sourcesContent":["'use strict'\nconst assert = require('node:assert')\n\nconst { kRetryHandlerDefaultRetry } = require('../core/symbols')\nconst { RequestRetryError } = require('../core/errors')\nconst WrapHandler = require('./wrap-handler')\nconst {\n  isDisturbed,\n  parseRangeHeader,\n  wrapRequestBody\n} = require('../core/util')\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const retryTime = new Date(retryAfter).getTime()\n  return isNaN(retryTime) ? 0 : retryTime - Date.now()\n}\n\nclass RetryHandler {\n  constructor (opts, { dispatch, handler }) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes,\n      throwOnError\n    } = retryOptions ?? {}\n\n    this.error = null\n    this.dispatch = dispatch\n    this.handler = WrapHandler.wrap(handler)\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.retryOpts = {\n      throwOnError: throwOnError ?? true,\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.headersSent = false\n    this.start = 0\n    this.end = null\n    this.etag = null\n  }\n\n  onResponseStartWithRetry (controller, statusCode, headers, statusMessage, err) {\n    if (this.retryOpts.throwOnError) {\n      // Preserve old behavior for status codes that are not eligible for retry\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      } else {\n        this.error = err\n      }\n\n      return\n    }\n\n    if (isDisturbed(this.opts.body)) {\n      this.headersSent = true\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    function shouldRetry (passedErr) {\n      if (passedErr) {\n        this.headersSent = true\n\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n        controller.resume()\n        return\n      }\n\n      this.error = err\n      controller.resume()\n    }\n\n    controller.pause()\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n\n  onRequestStart (controller, context) {\n    if (!this.headersSent) {\n      this.handler.onRequestStart?.(controller, context)\n    }\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(headers['retry-after'])\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.error = null\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      const err = new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: {\n          count: this.retryCount\n        }\n      })\n\n      this.onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err)\n      return\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.headersSent) {\n      // Only Partial Content 206 supposed to provide Content-Range,\n      // any other status code that partially consumed the payload\n      // should not be retried because it would result in downstream\n      // wrongly concatenate multiple responses.\n      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {\n        throw new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('Content-Range mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('ETag mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const { start, size, end = size ? size - 1 : null } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      return\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          this.headersSent = true\n          this.handler.onResponseStart?.(\n            controller,\n            statusCode,\n            headers,\n            statusMessage\n          )\n          return\n        }\n\n        const { start, size, end = size ? size - 1 : null } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) - 1 : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = true\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (\n        this.etag != null &&\n        this.etag[0] === 'W' &&\n        this.etag[1] === '/'\n      ) {\n        this.etag = null\n      }\n\n      this.headersSent = true\n      this.handler.onResponseStart?.(\n        controller,\n        statusCode,\n        headers,\n        statusMessage\n      )\n    } else {\n      throw new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: { count: this.retryCount }\n      })\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.error) {\n      return\n    }\n\n    this.start += chunk.length\n\n    this.handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.error && this.retryOpts.throwOnError) {\n      throw this.error\n    }\n\n    if (!this.error) {\n      this.retryCount = 0\n      return this.handler.onResponseEnd?.(controller, trailers)\n    }\n\n    this.retry(controller)\n  }\n\n  retry (controller) {\n    if (this.start !== 0) {\n      const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n      // Weak etag check - weak etags will make comparison algorithms never match\n      if (this.etag != null) {\n        headers['if-match'] = this.etag\n      }\n\n      this.opts = {\n        ...this.opts,\n        headers: {\n          ...this.opts.headers,\n          ...headers\n        }\n      }\n    }\n\n    try {\n      this.retryCountCheckpoint = this.retryCount\n      this.dispatch(this.opts, this)\n    } catch (err) {\n      this.handler.onResponseError?.(controller, err)\n    }\n  }\n\n  onResponseError (controller, err) {\n    if (controller?.aborted || isDisturbed(this.opts.body)) {\n      this.handler.onResponseError?.(controller, err)\n      return\n    }\n\n    function shouldRetry (returnedErr) {\n      if (!returnedErr) {\n        this.retry(controller)\n        return\n      }\n\n      this.handler?.onResponseError?.(controller, returnedErr)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n}\n\nmodule.exports = RetryHandler\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3840, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/decorator-handler.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst WrapHandler = require('./wrap-handler')\n\n/**\n * @deprecated\n */\nmodule.exports = class DecoratorHandler {\n  #handler\n  #onCompleteCalled = false\n  #onErrorCalled = false\n  #onResponseStartCalled = false\n\n  constructor (handler) {\n    if (typeof handler !== 'object' || handler === null) {\n      throw new TypeError('handler must be an object')\n    }\n    this.#handler = WrapHandler.wrap(handler)\n  }\n\n  onRequestStart (...args) {\n    this.#handler.onRequestStart?.(...args)\n  }\n\n  onRequestUpgrade (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onRequestUpgrade?.(...args)\n  }\n\n  onResponseStart (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n    assert(!this.#onResponseStartCalled)\n\n    this.#onResponseStartCalled = true\n\n    return this.#handler.onResponseStart?.(...args)\n  }\n\n  onResponseData (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onResponseData?.(...args)\n  }\n\n  onResponseEnd (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    this.#onCompleteCalled = true\n    return this.#handler.onResponseEnd?.(...args)\n  }\n\n  onResponseError (...args) {\n    this.#onErrorCalled = true\n    return this.#handler.onResponseError?.(...args)\n  }\n\n  /**\n   * @deprecated\n   */\n  onBodySent () {}\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;CAEC,GACD,OAAO,OAAO,GAAG,MAAM;IACrB,CAAA,OAAQ,CAAA;IACR,CAAA,gBAAiB,GAAG,MAAK;IACzB,CAAA,aAAc,GAAG,MAAK;IACtB,CAAA,qBAAsB,GAAG,MAAK;IAE9B,YAAa,OAAO,CAAE;QACpB,IAAI,OAAO,YAAY,YAAY,YAAY,MAAM;YACnD,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,CAAC,CAAA,OAAQ,GAAG,YAAY,IAAI,CAAC;IACnC;IAEA,eAAgB,GAAG,IAAI,EAAE;QACvB,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,MAAM;IACpC;IAEA,iBAAkB,GAAG,IAAI,EAAE;QACzB,OAAO,CAAC,IAAI,CAAC,CAAA,gBAAiB;QAC9B,OAAO,CAAC,IAAI,CAAC,CAAA,aAAc;QAE3B,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,gBAAgB,MAAM;IAC7C;IAEA,gBAAiB,GAAG,IAAI,EAAE;QACxB,OAAO,CAAC,IAAI,CAAC,CAAA,gBAAiB;QAC9B,OAAO,CAAC,IAAI,CAAC,CAAA,aAAc;QAC3B,OAAO,CAAC,IAAI,CAAC,CAAA,qBAAsB;QAEnC,IAAI,CAAC,CAAA,qBAAsB,GAAG;QAE9B,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,MAAM;IAC5C;IAEA,eAAgB,GAAG,IAAI,EAAE;QACvB,OAAO,CAAC,IAAI,CAAC,CAAA,gBAAiB;QAC9B,OAAO,CAAC,IAAI,CAAC,CAAA,aAAc;QAE3B,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,MAAM;IAC3C;IAEA,cAAe,GAAG,IAAI,EAAE;QACtB,OAAO,CAAC,IAAI,CAAC,CAAA,gBAAiB;QAC9B,OAAO,CAAC,IAAI,CAAC,CAAA,aAAc;QAE3B,IAAI,CAAC,CAAA,gBAAiB,GAAG;QACzB,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,aAAa,MAAM;IAC1C;IAEA,gBAAiB,GAAG,IAAI,EAAE;QACxB,IAAI,CAAC,CAAA,aAAc,GAAG;QACtB,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,MAAM;IAC5C;IAEA;;GAEC,GACD,aAAc,CAAC;AACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3893, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/redirect-handler.js"],"sourcesContent":["'use strict'\n\nconst util = require('../core/util')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('node:assert')\nconst { InvalidArgumentError } = require('../core/errors')\nconst EE = require('node:events')\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nconst noop = () => {}\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  static buildDispatch (dispatcher, maxRedirections) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    const dispatch = dispatcher.dispatch.bind(dispatcher)\n    return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler))\n  }\n\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    this.dispatch = dispatch\n    this.location = null\n    const { maxRedirections: _, ...cleanOpts } = opts\n    this.opts = cleanOpts // opts must be a copy, exclude maxRedirections\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body) &&\n      !util.isFormDataLike(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onRequestStart (controller, context) {\n    this.handler.onRequestStart?.(controller, { ...context, history: this.history })\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n      throw new Error('max redirects')\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.2\n    // https://fetch.spec.whatwg.org/#http-redirect-fetch\n    // In case of HTTP 301 or 302 with POST, change the method to GET\n    if ((statusCode === 301 || statusCode === 302) && this.opts.method === 'POST') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1\n      ? null\n      : headers.location\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Check for redirect loops by seeing if we've already visited this URL in our history\n    // This catches the case where Client/Pool try to handle cross-origin redirects but fail\n    // and keep redirecting to the same URL in an infinite loop\n    const redirectUrlString = `${origin}${path}`\n    for (const historyUrl of this.history) {\n      if (historyUrl.toString() === redirectUrlString) {\n        throw new InvalidArgumentError(`Redirect loop detected. Cannot redirect to ${origin}. This typically happens when using a Client or Pool with cross-origin redirects. Use an Agent for cross-origin redirects.`)\n      }\n    }\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.query = null\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      this.handler.onResponseData?.(controller, chunk)\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, error) {\n    this.handler.onResponseError?.(controller, error)\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  if (header.length === 4) {\n    return util.headerNameToString(header) === 'host'\n  }\n  if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n    return true\n  }\n  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n    const name = util.headerNameToString(header)\n    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'\n  }\n  return false\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    const entries = typeof headers[Symbol.iterator] === 'function' ? headers : Object.entries(headers)\n    for (const [key, value] of entries) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, value)\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4103, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/cache-handler.js"],"sourcesContent":["'use strict'\n\nconst util = require('../core/util')\nconst {\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable\n} = require('../util/cache')\nconst { parseHttpDate } = require('../util/date.js')\n\nfunction noop () {}\n\n// Status codes that we can use some heuristics on to cache\nconst HEURISTICALLY_CACHEABLE_STATUS_CODES = [\n  200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501\n]\n\n// Status codes which semantic is not handled by the cache\n// https://datatracker.ietf.org/doc/html/rfc9111#section-3\n// This list should not grow beyond 206 and 304 unless the RFC is updated\n// by a newer one including more. Please introduce another list if\n// implementing caching of responses with the 'must-understand' directive.\nconst NOT_UNDERSTOOD_STATUS_CODES = [\n  206, 304\n]\n\nconst MAX_RESPONSE_AGE = 2147483647000\n\n/**\n * @typedef {import('../../types/dispatcher.d.ts').default.DispatchHandler} DispatchHandler\n *\n * @implements {DispatchHandler}\n */\nclass CacheHandler {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n   */\n  #cacheKey\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}\n   */\n  #cacheType\n\n  /**\n   * @type {number | undefined}\n   */\n  #cacheByDefault\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}\n   */\n  #store\n\n  /**\n   * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n   */\n  #handler\n\n  /**\n   * @type {import('node:stream').Writable | undefined}\n   */\n  #writeStream\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n   */\n  constructor ({ store, type, cacheByDefault }, cacheKey, handler) {\n    this.#store = store\n    this.#cacheType = type\n    this.#cacheByDefault = cacheByDefault\n    this.#cacheKey = cacheKey\n    this.#handler = handler\n  }\n\n  onRequestStart (controller, context) {\n    this.#writeStream?.destroy()\n    this.#writeStream = undefined\n    this.#handler.onRequestStart?.(controller, context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {number} statusCode\n   * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n   * @param {string} statusMessage\n   */\n  onResponseStart (\n    controller,\n    statusCode,\n    resHeaders,\n    statusMessage\n  ) {\n    const downstreamOnHeaders = () =>\n      this.#handler.onResponseStart?.(\n        controller,\n        statusCode,\n        resHeaders,\n        statusMessage\n      )\n\n    if (\n      !util.safeHTTPMethods.includes(this.#cacheKey.method) &&\n      statusCode >= 200 &&\n      statusCode <= 399\n    ) {\n      // Successful response to an unsafe method, delete it from cache\n      //  https://www.rfc-editor.org/rfc/rfc9111.html#name-invalidating-stored-response\n      try {\n        this.#store.delete(this.#cacheKey)?.catch?.(noop)\n      } catch {\n        // Fail silently\n      }\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlHeader = resHeaders['cache-control']\n    const heuristicallyCacheable = resHeaders['last-modified'] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode)\n    if (\n      !cacheControlHeader &&\n      !resHeaders['expires'] &&\n      !heuristicallyCacheable &&\n      !this.#cacheByDefault\n    ) {\n      // Don't have anything to tell us this response is cachable and we're not\n      //  caching by default\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {}\n    if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {\n      return downstreamOnHeaders()\n    }\n\n    const now = Date.now()\n    const resAge = resHeaders.age ? getAge(resHeaders.age) : undefined\n    if (resAge && resAge >= MAX_RESPONSE_AGE) {\n      // Response considered stale\n      return downstreamOnHeaders()\n    }\n\n    const resDate = typeof resHeaders.date === 'string'\n      ? parseHttpDate(resHeaders.date)\n      : undefined\n\n    const staleAt =\n      determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ??\n      this.#cacheByDefault\n    if (staleAt === undefined || (resAge && resAge > staleAt)) {\n      return downstreamOnHeaders()\n    }\n\n    const baseTime = resDate ? resDate.getTime() : now\n    const absoluteStaleAt = staleAt + baseTime\n    if (now >= absoluteStaleAt) {\n      // Response is already stale\n      return downstreamOnHeaders()\n    }\n\n    let varyDirectives\n    if (this.#cacheKey.headers && resHeaders.vary) {\n      varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers)\n      if (!varyDirectives) {\n        // Parse error\n        return downstreamOnHeaders()\n      }\n    }\n\n    const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt)\n    const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives)\n\n    /**\n     * @type {import('../../types/cache-interceptor.d.ts').default.CacheValue}\n     */\n    const value = {\n      statusCode,\n      statusMessage,\n      headers: strippedHeaders,\n      vary: varyDirectives,\n      cacheControlDirectives,\n      cachedAt: resAge ? now - resAge : now,\n      staleAt: absoluteStaleAt,\n      deleteAt\n    }\n\n    if (typeof resHeaders.etag === 'string' && isEtagUsable(resHeaders.etag)) {\n      value.etag = resHeaders.etag\n    }\n\n    this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value)\n    if (!this.#writeStream) {\n      return downstreamOnHeaders()\n    }\n\n    const handler = this\n    this.#writeStream\n      .on('drain', () => controller.resume())\n      .on('error', function () {\n        // TODO (fix): Make error somehow observable?\n        handler.#writeStream = undefined\n\n        // Delete the value in case the cache store is holding onto state from\n        //  the call to createWriteStream\n        handler.#store.delete(handler.#cacheKey)\n      })\n      .on('close', function () {\n        if (handler.#writeStream === this) {\n          handler.#writeStream = undefined\n        }\n\n        // TODO (fix): Should we resume even if was paused downstream?\n        controller.resume()\n      })\n\n    return downstreamOnHeaders()\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#writeStream?.write(chunk) === false) {\n      controller.pause()\n    }\n\n    this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    this.#writeStream?.end()\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    this.#writeStream?.destroy(err)\n    this.#writeStream = undefined\n    this.#handler.onResponseError?.(controller, err)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n *\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} statusCode\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n */\nfunction canCacheResponse (cacheType, statusCode, resHeaders, cacheControlDirectives) {\n  // Status code must be final and understood.\n  if (statusCode < 200 || NOT_UNDERSTOOD_STATUS_CODES.includes(statusCode)) {\n    return false\n  }\n  // Responses with neither status codes that are heuristically cacheable, nor \"explicit enough\" caching\n  // directives, are not cacheable. \"Explicit enough\": see https://www.rfc-editor.org/rfc/rfc9111.html#section-3\n  if (!HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode) && !resHeaders['expires'] &&\n    !cacheControlDirectives.public &&\n    cacheControlDirectives['max-age'] === undefined &&\n    // RFC 9111: a private response directive, if the cache is not shared\n    !(cacheControlDirectives.private && cacheType === 'private') &&\n    !(cacheControlDirectives['s-maxage'] !== undefined && cacheType === 'shared')\n  ) {\n    return false\n  }\n\n  if (cacheControlDirectives['no-store']) {\n    return false\n  }\n\n  if (cacheType === 'shared' && cacheControlDirectives.private === true) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#section-4.1-5\n  if (resHeaders.vary?.includes('*')) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n  if (resHeaders.authorization) {\n    if (!cacheControlDirectives.public || typeof resHeaders.authorization !== 'string') {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['no-cache']) &&\n      cacheControlDirectives['no-cache'].includes('authorization')\n    ) {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['private']) &&\n      cacheControlDirectives['private'].includes('authorization')\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {string | string[]} ageHeader\n * @returns {number | undefined}\n */\nfunction getAge (ageHeader) {\n  const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader)\n\n  return isNaN(age) ? undefined : age * 1000\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} now\n * @param {number | undefined} age\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {Date | undefined} responseDate\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n *\n * @returns {number | undefined} time that the value is stale at in seconds or undefined if it shouldn't be cached\n */\nfunction determineStaleAt (cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {\n  if (cacheType === 'shared') {\n    // Prioritize s-maxage since we're a shared cache\n    //  s-maxage > max-age > Expire\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.2.10-3\n    const sMaxAge = cacheControlDirectives['s-maxage']\n    if (sMaxAge !== undefined) {\n      return sMaxAge > 0 ? sMaxAge * 1000 : undefined\n    }\n  }\n\n  const maxAge = cacheControlDirectives['max-age']\n  if (maxAge !== undefined) {\n    return maxAge > 0 ? maxAge * 1000 : undefined\n  }\n\n  if (typeof resHeaders.expires === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.3\n    const expiresDate = parseHttpDate(resHeaders.expires)\n    if (expiresDate) {\n      if (now >= expiresDate.getTime()) {\n        return undefined\n      }\n\n      if (responseDate) {\n        if (responseDate >= expiresDate) {\n          return undefined\n        }\n\n        if (age !== undefined && age > (expiresDate - responseDate)) {\n          return undefined\n        }\n      }\n\n      return expiresDate.getTime() - now\n    }\n  }\n\n  if (typeof resHeaders['last-modified'] === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-calculating-heuristic-fresh\n    const lastModified = new Date(resHeaders['last-modified'])\n    if (isValidDate(lastModified)) {\n      if (lastModified.getTime() >= now) {\n        return undefined\n      }\n\n      const responseAge = now - lastModified.getTime()\n\n      return responseAge * 0.1\n    }\n  }\n\n  if (cacheControlDirectives.immutable) {\n    // https://www.rfc-editor.org/rfc/rfc8246.html#section-2.2\n    return 31536000\n  }\n\n  return undefined\n}\n\n/**\n * @param {number} now\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @param {number} staleAt\n */\nfunction determineDeleteAt (now, cacheControlDirectives, staleAt) {\n  let staleWhileRevalidate = -Infinity\n  let staleIfError = -Infinity\n  let immutable = -Infinity\n\n  if (cacheControlDirectives['stale-while-revalidate']) {\n    staleWhileRevalidate = staleAt + (cacheControlDirectives['stale-while-revalidate'] * 1000)\n  }\n\n  if (cacheControlDirectives['stale-if-error']) {\n    staleIfError = staleAt + (cacheControlDirectives['stale-if-error'] * 1000)\n  }\n\n  if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {\n    immutable = now + 31536000000\n  }\n\n  return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable)\n}\n\n/**\n * Strips headers required to be removed in cached responses\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @returns {Record<string, string | string []>}\n */\nfunction stripNecessaryHeaders (resHeaders, cacheControlDirectives) {\n  const headersToRemove = [\n    'connection',\n    'proxy-authenticate',\n    'proxy-authentication-info',\n    'proxy-authorization',\n    'proxy-connection',\n    'te',\n    'transfer-encoding',\n    'upgrade',\n    // We'll add age back when serving it\n    'age'\n  ]\n\n  if (resHeaders['connection']) {\n    if (Array.isArray(resHeaders['connection'])) {\n      // connection: a\n      // connection: b\n      headersToRemove.push(...resHeaders['connection'].map(header => header.trim()))\n    } else {\n      // connection: a, b\n      headersToRemove.push(...resHeaders['connection'].split(',').map(header => header.trim()))\n    }\n  }\n\n  if (Array.isArray(cacheControlDirectives['no-cache'])) {\n    headersToRemove.push(...cacheControlDirectives['no-cache'])\n  }\n\n  if (Array.isArray(cacheControlDirectives['private'])) {\n    headersToRemove.push(...cacheControlDirectives['private'])\n  }\n\n  let strippedHeaders\n  for (const headerName of headersToRemove) {\n    if (resHeaders[headerName]) {\n      strippedHeaders ??= { ...resHeaders }\n      delete strippedHeaders[headerName]\n    }\n  }\n\n  return strippedHeaders ?? resHeaders\n}\n\n/**\n * @param {Date} date\n * @returns {boolean}\n */\nfunction isValidDate (date) {\n  return date instanceof Date && Number.isFinite(date.valueOf())\n}\n\nmodule.exports = CacheHandler\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4462, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/handler/cache-revalidation-handler.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\n\n/**\n * This takes care of revalidation requests we send to the origin. If we get\n *  a response indicating that what we have is cached (via a HTTP 304), we can\n *  continue using the cached value. Otherwise, we'll receive the new response\n *  here, which we then just pass on to the next handler (most likely a\n *  CacheHandler). Note that this assumes the proper headers were already\n *  included in the request to tell the origin that we want to revalidate the\n *  response (i.e. if-modified-since or if-none-match).\n *\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-validation\n *\n * @implements {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n */\nclass CacheRevalidationHandler {\n  #successful = false\n\n  /**\n   * @type {((boolean, any) => void) | null}\n   */\n  #callback\n\n  /**\n   * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}\n   */\n  #handler\n\n  #context\n\n  /**\n   * @type {boolean}\n   */\n  #allowErrorStatusCodes\n\n  /**\n   * @param {(boolean) => void} callback Function to call if the cached value is valid\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler\n   * @param {boolean} allowErrorStatusCodes\n   */\n  constructor (callback, handler, allowErrorStatusCodes) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.#callback = callback\n    this.#handler = handler\n    this.#allowErrorStatusCodes = allowErrorStatusCodes\n  }\n\n  onRequestStart (_, context) {\n    this.#successful = false\n    this.#context = context\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (\n    controller,\n    statusCode,\n    headers,\n    statusMessage\n  ) {\n    assert(this.#callback != null)\n\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-handling-a-validation-respo\n    // https://datatracker.ietf.org/doc/html/rfc5861#section-4\n    this.#successful = statusCode === 304 ||\n      (this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504)\n    this.#callback(this.#successful, this.#context)\n    this.#callback = null\n\n    if (this.#successful) {\n      return true\n    }\n\n    this.#handler.onRequestStart?.(controller, this.#context)\n    this.#handler.onResponseStart?.(\n      controller,\n      statusCode,\n      headers,\n      statusMessage\n    )\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#successful) {\n      return\n    }\n\n    return this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#successful) {\n      return\n    }\n\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#successful) {\n      return\n    }\n\n    if (this.#callback) {\n      this.#callback(false)\n      this.#callback = null\n    }\n\n    if (typeof this.#handler.onResponseError === 'function') {\n      this.#handler.onResponseError(controller, err)\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports = CacheRevalidationHandler\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;;;;;;;CAYC,GACD,MAAM;IACJ,CAAA,UAAW,GAAG,MAAK;IAEnB;;GAEC,GACD,CAAA,QAAS,CAAA;IAET;;GAEC,GACD,CAAA,OAAQ,CAAA;IAER,CAAA,OAAQ,CAAA;IAER;;GAEC,GACD,CAAA,qBAAsB,CAAA;IAEtB;;;;GAIC,GACD,YAAa,QAAQ,EAAE,OAAO,EAAE,qBAAqB,CAAE;QACrD,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM,IAAI,UAAU;QACtB;QAEA,IAAI,CAAC,CAAA,QAAS,GAAG;QACjB,IAAI,CAAC,CAAA,OAAQ,GAAG;QAChB,IAAI,CAAC,CAAA,qBAAsB,GAAG;IAChC;IAEA,eAAgB,CAAC,EAAE,OAAO,EAAE;QAC1B,IAAI,CAAC,CAAA,UAAW,GAAG;QACnB,IAAI,CAAC,CAAA,OAAQ,GAAG;IAClB;IAEA,iBAAkB,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE;QACzD,IAAI,CAAC,CAAA,OAAQ,CAAC,gBAAgB,GAAG,YAAY,YAAY,SAAS;IACpE;IAEA,gBACE,UAAU,EACV,UAAU,EACV,OAAO,EACP,aAAa,EACb;QACA,OAAO,IAAI,CAAC,CAAA,QAAS,IAAI;QAEzB,+EAA+E;QAC/E,0DAA0D;QAC1D,IAAI,CAAC,CAAA,UAAW,GAAG,eAAe,OAC/B,IAAI,CAAC,CAAA,qBAAsB,IAAI,cAAc,OAAO,cAAc;QACrE,IAAI,CAAC,CAAA,QAAS,CAAC,IAAI,CAAC,CAAA,UAAW,EAAE,IAAI,CAAC,CAAA,OAAQ;QAC9C,IAAI,CAAC,CAAA,QAAS,GAAG;QAEjB,IAAI,IAAI,CAAC,CAAA,UAAW,EAAE;YACpB,OAAO;QACT;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,GAAG,YAAY,IAAI,CAAC,CAAA,OAAQ;QACxD,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,GAC3B,YACA,YACA,SACA;IAEJ;IAEA,eAAgB,UAAU,EAAE,KAAK,EAAE;QACjC,IAAI,IAAI,CAAC,CAAA,UAAW,EAAE;YACpB;QACF;QAEA,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,cAAc,GAAG,YAAY;IACpD;IAEA,cAAe,UAAU,EAAE,QAAQ,EAAE;QACnC,IAAI,IAAI,CAAC,CAAA,UAAW,EAAE;YACpB;QACF;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,aAAa,GAAG,YAAY;IAC5C;IAEA,gBAAiB,UAAU,EAAE,GAAG,EAAE;QAChC,IAAI,IAAI,CAAC,CAAA,UAAW,EAAE;YACpB;QACF;QAEA,IAAI,IAAI,CAAC,CAAA,QAAS,EAAE;YAClB,IAAI,CAAC,CAAA,QAAS,CAAC;YACf,IAAI,CAAC,CAAA,QAAS,GAAG;QACnB;QAEA,IAAI,OAAO,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,KAAK,YAAY;YACvD,IAAI,CAAC,CAAA,OAAQ,CAAC,eAAe,CAAC,YAAY;QAC5C,OAAO;YACL,MAAM;QACR;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4551, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/readable.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('node:stream')\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom } = require('../core/util')\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\nconst kUsed = Symbol('kUsed')\nconst kBytesRead = Symbol('kBytesRead')\n\nconst noop = () => {}\n\n/**\n * @class\n * @extends {Readable}\n * @see https://fetch.spec.whatwg.org/#body\n */\nclass BodyReadable extends Readable {\n  /**\n   * @param {object} opts\n   * @param {(this: Readable, size: number) => void} opts.resume\n   * @param {() => (void | null)} opts.abort\n   * @param {string} [opts.contentType = '']\n   * @param {number} [opts.contentLength]\n   * @param {number} [opts.highWaterMark = 64 * 1024]\n   */\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n\n    /** @type {Consume | null} */\n    this[kConsume] = null\n\n    /** @type {number} */\n    this[kBytesRead] = 0\n\n    /** @type {ReadableStream|null} */\n    this[kBody] = null\n\n    /** @type {boolean} */\n    this[kUsed] = false\n\n    /** @type {string} */\n    this[kContentType] = contentType\n\n    /** @type {number|null} */\n    this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null\n\n    /**\n     * Is stream being consumed through Readable API?\n     * This is an optimization so that we avoid checking\n     * for 'data' and 'readable' listeners in the hot path\n     * inside push().\n     *\n     * @type {boolean}\n     */\n    this[kReading] = false\n  }\n\n  /**\n   * @param {Error|null} err\n   * @param {(error:(Error|null)) => void} callback\n   * @returns {void}\n   */\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing an 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kUsed]) {\n      setImmediate(callback, err)\n    } else {\n      callback(err)\n    }\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  on (event, listener) {\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = true\n      this[kUsed] = true\n    }\n    return super.on(event, listener)\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  addListener (event, listener) {\n    return this.on(event, listener)\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  off (event, listener) {\n    const ret = super.off(event, listener)\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  removeListener (event, listener) {\n    return this.off(event, listener)\n  }\n\n  /**\n   * @param {Buffer|null} chunk\n   * @returns {boolean}\n   */\n  push (chunk) {\n    if (chunk) {\n      this[kBytesRead] += chunk.length\n      if (this[kConsume]) {\n        consumePush(this[kConsume], chunk)\n        return this[kReading] ? super.push(chunk) : true\n      }\n    }\n\n    return super.push(chunk)\n  }\n\n  /**\n   * Consumes and returns the body as a string.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-text\n   * @returns {Promise<string>}\n   */\n  text () {\n    return consume(this, 'text')\n  }\n\n  /**\n   * Consumes and returns the body as a JavaScript Object.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-json\n   * @returns {Promise<unknown>}\n   */\n  json () {\n    return consume(this, 'json')\n  }\n\n  /**\n   * Consumes and returns the body as a Blob\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-blob\n   * @returns {Promise<Blob>}\n   */\n  blob () {\n    return consume(this, 'blob')\n  }\n\n  /**\n   * Consumes and returns the body as an Uint8Array.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bytes\n   * @returns {Promise<Uint8Array>}\n   */\n  bytes () {\n    return consume(this, 'bytes')\n  }\n\n  /**\n   * Consumes and returns the body as an ArrayBuffer.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n   * @returns {Promise<ArrayBuffer>}\n   */\n  arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  /**\n   * Not implemented\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-formdata\n   * @throws {NotSupportedError}\n   */\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  /**\n   * Returns true if the body is not null and the body has been consumed.\n   * Otherwise, returns false.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bodyused\n   * @readonly\n   * @returns {boolean}\n   */\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#dom-body-body\n   * @readonly\n   * @returns {ReadableStream}\n   */\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  /**\n   * Dumps the response body by reading `limit` number of bytes.\n   * @param {object} opts\n   * @param {number} [opts.limit = 131072] Number of bytes to read.\n   * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.\n   * @returns {Promise<null>}\n   */\n  dump (opts) {\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      return Promise.reject(new InvalidArgumentError('signal must be an AbortSignal'))\n    }\n\n    const limit = opts?.limit && Number.isFinite(opts.limit)\n      ? opts.limit\n      : 128 * 1024\n\n    if (signal?.aborted) {\n      return Promise.reject(signal.reason ?? new AbortError())\n    }\n\n    if (this._readableState.closeEmitted) {\n      return Promise.resolve(null)\n    }\n\n    return new Promise((resolve, reject) => {\n      if (\n        (this[kContentLength] && (this[kContentLength] > limit)) ||\n        this[kBytesRead] > limit\n      ) {\n        this.destroy(new AbortError())\n      }\n\n      if (signal) {\n        const onAbort = () => {\n          this.destroy(signal.reason ?? new AbortError())\n        }\n        signal.addEventListener('abort', onAbort)\n        this\n          .on('close', function () {\n            signal.removeEventListener('abort', onAbort)\n            if (signal.aborted) {\n              reject(signal.reason ?? new AbortError())\n            } else {\n              resolve(null)\n            }\n          })\n      } else {\n        this.on('close', resolve)\n      }\n\n      this\n        .on('error', noop)\n        .on('data', () => {\n          if (this[kBytesRead] > limit) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n\n  /**\n   * @param {BufferEncoding} encoding\n   * @returns {this}\n   */\n  setEncoding (encoding) {\n    if (Buffer.isEncoding(encoding)) {\n      this._readableState.encoding = encoding\n    }\n    return this\n  }\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestream-locked\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isLocked (bodyReadable) {\n  // Consume is an implicit lock.\n  return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isUnusable (bodyReadable) {\n  return util.isDisturbed(bodyReadable) || isLocked(bodyReadable)\n}\n\n/**\n * @typedef {'text' | 'json' | 'blob' | 'bytes' | 'arrayBuffer'} ConsumeType\n */\n\n/**\n * @template {ConsumeType} T\n * @typedef {T extends 'text' ? string :\n *           T extends 'json' ? unknown :\n *           T extends 'blob' ? Blob :\n *           T extends 'arrayBuffer' ? ArrayBuffer :\n *           T extends 'bytes' ? Uint8Array :\n *           never\n * } ConsumeReturnType\n */\n/**\n * @typedef {object} Consume\n * @property {ConsumeType} type\n * @property {BodyReadable} stream\n * @property {((value?: any) => void)} resolve\n * @property {((err: Error) => void)} reject\n * @property {number} length\n * @property {Buffer[]} body\n */\n\n/**\n * @template {ConsumeType} T\n * @param {BodyReadable} stream\n * @param {T} type\n * @returns {Promise<ConsumeReturnType<T>>}\n */\nfunction consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', reject)\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\n/**\n * @param {Consume} consume\n * @returns {void}\n */\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume], this._readableState.encoding)\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume], this._readableState.encoding)\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @param {BufferEncoding} [encoding='utf8']\n * @returns {string}\n */\nfunction chunksDecode (chunks, length, encoding) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  if (!encoding || encoding === 'utf8' || encoding === 'utf-8') {\n    return buffer.utf8Slice(start, bufferLength)\n  } else {\n    return buffer.subarray(start, bufferLength).toString(encoding)\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction chunksConcat (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return new Uint8Array(0)\n  }\n  if (chunks.length === 1) {\n    // fast-path\n    return new Uint8Array(chunks[0])\n  }\n  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer)\n\n  let offset = 0\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i]\n    buffer.set(chunk, offset)\n    offset += chunk.length\n  }\n\n  return buffer\n}\n\n/**\n * @param {Consume} consume\n * @param {BufferEncoding} encoding\n * @returns {void}\n */\nfunction consumeEnd (consume, encoding) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length, encoding))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length, encoding)))\n    } else if (type === 'arrayBuffer') {\n      resolve(chunksConcat(body, length).buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    } else if (type === 'bytes') {\n      resolve(chunksConcat(body, length))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\n/**\n * @param {Consume} consume\n * @param {Buffer} chunk\n * @returns {void}\n */\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\n/**\n * @param {Consume} consume\n * @param {Error} [err]\n * @returns {void}\n */\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  // Reset the consume object to allow for garbage collection.\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = {\n  Readable: BodyReadable,\n  chunksDecode\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5006, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { AsyncResource } = require('node:async_hooks')\nconst { Readable } = require('./readable')\nconst { InvalidArgumentError, RequestAbortedError } = require('../core/errors')\nconst util = require('../core/util')\n\nfunction noop () {}\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.highWaterMark = highWaterMark\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (signal?.aborted) {\n      this.reason = signal.reason ?? new RequestAbortedError()\n    } else if (signal) {\n      this.removeAbortListener = util.addAbortListener(signal, () => {\n        this.reason = signal.reason ?? new RequestAbortedError()\n        if (this.res) {\n          util.destroy(this.res.on('error', noop), this.reason)\n        } else if (this.abort) {\n          this.abort(this.reason)\n        }\n      })\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n      this.removeAbortListener = null\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      try {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      } catch (err) {\n        // If the callback throws synchronously, we need to handle it\n        // Remove reference to res to allow res being garbage collected\n        this.res = null\n\n        // Destroy the response stream\n        util.destroy(res.on('error', noop), err)\n\n        // Use queueMicrotask to re-throw the error so it reaches uncaughtException\n        queueMicrotask(() => {\n          throw err\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res.on('error', noop), err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n\n      if (util.isStream(body)) {\n        body.on('error', noop)\n        util.destroy(body, err)\n      }\n    }\n\n    if (this.removeAbortListener) {\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new RequestHandler(opts, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5192, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/abort-signal.js"],"sourcesContent":["'use strict'\n\nconst { addAbortListener } = require('../core/util')\nconst { RequestAbortedError } = require('../core/errors')\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort(self[kSignal]?.reason)\n  } else {\n    self.reason = self[kSignal]?.reason ?? new RequestAbortedError()\n  }\n  removeSignal(self)\n}\n\nfunction addSignal (self, signal) {\n  self.reason = null\n\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,gBAAgB,EAAE;AAC1B,MAAM,EAAE,mBAAmB,EAAE;AAE7B,MAAM,YAAY,OAAO;AACzB,MAAM,UAAU,OAAO;AAEvB,SAAS,MAAO,IAAI;IAClB,IAAI,KAAK,KAAK,EAAE;QACd,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE;IAC5B,OAAO;QACL,KAAK,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,UAAU,IAAI;IAC7C;IACA,aAAa;AACf;AAEA,SAAS,UAAW,IAAI,EAAE,MAAM;IAC9B,KAAK,MAAM,GAAG;IAEd,IAAI,CAAC,QAAQ,GAAG;IAChB,IAAI,CAAC,UAAU,GAAG;IAElB,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,IAAI,OAAO,OAAO,EAAE;QAClB,MAAM;QACN;IACF;IAEA,IAAI,CAAC,QAAQ,GAAG;IAChB,IAAI,CAAC,UAAU,GAAG;QAChB,MAAM;IACR;IAEA,iBAAiB,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU;AACjD;AAEA,SAAS,aAAc,IAAI;IACzB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;QAClB;IACF;IAEA,IAAI,yBAAyB,IAAI,CAAC,QAAQ,EAAE;QAC1C,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,SAAS,IAAI,CAAC,UAAU;IAC5D,OAAO;QACL,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,SAAS,IAAI,CAAC,UAAU;IACvD;IAEA,IAAI,CAAC,QAAQ,GAAG;IAChB,IAAI,CAAC,UAAU,GAAG;AACpB;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5241, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/api-stream.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { finished } = require('node:stream')\nconst { AsyncResource } = require('node:async_hooks')\nconst { InvalidArgumentError, InvalidReturnValueError } = require('../core/errors')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nfunction noop () {}\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    if (factory === null) {\n      return\n    }\n\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res?.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new StreamHandler(opts, factory, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5411, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/api-pipeline.js"],"sourcesContent":["'use strict'\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('node:stream')\nconst assert = require('node:assert')\nconst { AsyncResource } = require('node:async_hooks')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nfunction noop () {}\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', noop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', noop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5611, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/api-upgrade.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('node:async_hooks')\nconst assert = require('node:assert')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    assert(statusCode === 101)\n\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    const upgradeOpts = {\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }\n\n    this.dispatch(upgradeOpts, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,oBAAoB,EAAE,WAAW,EAAE;AAC3C,MAAM,EAAE,aAAa,EAAE;AACvB,MAAM;AACN,MAAM;AACN,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE;AAEjC,MAAM,uBAAuB;IAC3B,YAAa,IAAI,EAAE,QAAQ,CAAE;QAC3B,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;YACrC,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM,IAAI,qBAAqB;QACjC;QAEA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,GAAG;QAE5C,IAAI,UAAU,OAAO,OAAO,EAAE,KAAK,cAAc,OAAO,OAAO,gBAAgB,KAAK,YAAY;YAC9F,MAAM,IAAI,qBAAqB;QACjC;QAEA,KAAK,CAAC;QAEN,IAAI,CAAC,eAAe,GAAG,mBAAmB;QAC1C,IAAI,CAAC,MAAM,GAAG,UAAU;QACxB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,OAAO,GAAG;QAEf,UAAU,IAAI,EAAE;IAClB;IAEA,UAAW,KAAK,EAAE,OAAO,EAAE;QACzB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,CAAC,MAAM;YACjB;QACF;QAEA,OAAO,IAAI,CAAC,QAAQ;QAEpB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,YAAa;QACX,MAAM,IAAI,YAAY,eAAe;IACvC;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE;QACzC,OAAO,eAAe;QAEtB,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI;QAE1C,aAAa,IAAI;QAEjB,IAAI,CAAC,QAAQ,GAAG;QAChB,MAAM,UAAU,IAAI,CAAC,eAAe,KAAK,QAAQ,KAAK,eAAe,CAAC,cAAc,KAAK,YAAY,CAAC;QACtG,IAAI,CAAC,eAAe,CAAC,UAAU,MAAM,MAAM;YACzC;YACA;YACA;YACA;QACF;IACF;IAEA,QAAS,GAAG,EAAE;QACZ,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,IAAI;QAEjC,aAAa,IAAI;QAEjB,IAAI,UAAU;YACZ,IAAI,CAAC,QAAQ,GAAG;YAChB,eAAe;gBACb,IAAI,CAAC,eAAe,CAAC,UAAU,MAAM,KAAK;oBAAE;gBAAO;YACrD;QACF;IACF;AACF;AAEA,SAAS,QAAS,IAAI,EAAE,QAAQ;IAC9B,IAAI,aAAa,WAAW;QAC1B,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,QAAQ,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK;gBAC7B,OAAO,MAAM,OAAO,OAAO,QAAQ;YACrC;QACF;IACF;IAEA,IAAI;QACF,MAAM,iBAAiB,IAAI,eAAe,MAAM;QAChD,MAAM,cAAc;YAClB,GAAG,IAAI;YACP,QAAQ,KAAK,MAAM,IAAI;YACvB,SAAS,KAAK,QAAQ,IAAI;QAC5B;QAEA,IAAI,CAAC,QAAQ,CAAC,aAAa;IAC7B,EAAE,OAAO,KAAK;QACZ,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM;QACR;QACA,MAAM,SAAS,MAAM;QACrB,eAAe,IAAM,SAAS,KAAK;gBAAE;YAAO;IAC9C;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5705, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/api-connect.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { AsyncResource } = require('node:async_hooks')\nconst { InvalidArgumentError, SocketError } = require('../core/errors')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    const connectOptions = { ...opts, method: 'CONNECT' }\n\n    this.dispatch(connectOptions, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,EAAE,aAAa,EAAE;AACvB,MAAM,EAAE,oBAAoB,EAAE,WAAW,EAAE;AAC3C,MAAM;AACN,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE;AAEjC,MAAM,uBAAuB;IAC3B,YAAa,IAAI,EAAE,QAAQ,CAAE;QAC3B,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;YACrC,MAAM,IAAI,qBAAqB;QACjC;QAEA,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM,IAAI,qBAAqB;QACjC;QAEA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,GAAG;QAE5C,IAAI,UAAU,OAAO,OAAO,EAAE,KAAK,cAAc,OAAO,OAAO,gBAAgB,KAAK,YAAY;YAC9F,MAAM,IAAI,qBAAqB;QACjC;QAEA,KAAK,CAAC;QAEN,IAAI,CAAC,MAAM,GAAG,UAAU;QACxB,IAAI,CAAC,eAAe,GAAG,mBAAmB;QAC1C,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QAEb,UAAU,IAAI,EAAE;IAClB;IAEA,UAAW,KAAK,EAAE,OAAO,EAAE;QACzB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,IAAI,CAAC,MAAM;YACjB;QACF;QAEA,OAAO,IAAI,CAAC,QAAQ;QAEpB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,YAAa;QACX,MAAM,IAAI,YAAY,eAAe;IACvC;IAEA,UAAW,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE;QACzC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI;QAE1C,aAAa,IAAI;QAEjB,IAAI,CAAC,QAAQ,GAAG;QAEhB,IAAI,UAAU;QACd,+BAA+B;QAC/B,IAAI,WAAW,MAAM;YACnB,UAAU,IAAI,CAAC,eAAe,KAAK,QAAQ,KAAK,eAAe,CAAC,cAAc,KAAK,YAAY,CAAC;QAClG;QAEA,IAAI,CAAC,eAAe,CAAC,UAAU,MAAM,MAAM;YACzC;YACA;YACA;YACA;YACA;QACF;IACF;IAEA,QAAS,GAAG,EAAE;QACZ,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,IAAI;QAEjC,aAAa,IAAI;QAEjB,IAAI,UAAU;YACZ,IAAI,CAAC,QAAQ,GAAG;YAChB,eAAe;gBACb,IAAI,CAAC,eAAe,CAAC,UAAU,MAAM,KAAK;oBAAE;gBAAO;YACrD;QACF;IACF;AACF;AAEA,SAAS,QAAS,IAAI,EAAE,QAAQ;IAC9B,IAAI,aAAa,WAAW;QAC1B,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,QAAQ,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK;gBAC7B,OAAO,MAAM,OAAO,OAAO,QAAQ;YACrC;QACF;IACF;IAEA,IAAI;QACF,MAAM,iBAAiB,IAAI,eAAe,MAAM;QAChD,MAAM,iBAAiB;YAAE,GAAG,IAAI;YAAE,QAAQ;QAAU;QAEpD,IAAI,CAAC,QAAQ,CAAC,gBAAgB;IAChC,EAAE,OAAO,KAAK;QACZ,IAAI,OAAO,aAAa,YAAY;YAClC,MAAM;QACR;QACA,MAAM,SAAS,MAAM;QACrB,eAAe,IAAM,SAAS,KAAK;gBAAE;YAAO;IAC9C;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5801, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/api/index.js"],"sourcesContent":["'use strict'\n\nmodule.exports.request = require('./api-request')\nmodule.exports.stream = require('./api-stream')\nmodule.exports.pipeline = require('./api-pipeline')\nmodule.exports.upgrade = require('./api-upgrade')\nmodule.exports.connect = require('./api-connect')\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,CAAC,OAAO;AACtB,OAAO,OAAO,CAAC,MAAM;AACrB,OAAO,OAAO,CAAC,QAAQ;AACvB,OAAO,OAAO,CAAC,OAAO;AACtB,OAAO,OAAO,CAAC,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5810, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-errors.js"],"sourcesContent":["'use strict'\n\nconst { UndiciError } = require('../core/errors')\n\nconst kMockNotMatchedError = Symbol.for('undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED')\n\n/**\n * The request does not match any registered mock dispatches.\n */\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n\n  static [Symbol.hasInstance] (instance) {\n    return instance && instance[kMockNotMatchedError] === true\n  }\n\n  get [kMockNotMatchedError] () {\n    return true\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,WAAW,EAAE;AAErB,MAAM,uBAAuB,OAAO,GAAG,CAAC;AAExC;;CAEC,GACD,MAAM,4BAA4B;IAChC,YAAa,OAAO,CAAE;QACpB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG,WAAW;QAC1B,IAAI,CAAC,IAAI,GAAG;IACd;IAEA,OAAO,CAAC,OAAO,WAAW,CAAC,CAAE,QAAQ,EAAE;QACrC,OAAO,YAAY,QAAQ,CAAC,qBAAqB,KAAK;IACxD;IAEA,IAAI,CAAC,qBAAqB,GAAI;QAC5B,OAAO;IACT;AACF;AAEA,OAAO,OAAO,GAAG;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5835, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-symbols.js"],"sourcesContent":["'use strict'\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOriginalDispatch: Symbol('original dispatch'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected'),\n  kIgnoreTrailingSlash: Symbol('ignore trailing slash'),\n  kMockAgentMockCallHistoryInstance: Symbol('mock agent mock call history name'),\n  kMockAgentRegisterCallHistory: Symbol('mock agent register mock call history'),\n  kMockAgentAddCallHistoryLog: Symbol('mock agent add call history log'),\n  kMockAgentIsCallHistoryEnabled: Symbol('mock agent is call history enabled'),\n  kMockAgentAcceptsNonStandardSearchParameters: Symbol('mock agent accepts non standard search parameters'),\n  kMockCallHistoryAddLog: Symbol('mock call history add log')\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;IACf,QAAQ,OAAO;IACf,UAAU,OAAO;IACjB,UAAU,OAAO;IACjB,aAAa,OAAO;IACpB,cAAc,OAAO;IACrB,iBAAiB,OAAO;IACxB,kBAAkB,OAAO;IACzB,gBAAgB,OAAO;IACvB,YAAY,OAAO;IACnB,eAAe,OAAO;IACtB,eAAe,OAAO;IACtB,eAAe,OAAO;IACtB,QAAQ,OAAO;IACf,gBAAgB,OAAO;IACvB,mBAAmB,OAAO;IAC1B,SAAS,OAAO;IAChB,eAAe,OAAO;IACtB,aAAa,OAAO;IACpB,gBAAgB,OAAO;IACvB,YAAY,OAAO;IACnB,sBAAsB,OAAO;IAC7B,mCAAmC,OAAO;IAC1C,+BAA+B,OAAO;IACtC,6BAA6B,OAAO;IACpC,gCAAgC,OAAO;IACvC,8CAA8C,OAAO;IACrD,wBAAwB,OAAO;AACjC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5868, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-utils.js"],"sourcesContent":["'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols')\nconst { serializePathWithQuery } = require('../core/util')\nconst { STATUS_CODES } = require('node:http')\nconst {\n  types: {\n    isPromise\n  }\n} = require('node:util')\nconst { InvalidArgumentError } = require('../core/errors')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction normalizeSearchParams (query) {\n  if (typeof query !== 'string') {\n    return query\n  }\n\n  const originalQp = new URLSearchParams(query)\n  const normalizedQp = new URLSearchParams()\n\n  for (let [key, value] of originalQp.entries()) {\n    key = key.replace('[]', '')\n\n    const valueRepresentsString = /^(['\"]).*\\1$/.test(value)\n    if (valueRepresentsString) {\n      normalizedQp.append(key, value)\n      continue\n    }\n\n    if (value.includes(',')) {\n      const values = value.split(',')\n      for (const v of values) {\n        normalizedQp.append(key, v)\n      }\n      continue\n    }\n\n    normalizedQp.append(key, value)\n  }\n\n  return normalizedQp\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n  const pathSegments = path.split('?', 3)\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else if (data) {\n    return data.toString()\n  } else {\n    return ''\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath)\n\n  // Match path\n  let matchedMockDispatches = mockDispatches\n    .filter(({ consumed }) => !consumed)\n    .filter(({ path, ignoreTrailingSlash }) => {\n      return ignoreTrailingSlash\n        ? matchValue(removeTrailingSlash(safeUrl(path)), resolvedPathWithoutTrailingSlash)\n        : matchValue(safeUrl(path), resolvedPath)\n    })\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data, opts) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\n/**\n * @param {string} path Path to remove trailing slash from\n */\nfunction removeTrailingSlash (path) {\n  while (path.endsWith('/')) {\n    path = path.slice(0, -1)\n  }\n\n  if (path.length === 0) {\n    path = '/'\n  }\n\n  return path\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error.code === 'UND_MOCK_ERR_MOCK_NOT_MATCHED') {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildAndValidateMockOptions (opts) {\n  const { agent, ...mockOptions } = opts\n\n  if ('enableCallHistory' in mockOptions && typeof mockOptions.enableCallHistory !== 'boolean') {\n    throw new InvalidArgumentError('options.enableCallHistory must to be a boolean')\n  }\n\n  if ('acceptNonStandardSearchParameters' in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== 'boolean') {\n    throw new InvalidArgumentError('options.acceptNonStandardSearchParameters must to be a boolean')\n  }\n\n  if ('ignoreTrailingSlash' in mockOptions && typeof mockOptions.ignoreTrailingSlash !== 'boolean') {\n    throw new InvalidArgumentError('options.ignoreTrailingSlash must to be a boolean')\n  }\n\n  return mockOptions\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildAndValidateMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray,\n  normalizeSearchParams\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6255, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-interceptor.js"],"sourcesContent":["'use strict'\n\nconst { getResponseData, buildKey, addMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch,\n  kIgnoreTrailingSlash\n} = require('./mock-symbols')\nconst { InvalidArgumentError } = require('../core/errors')\nconst { serializePathWithQuery } = require('../core/util')\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = serializePathWithQuery(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData ({ statusCode, data, responseOptions }) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (replyParameters) {\n    if (typeof replyParameters.statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyOptionsCallbackOrStatusCode) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyOptionsCallbackOrStatusCode(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object' || resolvedData === null) {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const replyParameters = { data: '', responseOptions: {}, ...resolvedData }\n        this.validateReplyParameters(replyParameters)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(replyParameters)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const replyParameters = {\n      statusCode: replyOptionsCallbackOrStatusCode,\n      data: arguments[1] === undefined ? '' : arguments[1],\n      responseOptions: arguments[2] === undefined ? {} : arguments[2]\n    }\n    this.validateReplyParameters(replyParameters)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(replyParameters)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6449, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-client.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('node:util')\nconst Client = require('../dispatcher/client')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,SAAS,EAAE;AACnB,MAAM;AACN,MAAM,EAAE,iBAAiB,EAAE;AAC3B,MAAM,EACJ,WAAW,EACX,UAAU,EACV,MAAM,EACN,cAAc,EACd,OAAO,EACP,iBAAiB,EACjB,UAAU,EACV,oBAAoB,EACrB;AACD,MAAM,EAAE,eAAe,EAAE;AACzB,MAAM;AACN,MAAM,EAAE,oBAAoB,EAAE;AAE9B;;CAEC,GACD,MAAM,mBAAmB;IACvB,YAAa,MAAM,EAAE,IAAI,CAAE;QACzB,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,QAAQ,KAAK,YAAY;YACrE,MAAM,IAAI,qBAAqB;QACjC;QAEA,KAAK,CAAC,QAAQ;QAEd,IAAI,CAAC,WAAW,GAAG,KAAK,KAAK;QAC7B,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,qBAAqB,GAAG,KAAK,mBAAmB,IAAI;QACzD,IAAI,CAAC,YAAY,GAAG,EAAE;QACtB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAAQ;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI;QAE3C,IAAI,CAAC,QAAQ,GAAG,kBAAkB,IAAI,CAAC,IAAI;QAC3C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO;IAC3B;IAEA,IAAI,CAAC,QAAQ,UAAU,CAAC,GAAI;QAC1B,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA;;GAEC,GACD,UAAW,IAAI,EAAE;QACf,OAAO,IAAI,gBACT,QAAQ;YAAE,qBAAqB,IAAI,CAAC,qBAAqB;YAAE,GAAG,IAAI;QAAC,GACnE,IAAI,CAAC,YAAY;IAErB;IAEA,aAAc;QACZ,IAAI,CAAC,YAAY,GAAG,EAAE;IACxB;IAEA,MAAM,CAAC,OAAO,GAAI;QAChB,MAAM,UAAU,IAAI,CAAC,eAAe;QACpC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ;IACzD;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6499, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-call-history.js"],"sourcesContent":["'use strict'\n\nconst { kMockCallHistoryAddLog } = require('./mock-symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\nfunction handleFilterCallsWithOptions (criteria, options, handler, store) {\n  switch (options.operator) {\n    case 'OR':\n      store.push(...handler(criteria))\n\n      return store\n    case 'AND':\n      return handler.call({ logs: store }, criteria)\n    default:\n      // guard -- should never happens because buildAndValidateFilterCallsOptions is called before\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n  }\n}\n\nfunction buildAndValidateFilterCallsOptions (options = {}) {\n  const finalOptions = {}\n\n  if ('operator' in options) {\n    if (typeof options.operator !== 'string' || (options.operator.toUpperCase() !== 'OR' && options.operator.toUpperCase() !== 'AND')) {\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n    }\n\n    return {\n      ...finalOptions,\n      operator: options.operator.toUpperCase()\n    }\n  }\n\n  return finalOptions\n}\n\nfunction makeFilterCalls (parameterName) {\n  return (parameterValue) => {\n    if (typeof parameterValue === 'string' || parameterValue == null) {\n      return this.logs.filter((log) => {\n        return log[parameterName] === parameterValue\n      })\n    }\n    if (parameterValue instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return parameterValue.test(log[parameterName])\n      })\n    }\n\n    throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`)\n  }\n}\nfunction computeUrlWithMaybeSearchParameters (requestInit) {\n  // path can contains query url parameters\n  // or query can contains query url parameters\n  try {\n    const url = new URL(requestInit.path, requestInit.origin)\n\n    // requestInit.path contains query url parameters\n    // requestInit.query is then undefined\n    if (url.search.length !== 0) {\n      return url\n    }\n\n    // requestInit.query can be populated here\n    url.search = new URLSearchParams(requestInit.query).toString()\n\n    return url\n  } catch (error) {\n    throw new InvalidArgumentError('An error occurred when computing MockCallHistoryLog.url', { cause: error })\n  }\n}\n\nclass MockCallHistoryLog {\n  constructor (requestInit = {}) {\n    this.body = requestInit.body\n    this.headers = requestInit.headers\n    this.method = requestInit.method\n\n    const url = computeUrlWithMaybeSearchParameters(requestInit)\n\n    this.fullUrl = url.toString()\n    this.origin = url.origin\n    this.path = url.pathname\n    this.searchParams = Object.fromEntries(url.searchParams)\n    this.protocol = url.protocol\n    this.host = url.host\n    this.port = url.port\n    this.hash = url.hash\n  }\n\n  toMap () {\n    return new Map([\n      ['protocol', this.protocol],\n      ['host', this.host],\n      ['port', this.port],\n      ['origin', this.origin],\n      ['path', this.path],\n      ['hash', this.hash],\n      ['searchParams', this.searchParams],\n      ['fullUrl', this.fullUrl],\n      ['method', this.method],\n      ['body', this.body],\n      ['headers', this.headers]]\n    )\n  }\n\n  toString () {\n    const options = { betweenKeyValueSeparator: '->', betweenPairSeparator: '|' }\n    let result = ''\n\n    this.toMap().forEach((value, key) => {\n      if (typeof value === 'string' || value === undefined || value === null) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`\n      }\n      if ((typeof value === 'object' && value !== null) || Array.isArray(value)) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`\n      }\n      // maybe miss something for non Record / Array headers and searchParams here\n    })\n\n    // delete last betweenPairSeparator\n    return result.slice(0, -1)\n  }\n}\n\nclass MockCallHistory {\n  logs = []\n\n  calls () {\n    return this.logs\n  }\n\n  firstCall () {\n    return this.logs.at(0)\n  }\n\n  lastCall () {\n    return this.logs.at(-1)\n  }\n\n  nthCall (number) {\n    if (typeof number !== 'number') {\n      throw new InvalidArgumentError('nthCall must be called with a number')\n    }\n    if (!Number.isInteger(number)) {\n      throw new InvalidArgumentError('nthCall must be called with an integer')\n    }\n    if (Math.sign(number) !== 1) {\n      throw new InvalidArgumentError('nthCall must be called with a positive value. use firstCall or lastCall instead')\n    }\n\n    // non zero based index. this is more human readable\n    return this.logs.at(number - 1)\n  }\n\n  filterCalls (criteria, options) {\n    // perf\n    if (this.logs.length === 0) {\n      return this.logs\n    }\n    if (typeof criteria === 'function') {\n      return this.logs.filter(criteria)\n    }\n    if (criteria instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return criteria.test(log.toString())\n      })\n    }\n    if (typeof criteria === 'object' && criteria !== null) {\n      // no criteria - returning all logs\n      if (Object.keys(criteria).length === 0) {\n        return this.logs\n      }\n\n      const finalOptions = { operator: 'OR', ...buildAndValidateFilterCallsOptions(options) }\n\n      let maybeDuplicatedLogsFiltered = []\n      if ('protocol' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered)\n      }\n      if ('host' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered)\n      }\n      if ('port' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered)\n      }\n      if ('origin' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered)\n      }\n      if ('path' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered)\n      }\n      if ('hash' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered)\n      }\n      if ('fullUrl' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered)\n      }\n      if ('method' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered)\n      }\n\n      const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)]\n\n      return uniqLogsFiltered\n    }\n\n    throw new InvalidArgumentError('criteria parameter should be one of function, regexp, or object')\n  }\n\n  filterCallsByProtocol = makeFilterCalls.call(this, 'protocol')\n\n  filterCallsByHost = makeFilterCalls.call(this, 'host')\n\n  filterCallsByPort = makeFilterCalls.call(this, 'port')\n\n  filterCallsByOrigin = makeFilterCalls.call(this, 'origin')\n\n  filterCallsByPath = makeFilterCalls.call(this, 'path')\n\n  filterCallsByHash = makeFilterCalls.call(this, 'hash')\n\n  filterCallsByFullUrl = makeFilterCalls.call(this, 'fullUrl')\n\n  filterCallsByMethod = makeFilterCalls.call(this, 'method')\n\n  clear () {\n    this.logs = []\n  }\n\n  [kMockCallHistoryAddLog] (requestInit) {\n    const log = new MockCallHistoryLog(requestInit)\n\n    this.logs.push(log)\n\n    return log\n  }\n\n  * [Symbol.iterator] () {\n    for (const log of this.calls()) {\n      yield log\n    }\n  }\n}\n\nmodule.exports.MockCallHistory = MockCallHistory\nmodule.exports.MockCallHistoryLog = MockCallHistoryLog\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6750, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-pool.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('node:util')\nconst Pool = require('../dispatcher/pool')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,SAAS,EAAE;AACnB,MAAM;AACN,MAAM,EAAE,iBAAiB,EAAE;AAC3B,MAAM,EACJ,WAAW,EACX,UAAU,EACV,MAAM,EACN,cAAc,EACd,OAAO,EACP,iBAAiB,EACjB,UAAU,EACV,oBAAoB,EACrB;AACD,MAAM,EAAE,eAAe,EAAE;AACzB,MAAM;AACN,MAAM,EAAE,oBAAoB,EAAE;AAE9B;;CAEC,GACD,MAAM,iBAAiB;IACrB,YAAa,MAAM,EAAE,IAAI,CAAE;QACzB,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,QAAQ,KAAK,YAAY;YACrE,MAAM,IAAI,qBAAqB;QACjC;QAEA,KAAK,CAAC,QAAQ;QAEd,IAAI,CAAC,WAAW,GAAG,KAAK,KAAK;QAC7B,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,qBAAqB,GAAG,KAAK,mBAAmB,IAAI;QACzD,IAAI,CAAC,YAAY,GAAG,EAAE;QACtB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAAQ;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI;QAE3C,IAAI,CAAC,QAAQ,GAAG,kBAAkB,IAAI,CAAC,IAAI;QAC3C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO;IAC3B;IAEA,IAAI,CAAC,QAAQ,UAAU,CAAC,GAAI;QAC1B,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA;;GAEC,GACD,UAAW,IAAI,EAAE;QACf,OAAO,IAAI,gBACT,QAAQ;YAAE,qBAAqB,IAAI,CAAC,qBAAqB;YAAE,GAAG,IAAI;QAAC,GACnE,IAAI,CAAC,YAAY;IAErB;IAEA,aAAc;QACZ,IAAI,CAAC,YAAY,GAAG,EAAE;IACxB;IAEA,MAAM,CAAC,OAAO,GAAI;QAChB,MAAM,UAAU,IAAI,CAAC,eAAe;QACpC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ;IACzD;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6800, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"],"sourcesContent":["'use strict'\n\nconst { Transform } = require('node:stream')\nconst { Console } = require('node:console')\n\nconst PERSISTENT = process.versions.icu ? '' : 'Y '\nconst NOT_PERSISTENT = process.versions.icu ? '' : 'N '\n\n/**\n * Gets the output of `console.table()` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,SAAS,EAAE;AACnB,MAAM,EAAE,OAAO,EAAE;AAEjB,MAAM,aAAa,QAAQ,QAAQ,CAAC,GAAG,GAAG,MAAM;AAChD,MAAM,iBAAiB,QAAQ,QAAQ,CAAC,GAAG,GAAG,MAAM;AAEpD;;CAEC,GACD,OAAO,OAAO,GAAG,MAAM;IACrB,YAAa,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC,CAAE;QACnC,IAAI,CAAC,SAAS,GAAG,IAAI,UAAU;YAC7B,WAAW,KAAK,EAAE,IAAI,EAAE,EAAE;gBACxB,GAAG,MAAM;YACX;QACF;QAEA,IAAI,CAAC,MAAM,GAAG,IAAI,QAAQ;YACxB,QAAQ,IAAI,CAAC,SAAS;YACtB,gBAAgB;gBACd,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,GAAG,CAAC,EAAE;YAC3C;QACF;IACF;IAEA,OAAQ,mBAAmB,EAAE;QAC3B,MAAM,oBAAoB,oBAAoB,GAAG,CAC/C,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,YAAY,EAAE,MAAM,EAAE,GAAK,CAAC;gBACjF,QAAQ;gBACR,QAAQ;gBACR,MAAM;gBACN,eAAe;gBACf,YAAY,UAAU,aAAa;gBACnC,aAAa;gBACb,WAAW,UAAU,WAAW,QAAQ;YAC1C,CAAC;QAEH,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;QAClB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,QAAQ;IACvC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6838, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/mock-agent.js"],"sourcesContent":["'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../dispatcher/agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory,\n  kMockAgentRegisterCallHistory,\n  kMockAgentIsCallHistoryEnabled,\n  kMockAgentAddCallHistoryLog,\n  kMockAgentMockCallHistoryInstance,\n  kMockAgentAcceptsNonStandardSearchParameters,\n  kMockCallHistoryAddLog,\n  kIgnoreTrailingSlash\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, normalizeSearchParams, buildAndValidateMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher/dispatcher')\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter')\nconst { MockCallHistory } = require('./mock-call-history')\n\nclass MockAgent extends Dispatcher {\n  constructor (opts = {}) {\n    super(opts)\n\n    const mockOptions = buildAndValidateMockOptions(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n    this[kMockAgentIsCallHistoryEnabled] = mockOptions.enableCallHistory ?? false\n    this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions.acceptNonStandardSearchParameters ?? false\n    this[kIgnoreTrailingSlash] = mockOptions.ignoreTrailingSlash ?? false\n\n    // Instantiate Agent and encapsulate\n    if (opts?.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = mockOptions\n\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      this[kMockAgentRegisterCallHistory]()\n    }\n  }\n\n  get (origin) {\n    const originKey = this[kIgnoreTrailingSlash]\n      ? origin.replace(/\\/$/, '')\n      : origin\n\n    let dispatcher = this[kMockAgentGet](originKey)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](originKey)\n      this[kMockAgentSet](originKey, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n\n    this[kMockAgentAddCallHistoryLog](opts)\n\n    const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters]\n\n    const dispatchOpts = { ...opts }\n\n    if (acceptNonStandardSearchParameters && dispatchOpts.path) {\n      const [path, searchParams] = dispatchOpts.path.split('?')\n      const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters)\n      dispatchOpts.path = `${path}?${normalizedSearchParams}`\n    }\n\n    return this[kAgent].dispatch(dispatchOpts, handler)\n  }\n\n  async close () {\n    this.clearCallHistory()\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  enableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = true\n\n    return this\n  }\n\n  disableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = false\n\n    return this\n  }\n\n  getCallHistory () {\n    return this[kMockAgentMockCallHistoryInstance]\n  }\n\n  clearCallHistory () {\n    if (this[kMockAgentMockCallHistoryInstance] !== undefined) {\n      this[kMockAgentMockCallHistoryInstance].clear()\n    }\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentRegisterCallHistory] () {\n    if (this[kMockAgentMockCallHistoryInstance] === undefined) {\n      this[kMockAgentMockCallHistoryInstance] = new MockCallHistory()\n    }\n  }\n\n  [kMockAgentAddCallHistoryLog] (opts) {\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      // additional setup when enableCallHistory class method is used after mockAgent instantiation\n      this[kMockAgentRegisterCallHistory]()\n\n      // add call history log on every call (intercepted or not)\n      this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts)\n    }\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, { count: 0, dispatcher })\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const result = this[kClients].get(origin)\n    if (result?.dispatcher) {\n      return result.dispatcher\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, result] of Array.from(this[kClients])) {\n      if (result && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = result.dispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, result]) => result.dispatcher[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    throw new UndiciError(\n      pending.length === 1\n        ? `1 interceptor is pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n        : `${pending.length} interceptors are pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n    )\n  }\n}\n\nmodule.exports = MockAgent\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7013, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/snapshot-utils.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * @typedef {Object} HeaderFilters\n * @property {Set<string>} ignore - Set of headers to ignore for matching\n * @property {Set<string>} exclude - Set of headers to exclude from matching\n * @property {Set<string>} match - Set of headers to match (empty means match\n */\n\n/**\n * Creates cached header sets for performance\n *\n * @param {import('./snapshot-recorder').SnapshotRecorderMatchOptions} matchOptions - Matching options for headers\n * @returns {HeaderFilters} - Cached sets for ignore, exclude, and match headers\n */\nfunction createHeaderFilters (matchOptions = {}) {\n  const { ignoreHeaders = [], excludeHeaders = [], matchHeaders = [], caseSensitive = false } = matchOptions\n\n  return {\n    ignore: new Set(ignoreHeaders.map(header => caseSensitive ? header : header.toLowerCase())),\n    exclude: new Set(excludeHeaders.map(header => caseSensitive ? header : header.toLowerCase())),\n    match: new Set(matchHeaders.map(header => caseSensitive ? header : header.toLowerCase()))\n  }\n}\n\nlet crypto\ntry {\n  crypto = require('node:crypto')\n} catch { /* Fallback if crypto is not available */ }\n\n/**\n * @callback HashIdFunction\n * @param {string} value - The value to hash\n * @returns {string} - The base64url encoded hash of the value\n */\n\n/**\n * Generates a hash for a given value\n * @type {HashIdFunction}\n */\nconst hashId = crypto?.hash\n  ? (value) => crypto.hash('sha256', value, 'base64url')\n  : (value) => Buffer.from(value).toString('base64url')\n\n/**\n * @typedef {(url: string) => boolean} IsUrlExcluded Checks if a URL matches any of the exclude patterns\n */\n\n/** @typedef {{[key: Lowercase<string>]: string}} NormalizedHeaders */\n/** @typedef {Array<string>} UndiciHeaders */\n/** @typedef {Record<string, string|string[]>} Headers */\n\n/**\n * @param {*} headers\n * @returns {headers is UndiciHeaders}\n */\nfunction isUndiciHeaders (headers) {\n  return Array.isArray(headers) && (headers.length & 1) === 0\n}\n\n/**\n * Factory function to create a URL exclusion checker\n * @param {Array<string| RegExp>} [excludePatterns=[]] - Array of patterns to exclude\n * @returns {IsUrlExcluded} - A function that checks if a URL matches any of the exclude patterns\n */\nfunction isUrlExcludedFactory (excludePatterns = []) {\n  if (excludePatterns.length === 0) {\n    return () => false\n  }\n\n  return function isUrlExcluded (url) {\n    let urlLowerCased\n\n    for (const pattern of excludePatterns) {\n      if (typeof pattern === 'string') {\n        if (!urlLowerCased) {\n          // Convert URL to lowercase only once\n          urlLowerCased = url.toLowerCase()\n        }\n        // Simple string match (case-insensitive)\n        if (urlLowerCased.includes(pattern.toLowerCase())) {\n          return true\n        }\n      } else if (pattern instanceof RegExp) {\n        // Regex pattern match\n        if (pattern.test(url)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Normalizes headers for consistent comparison\n *\n * @param {Object|UndiciHeaders} headers - Headers to normalize\n * @returns {NormalizedHeaders} - Normalized headers as a lowercase object\n */\nfunction normalizeHeaders (headers) {\n  /** @type {NormalizedHeaders} */\n  const normalizedHeaders = {}\n\n  if (!headers) return normalizedHeaders\n\n  // Handle array format (undici internal format: [name, value, name, value, ...])\n  if (isUndiciHeaders(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      const key = headers[i]\n      const value = headers[i + 1]\n      if (key && value !== undefined) {\n        // Convert Buffers to strings if needed\n        const keyStr = Buffer.isBuffer(key) ? key.toString() : key\n        const valueStr = Buffer.isBuffer(value) ? value.toString() : value\n        normalizedHeaders[keyStr.toLowerCase()] = valueStr\n      }\n    }\n    return normalizedHeaders\n  }\n\n  // Handle object format\n  if (headers && typeof headers === 'object') {\n    for (const [key, value] of Object.entries(headers)) {\n      if (key && typeof key === 'string') {\n        normalizedHeaders[key.toLowerCase()] = Array.isArray(value) ? value.join(', ') : String(value)\n      }\n    }\n  }\n\n  return normalizedHeaders\n}\n\nconst validSnapshotModes = /** @type {const} */ (['record', 'playback', 'update'])\n\n/** @typedef {typeof validSnapshotModes[number]} SnapshotMode */\n\n/**\n * @param {*} mode - The snapshot mode to validate\n * @returns {asserts mode is SnapshotMode}\n */\nfunction validateSnapshotMode (mode) {\n  if (!validSnapshotModes.includes(mode)) {\n    throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be one of: ${validSnapshotModes.join(', ')}`)\n  }\n}\n\nmodule.exports = {\n  createHeaderFilters,\n  hashId,\n  isUndiciHeaders,\n  normalizeHeaders,\n  isUrlExcludedFactory,\n  validateSnapshotMode\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7139, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/snapshot-recorder.js"],"sourcesContent":["'use strict'\n\nconst { writeFile, readFile, mkdir } = require('node:fs/promises')\nconst { dirname, resolve } = require('node:path')\nconst { setTimeout, clearTimeout } = require('node:timers')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst { hashId, isUrlExcludedFactory, normalizeHeaders, createHeaderFilters } = require('./snapshot-utils')\n\n/**\n * @typedef {Object} SnapshotRequestOptions\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} path - Request path\n * @property {string} origin - Request origin (base URL)\n * @property {import('./snapshot-utils').Headers|import('./snapshot-utils').UndiciHeaders} headers - Request headers\n * @property {import('./snapshot-utils').NormalizedHeaders} _normalizedHeaders - Request headers as a lowercase object\n * @property {string|Buffer} [body] - Request body (optional)\n */\n\n/**\n * @typedef {Object} SnapshotEntryRequest\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} url - Full URL of the request\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized headers as a lowercase object\n * @property {string|Buffer} [body] - Request body (optional)\n */\n\n/**\n * @typedef {Object} SnapshotEntryResponse\n * @property {number} statusCode - HTTP status code of the response\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized response headers as a lowercase object\n * @property {string} body - Response body as a base64url encoded string\n * @property {Object} [trailers] - Optional response trailers\n */\n\n/**\n * @typedef {Object} SnapshotEntry\n * @property {SnapshotEntryRequest} request - The request object\n * @property {Array<SnapshotEntryResponse>} responses - Array of response objects\n * @property {number} callCount - Number of times this snapshot has been called\n * @property {string} timestamp - ISO timestamp of when the snapshot was created\n */\n\n/**\n * @typedef {Object} SnapshotRecorderMatchOptions\n * @property {Array<string>} [matchHeaders=[]] - Headers to match (empty array means match all headers)\n * @property {Array<string>} [ignoreHeaders=[]] - Headers to ignore for matching\n * @property {Array<string>} [excludeHeaders=[]] - Headers to exclude from matching\n * @property {boolean} [matchBody=true] - Whether to match request body\n * @property {boolean} [matchQuery=true] - Whether to match query properties\n * @property {boolean} [caseSensitive=false] - Whether header matching is case-sensitive\n */\n\n/**\n * @typedef {Object} SnapshotRecorderOptions\n * @property {string} [snapshotPath] - Path to save/load snapshots\n * @property {import('./snapshot-utils').SnapshotMode} [mode='record'] - Mode: 'record' or 'playback'\n * @property {number} [maxSnapshots=Infinity] - Maximum number of snapshots to keep\n * @property {boolean} [autoFlush=false] - Whether to automatically flush snapshots to disk\n * @property {number} [flushInterval=30000] - Auto-flush interval in milliseconds (default: 30 seconds)\n * @property {Array<string|RegExp>} [excludeUrls=[]] - URLs to exclude from recording\n * @property {function} [shouldRecord=null] - Function to filter requests for recording\n * @property {function} [shouldPlayback=null] - Function to filter requests\n */\n\n/**\n * @typedef {Object} SnapshotFormattedRequest\n * @property {string} method - HTTP method (e.g. 'GET', 'POST', etc.)\n * @property {string} url - Full URL of the request (with query parameters if matchQuery is true)\n * @property {import('./snapshot-utils').NormalizedHeaders} headers - Normalized headers as a lowercase object\n * @property {string} body - Request body (optional, only if matchBody is true)\n */\n\n/**\n * @typedef {Object} SnapshotInfo\n * @property {string} hash - Hash key for the snapshot\n * @property {SnapshotEntryRequest} request - The request object\n * @property {number} responseCount - Number of responses recorded for this request\n * @property {number} callCount - Number of times this snapshot has been called\n * @property {string} timestamp - ISO timestamp of when the snapshot was created\n */\n\n/**\n * Formats a request for consistent snapshot storage\n * Caches normalized headers to avoid repeated processing\n *\n * @param {SnapshotRequestOptions} opts - Request options\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached header sets for performance\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers and body\n * @returns {SnapshotFormattedRequest} - Formatted request object\n */\nfunction formatRequestKey (opts, headerFilters, matchOptions = {}) {\n  const url = new URL(opts.path, opts.origin)\n\n  // Cache normalized headers if not already done\n  const normalized = opts._normalizedHeaders || normalizeHeaders(opts.headers)\n  if (!opts._normalizedHeaders) {\n    opts._normalizedHeaders = normalized\n  }\n\n  return {\n    method: opts.method || 'GET',\n    url: matchOptions.matchQuery !== false ? url.toString() : `${url.origin}${url.pathname}`,\n    headers: filterHeadersForMatching(normalized, headerFilters, matchOptions),\n    body: matchOptions.matchBody !== false && opts.body ? String(opts.body) : ''\n  }\n}\n\n/**\n * Filters headers based on matching configuration\n *\n * @param {import('./snapshot-utils').Headers} headers - Headers to filter\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached sets for ignore, exclude, and match headers\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers\n */\nfunction filterHeadersForMatching (headers, headerFilters, matchOptions = {}) {\n  if (!headers || typeof headers !== 'object') return {}\n\n  const {\n    caseSensitive = false\n  } = matchOptions\n\n  const filtered = {}\n  const { ignore, exclude, match } = headerFilters\n\n  for (const [key, value] of Object.entries(headers)) {\n    const headerKey = caseSensitive ? key : key.toLowerCase()\n\n    // Skip if in exclude list (for security)\n    if (exclude.has(headerKey)) continue\n\n    // Skip if in ignore list (for matching)\n    if (ignore.has(headerKey)) continue\n\n    // If matchHeaders is specified, only include those headers\n    if (match.size !== 0) {\n      if (!match.has(headerKey)) continue\n    }\n\n    filtered[headerKey] = value\n  }\n\n  return filtered\n}\n\n/**\n * Filters headers for storage (only excludes sensitive headers)\n *\n * @param {import('./snapshot-utils').Headers} headers - Headers to filter\n * @param {import('./snapshot-utils').HeaderFilters} headerFilters - Cached sets for ignore, exclude, and match headers\n * @param {SnapshotRecorderMatchOptions} [matchOptions] - Matching options for headers\n */\nfunction filterHeadersForStorage (headers, headerFilters, matchOptions = {}) {\n  if (!headers || typeof headers !== 'object') return {}\n\n  const {\n    caseSensitive = false\n  } = matchOptions\n\n  const filtered = {}\n  const { exclude: excludeSet } = headerFilters\n\n  for (const [key, value] of Object.entries(headers)) {\n    const headerKey = caseSensitive ? key : key.toLowerCase()\n\n    // Skip if in exclude list (for security)\n    if (excludeSet.has(headerKey)) continue\n\n    filtered[headerKey] = value\n  }\n\n  return filtered\n}\n\n/**\n * Creates a hash key for request matching\n * Properly orders headers to avoid conflicts and uses crypto hashing when available\n *\n * @param {SnapshotFormattedRequest} formattedRequest - Request object\n * @returns {string} - Base64url encoded hash of the request\n */\nfunction createRequestHash (formattedRequest) {\n  const parts = [\n    formattedRequest.method,\n    formattedRequest.url\n  ]\n\n  // Process headers in a deterministic way to avoid conflicts\n  if (formattedRequest.headers && typeof formattedRequest.headers === 'object') {\n    const headerKeys = Object.keys(formattedRequest.headers).sort()\n    for (const key of headerKeys) {\n      const values = Array.isArray(formattedRequest.headers[key])\n        ? formattedRequest.headers[key]\n        : [formattedRequest.headers[key]]\n\n      // Add header name\n      parts.push(key)\n\n      // Add all values for this header, sorted for consistency\n      for (const value of values.sort()) {\n        parts.push(String(value))\n      }\n    }\n  }\n\n  // Add body\n  parts.push(formattedRequest.body)\n\n  const content = parts.join('|')\n\n  return hashId(content)\n}\n\nclass SnapshotRecorder {\n  /** @type {NodeJS.Timeout | null} */\n  #flushTimeout\n\n  /** @type {import('./snapshot-utils').IsUrlExcluded} */\n  #isUrlExcluded\n\n  /** @type {Map<string, SnapshotEntry>} */\n  #snapshots = new Map()\n\n  /** @type {string|undefined} */\n  #snapshotPath\n\n  /** @type {number} */\n  #maxSnapshots = Infinity\n\n  /** @type {boolean} */\n  #autoFlush = false\n\n  /** @type {import('./snapshot-utils').HeaderFilters} */\n  #headerFilters\n\n  /**\n   * Creates a new SnapshotRecorder instance\n   * @param {SnapshotRecorderOptions&SnapshotRecorderMatchOptions} [options={}] - Configuration options for the recorder\n   */\n  constructor (options = {}) {\n    this.#snapshotPath = options.snapshotPath\n    this.#maxSnapshots = options.maxSnapshots || Infinity\n    this.#autoFlush = options.autoFlush || false\n    this.flushInterval = options.flushInterval || 30000 // 30 seconds default\n    this._flushTimer = null\n\n    // Matching configuration\n    /** @type {Required<SnapshotRecorderMatchOptions>} */\n    this.matchOptions = {\n      matchHeaders: options.matchHeaders || [], // empty means match all headers\n      ignoreHeaders: options.ignoreHeaders || [],\n      excludeHeaders: options.excludeHeaders || [],\n      matchBody: options.matchBody !== false, // default: true\n      matchQuery: options.matchQuery !== false, // default: true\n      caseSensitive: options.caseSensitive || false\n    }\n\n    // Cache processed header sets to avoid recreating them on every request\n    this.#headerFilters = createHeaderFilters(this.matchOptions)\n\n    // Request filtering callbacks\n    this.shouldRecord = options.shouldRecord || (() => true) // function(requestOpts) -> boolean\n    this.shouldPlayback = options.shouldPlayback || (() => true) // function(requestOpts) -> boolean\n\n    // URL pattern filtering\n    this.#isUrlExcluded = isUrlExcludedFactory(options.excludeUrls) // Array of regex patterns or strings\n\n    // Start auto-flush timer if enabled\n    if (this.#autoFlush && this.#snapshotPath) {\n      this.#startAutoFlush()\n    }\n  }\n\n  /**\n   * Records a request-response interaction\n   * @param {SnapshotRequestOptions} requestOpts - Request options\n   * @param {SnapshotEntryResponse} response - Response data to record\n   * @return {Promise<void>} - Resolves when the recording is complete\n   */\n  async record (requestOpts, response) {\n    // Check if recording should be filtered out\n    if (!this.shouldRecord(requestOpts)) {\n      return // Skip recording\n    }\n\n    // Check URL exclusion patterns\n    const url = new URL(requestOpts.path, requestOpts.origin).toString()\n    if (this.#isUrlExcluded(url)) {\n      return // Skip recording\n    }\n\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n\n    // Extract response data - always store body as base64\n    const normalizedHeaders = normalizeHeaders(response.headers)\n\n    /** @type {SnapshotEntryResponse} */\n    const responseData = {\n      statusCode: response.statusCode,\n      headers: filterHeadersForStorage(normalizedHeaders, this.#headerFilters, this.matchOptions),\n      body: Buffer.isBuffer(response.body)\n        ? response.body.toString('base64')\n        : Buffer.from(String(response.body || '')).toString('base64'),\n      trailers: response.trailers\n    }\n\n    // Remove oldest snapshot if we exceed maxSnapshots limit\n    if (this.#snapshots.size >= this.#maxSnapshots && !this.#snapshots.has(hash)) {\n      const oldestKey = this.#snapshots.keys().next().value\n      this.#snapshots.delete(oldestKey)\n    }\n\n    // Support sequential responses - if snapshot exists, add to responses array\n    const existingSnapshot = this.#snapshots.get(hash)\n    if (existingSnapshot && existingSnapshot.responses) {\n      existingSnapshot.responses.push(responseData)\n      existingSnapshot.timestamp = new Date().toISOString()\n    } else {\n      this.#snapshots.set(hash, {\n        request,\n        responses: [responseData], // Always store as array for consistency\n        callCount: 0,\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    // Auto-flush if enabled\n    if (this.#autoFlush && this.#snapshotPath) {\n      this.#scheduleFlush()\n    }\n  }\n\n  /**\n   * Finds a matching snapshot for the given request\n   * Returns the appropriate response based on call count for sequential responses\n   *\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {SnapshotEntry&Record<'response', SnapshotEntryResponse>|undefined} - Matching snapshot response or undefined if not found\n   */\n  findSnapshot (requestOpts) {\n    // Check if playback should be filtered out\n    if (!this.shouldPlayback(requestOpts)) {\n      return undefined // Skip playback\n    }\n\n    // Check URL exclusion patterns\n    const url = new URL(requestOpts.path, requestOpts.origin).toString()\n    if (this.#isUrlExcluded(url)) {\n      return undefined // Skip playback\n    }\n\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    const snapshot = this.#snapshots.get(hash)\n\n    if (!snapshot) return undefined\n\n    // Handle sequential responses\n    const currentCallCount = snapshot.callCount || 0\n    const responseIndex = Math.min(currentCallCount, snapshot.responses.length - 1)\n    snapshot.callCount = currentCallCount + 1\n\n    return {\n      ...snapshot,\n      response: snapshot.responses[responseIndex]\n    }\n  }\n\n  /**\n   * Loads snapshots from file\n   * @param {string} [filePath] - Optional file path to load snapshots from\n   * @return {Promise<void>} - Resolves when snapshots are loaded\n   */\n  async loadSnapshots (filePath) {\n    const path = filePath || this.#snapshotPath\n    if (!path) {\n      throw new InvalidArgumentError('Snapshot path is required')\n    }\n\n    try {\n      const data = await readFile(resolve(path), 'utf8')\n      const parsed = JSON.parse(data)\n\n      // Convert array format back to Map\n      if (Array.isArray(parsed)) {\n        this.#snapshots.clear()\n        for (const { hash, snapshot } of parsed) {\n          this.#snapshots.set(hash, snapshot)\n        }\n      } else {\n        // Legacy object format\n        this.#snapshots = new Map(Object.entries(parsed))\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // File doesn't exist yet - that's ok for recording mode\n        this.#snapshots.clear()\n      } else {\n        throw new UndiciError(`Failed to load snapshots from ${path}`, { cause: error })\n      }\n    }\n  }\n\n  /**\n   * Saves snapshots to file\n   *\n   * @param {string} [filePath] - Optional file path to save snapshots\n   * @returns {Promise<void>} - Resolves when snapshots are saved\n   */\n  async saveSnapshots (filePath) {\n    const path = filePath || this.#snapshotPath\n    if (!path) {\n      throw new InvalidArgumentError('Snapshot path is required')\n    }\n\n    const resolvedPath = resolve(path)\n\n    // Ensure directory exists\n    await mkdir(dirname(resolvedPath), { recursive: true })\n\n    // Convert Map to serializable format\n    const data = Array.from(this.#snapshots.entries()).map(([hash, snapshot]) => ({\n      hash,\n      snapshot\n    }))\n\n    await writeFile(resolvedPath, JSON.stringify(data, null, 2), { flush: true })\n  }\n\n  /**\n   * Clears all recorded snapshots\n   * @returns {void}\n   */\n  clear () {\n    this.#snapshots.clear()\n  }\n\n  /**\n   * Gets all recorded snapshots\n   * @return {Array<SnapshotEntry>} - Array of all recorded snapshots\n   */\n  getSnapshots () {\n    return Array.from(this.#snapshots.values())\n  }\n\n  /**\n   * Gets snapshot count\n   * @return {number} - Number of recorded snapshots\n   */\n  size () {\n    return this.#snapshots.size\n  }\n\n  /**\n   * Resets call counts for all snapshots (useful for test cleanup)\n   * @returns {void}\n   */\n  resetCallCounts () {\n    for (const snapshot of this.#snapshots.values()) {\n      snapshot.callCount = 0\n    }\n  }\n\n  /**\n   * Deletes a specific snapshot by request options\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {boolean} - True if snapshot was deleted, false if not found\n   */\n  deleteSnapshot (requestOpts) {\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    return this.#snapshots.delete(hash)\n  }\n\n  /**\n   * Gets information about a specific snapshot\n   * @param {SnapshotRequestOptions} requestOpts - Request options to match\n   * @returns {SnapshotInfo|null} - Snapshot information or null if not found\n   */\n  getSnapshotInfo (requestOpts) {\n    const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions)\n    const hash = createRequestHash(request)\n    const snapshot = this.#snapshots.get(hash)\n\n    if (!snapshot) return null\n\n    return {\n      hash,\n      request: snapshot.request,\n      responseCount: snapshot.responses ? snapshot.responses.length : (snapshot.response ? 1 : 0), // .response for legacy snapshots\n      callCount: snapshot.callCount || 0,\n      timestamp: snapshot.timestamp\n    }\n  }\n\n  /**\n   * Replaces all snapshots with new data (full replacement)\n   * @param {Array<{hash: string; snapshot: SnapshotEntry}>|Record<string, SnapshotEntry>} snapshotData - New snapshot data to replace existing ones\n   * @returns {void}\n   */\n  replaceSnapshots (snapshotData) {\n    this.#snapshots.clear()\n\n    if (Array.isArray(snapshotData)) {\n      for (const { hash, snapshot } of snapshotData) {\n        this.#snapshots.set(hash, snapshot)\n      }\n    } else if (snapshotData && typeof snapshotData === 'object') {\n      // Legacy object format\n      this.#snapshots = new Map(Object.entries(snapshotData))\n    }\n  }\n\n  /**\n   * Starts the auto-flush timer\n   * @returns {void}\n   */\n  #startAutoFlush () {\n    return this.#scheduleFlush()\n  }\n\n  /**\n   * Stops the auto-flush timer\n   * @returns {void}\n   */\n  #stopAutoFlush () {\n    if (this.#flushTimeout) {\n      clearTimeout(this.#flushTimeout)\n      // Ensure any pending flush is completed\n      this.saveSnapshots().catch(() => {\n      // Ignore flush errors\n      })\n      this.#flushTimeout = null\n    }\n  }\n\n  /**\n   * Schedules a flush (debounced to avoid excessive writes)\n   */\n  #scheduleFlush () {\n    this.#flushTimeout = setTimeout(() => {\n      this.saveSnapshots().catch(() => {\n        // Ignore flush errors\n      })\n      if (this.#autoFlush) {\n        this.#flushTimeout?.refresh()\n      } else {\n        this.#flushTimeout = null\n      }\n    }, 1000) // 1 second debounce\n  }\n\n  /**\n   * Cleanup method to stop timers\n   * @returns {void}\n   */\n  destroy () {\n    this.#stopAutoFlush()\n    if (this.#flushTimeout) {\n      clearTimeout(this.#flushTimeout)\n      this.#flushTimeout = null\n    }\n  }\n\n  /**\n   * Async close method that saves all recordings and performs cleanup\n   * @returns {Promise<void>}\n   */\n  async close () {\n    // Save any pending recordings if we have a snapshot path\n    if (this.#snapshotPath && this.#snapshots.size !== 0) {\n      await this.saveSnapshots()\n    }\n\n    // Perform cleanup\n    this.destroy()\n  }\n}\n\nmodule.exports = { SnapshotRecorder, formatRequestKey, createRequestHash, filterHeadersForMatching, filterHeadersForStorage, createHeaderFilters }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7608, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/mock/snapshot-agent.js"],"sourcesContent":["'use strict'\n\nconst Agent = require('../dispatcher/agent')\nconst MockAgent = require('./mock-agent')\nconst { SnapshotRecorder } = require('./snapshot-recorder')\nconst WrapHandler = require('../handler/wrap-handler')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst { validateSnapshotMode } = require('./snapshot-utils')\n\nconst kSnapshotRecorder = Symbol('kSnapshotRecorder')\nconst kSnapshotMode = Symbol('kSnapshotMode')\nconst kSnapshotPath = Symbol('kSnapshotPath')\nconst kSnapshotLoaded = Symbol('kSnapshotLoaded')\nconst kRealAgent = Symbol('kRealAgent')\n\n// Static flag to ensure warning is only emitted once per process\nlet warningEmitted = false\n\nclass SnapshotAgent extends MockAgent {\n  constructor (opts = {}) {\n    // Emit experimental warning only once\n    if (!warningEmitted) {\n      process.emitWarning(\n        'SnapshotAgent is experimental and subject to change',\n        'ExperimentalWarning'\n      )\n      warningEmitted = true\n    }\n\n    const {\n      mode = 'record',\n      snapshotPath = null,\n      ...mockAgentOpts\n    } = opts\n\n    super(mockAgentOpts)\n\n    validateSnapshotMode(mode)\n\n    // Validate snapshotPath is provided when required\n    if ((mode === 'playback' || mode === 'update') && !snapshotPath) {\n      throw new InvalidArgumentError(`snapshotPath is required when mode is '${mode}'`)\n    }\n\n    this[kSnapshotMode] = mode\n    this[kSnapshotPath] = snapshotPath\n\n    this[kSnapshotRecorder] = new SnapshotRecorder({\n      snapshotPath: this[kSnapshotPath],\n      mode: this[kSnapshotMode],\n      maxSnapshots: opts.maxSnapshots,\n      autoFlush: opts.autoFlush,\n      flushInterval: opts.flushInterval,\n      matchHeaders: opts.matchHeaders,\n      ignoreHeaders: opts.ignoreHeaders,\n      excludeHeaders: opts.excludeHeaders,\n      matchBody: opts.matchBody,\n      matchQuery: opts.matchQuery,\n      caseSensitive: opts.caseSensitive,\n      shouldRecord: opts.shouldRecord,\n      shouldPlayback: opts.shouldPlayback,\n      excludeUrls: opts.excludeUrls\n    })\n    this[kSnapshotLoaded] = false\n\n    // For recording/update mode, we need a real agent to make actual requests\n    if (this[kSnapshotMode] === 'record' || this[kSnapshotMode] === 'update') {\n      this[kRealAgent] = new Agent(opts)\n    }\n\n    // Auto-load snapshots in playback/update mode\n    if ((this[kSnapshotMode] === 'playback' || this[kSnapshotMode] === 'update') && this[kSnapshotPath]) {\n      this.loadSnapshots().catch(() => {\n        // Ignore load errors - file might not exist yet\n      })\n    }\n  }\n\n  dispatch (opts, handler) {\n    handler = WrapHandler.wrap(handler)\n    const mode = this[kSnapshotMode]\n\n    if (mode === 'playback' || mode === 'update') {\n      // Ensure snapshots are loaded\n      if (!this[kSnapshotLoaded]) {\n        // Need to load asynchronously, delegate to async version\n        return this.#asyncDispatch(opts, handler)\n      }\n\n      // Try to find existing snapshot (synchronous)\n      const snapshot = this[kSnapshotRecorder].findSnapshot(opts)\n\n      if (snapshot) {\n        // Use recorded response (synchronous)\n        return this.#replaySnapshot(snapshot, handler)\n      } else if (mode === 'update') {\n        // Make real request and record it (async required)\n        return this.#recordAndReplay(opts, handler)\n      } else {\n        // Playback mode but no snapshot found\n        const error = new UndiciError(`No snapshot found for ${opts.method || 'GET'} ${opts.path}`)\n        if (handler.onError) {\n          handler.onError(error)\n          return\n        }\n        throw error\n      }\n    } else if (mode === 'record') {\n      // Record mode - make real request and save response (async required)\n      return this.#recordAndReplay(opts, handler)\n    }\n  }\n\n  /**\n   * Async version of dispatch for when we need to load snapshots first\n   */\n  async #asyncDispatch (opts, handler) {\n    await this.loadSnapshots()\n    return this.dispatch(opts, handler)\n  }\n\n  /**\n   * Records a real request and replays the response\n   */\n  #recordAndReplay (opts, handler) {\n    const responseData = {\n      statusCode: null,\n      headers: {},\n      trailers: {},\n      body: []\n    }\n\n    const self = this // Capture 'this' context for use within nested handler callbacks\n\n    const recordingHandler = {\n      onRequestStart (controller, context) {\n        return handler.onRequestStart(controller, { ...context, history: this.history })\n      },\n\n      onRequestUpgrade (controller, statusCode, headers, socket) {\n        return handler.onRequestUpgrade(controller, statusCode, headers, socket)\n      },\n\n      onResponseStart (controller, statusCode, headers, statusMessage) {\n        responseData.statusCode = statusCode\n        responseData.headers = headers\n        return handler.onResponseStart(controller, statusCode, headers, statusMessage)\n      },\n\n      onResponseData (controller, chunk) {\n        responseData.body.push(chunk)\n        return handler.onResponseData(controller, chunk)\n      },\n\n      onResponseEnd (controller, trailers) {\n        responseData.trailers = trailers\n\n        // Record the interaction using captured 'self' context (fire and forget)\n        const responseBody = Buffer.concat(responseData.body)\n        self[kSnapshotRecorder].record(opts, {\n          statusCode: responseData.statusCode,\n          headers: responseData.headers,\n          body: responseBody,\n          trailers: responseData.trailers\n        }).then(() => {\n          handler.onResponseEnd(controller, trailers)\n        }).catch((error) => {\n          handler.onResponseError(controller, error)\n        })\n      }\n    }\n\n    // Use composed agent if available (includes interceptors), otherwise use real agent\n    const agent = this[kRealAgent]\n    return agent.dispatch(opts, recordingHandler)\n  }\n\n  /**\n   * Replays a recorded response\n   *\n   * @param {Object} snapshot - The recorded snapshot to replay.\n   * @param {Object} handler - The handler to call with the response data.\n   * @returns {void}\n   */\n  #replaySnapshot (snapshot, handler) {\n    try {\n      const { response } = snapshot\n\n      const controller = {\n        pause () { },\n        resume () { },\n        abort (reason) {\n          this.aborted = true\n          this.reason = reason\n        },\n\n        aborted: false,\n        paused: false\n      }\n\n      handler.onRequestStart(controller)\n\n      handler.onResponseStart(controller, response.statusCode, response.headers)\n\n      // Body is always stored as base64 string\n      const body = Buffer.from(response.body, 'base64')\n      handler.onResponseData(controller, body)\n\n      handler.onResponseEnd(controller, response.trailers)\n    } catch (error) {\n      handler.onError?.(error)\n    }\n  }\n\n  /**\n   * Loads snapshots from file\n   *\n   * @param {string} [filePath] - Optional file path to load snapshots from.\n   * @returns {Promise<void>} - Resolves when snapshots are loaded.\n   */\n  async loadSnapshots (filePath) {\n    await this[kSnapshotRecorder].loadSnapshots(filePath || this[kSnapshotPath])\n    this[kSnapshotLoaded] = true\n\n    // In playback mode, set up MockAgent interceptors for all snapshots\n    if (this[kSnapshotMode] === 'playback') {\n      this.#setupMockInterceptors()\n    }\n  }\n\n  /**\n   * Saves snapshots to file\n   *\n   * @param {string} [filePath] - Optional file path to save snapshots to.\n   * @returns {Promise<void>} - Resolves when snapshots are saved.\n   */\n  async saveSnapshots (filePath) {\n    return this[kSnapshotRecorder].saveSnapshots(filePath || this[kSnapshotPath])\n  }\n\n  /**\n   * Sets up MockAgent interceptors based on recorded snapshots.\n   *\n   * This method creates MockAgent interceptors for each recorded snapshot,\n   * allowing the SnapshotAgent to fall back to MockAgent's standard intercept\n   * mechanism in playback mode. Each interceptor is configured to persist\n   * (remain active for multiple requests) and responds with the recorded\n   * response data.\n   *\n   * Called automatically when loading snapshots in playback mode.\n   *\n   * @returns {void}\n   */\n  #setupMockInterceptors () {\n    for (const snapshot of this[kSnapshotRecorder].getSnapshots()) {\n      const { request, responses, response } = snapshot\n      const url = new URL(request.url)\n\n      const mockPool = this.get(url.origin)\n\n      // Handle both new format (responses array) and legacy format (response object)\n      const responseData = responses ? responses[0] : response\n      if (!responseData) continue\n\n      mockPool.intercept({\n        path: url.pathname + url.search,\n        method: request.method,\n        headers: request.headers,\n        body: request.body\n      }).reply(responseData.statusCode, responseData.body, {\n        headers: responseData.headers,\n        trailers: responseData.trailers\n      }).persist()\n    }\n  }\n\n  /**\n   * Gets the snapshot recorder\n   * @return {SnapshotRecorder} - The snapshot recorder instance\n   */\n  getRecorder () {\n    return this[kSnapshotRecorder]\n  }\n\n  /**\n   * Gets the current mode\n   * @return {import('./snapshot-utils').SnapshotMode} - The current snapshot mode\n   */\n  getMode () {\n    return this[kSnapshotMode]\n  }\n\n  /**\n   * Clears all snapshots\n   * @returns {void}\n   */\n  clearSnapshots () {\n    this[kSnapshotRecorder].clear()\n  }\n\n  /**\n   * Resets call counts for all snapshots (useful for test cleanup)\n   * @returns {void}\n   */\n  resetCallCounts () {\n    this[kSnapshotRecorder].resetCallCounts()\n  }\n\n  /**\n   * Deletes a specific snapshot by request options\n   * @param {import('./snapshot-recorder').SnapshotRequestOptions} requestOpts - Request options to identify the snapshot\n   * @return {Promise<boolean>} - Returns true if the snapshot was deleted, false if not found\n   */\n  deleteSnapshot (requestOpts) {\n    return this[kSnapshotRecorder].deleteSnapshot(requestOpts)\n  }\n\n  /**\n   * Gets information about a specific snapshot\n   * @returns {import('./snapshot-recorder').SnapshotInfo|null} - Snapshot information or null if not found\n   */\n  getSnapshotInfo (requestOpts) {\n    return this[kSnapshotRecorder].getSnapshotInfo(requestOpts)\n  }\n\n  /**\n   * Replaces all snapshots with new data (full replacement)\n   * @param {Array<{hash: string; snapshot: import('./snapshot-recorder').SnapshotEntryshotEntry}>|Record<string, import('./snapshot-recorder').SnapshotEntry>} snapshotData - New snapshot data to replace existing snapshots\n   * @returns {void}\n   */\n  replaceSnapshots (snapshotData) {\n    this[kSnapshotRecorder].replaceSnapshots(snapshotData)\n  }\n\n  /**\n   * Closes the agent, saving snapshots and cleaning up resources.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    await this[kSnapshotRecorder].close()\n    await this[kRealAgent]?.close()\n    await super.close()\n  }\n}\n\nmodule.exports = SnapshotAgent\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7892, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/global.js"],"sourcesContent":["'use strict'\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = require('./core/errors')\nconst Agent = require('./dispatcher/agent')\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\n// These are the globals that can be installed by undici.install().\n// Not exported by index.js to avoid use outside of this module.\nconst installedExports = /** @type {const} */ (\n  [\n    'fetch',\n    'Headers',\n    'Response',\n    'Request',\n    'FormData',\n    'WebSocket',\n    'CloseEvent',\n    'ErrorEvent',\n    'MessageEvent',\n    'EventSource'\n  ]\n)\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher,\n  installedExports\n}\n"],"names":[],"mappings":"AAEA,mFAAmF;AACnF,4DAA4D;AAC5D,MAAM,mBAAmB,OAAO,GAAG,CAAC;AACpC,MAAM,EAAE,oBAAoB,EAAE;AAC9B,MAAM;AAEN,IAAI,0BAA0B,WAAW;IACvC,oBAAoB,IAAI;AAC1B;AAEA,SAAS,oBAAqB,KAAK;IACjC,IAAI,CAAC,SAAS,OAAO,MAAM,QAAQ,KAAK,YAAY;QAClD,MAAM,IAAI,qBAAqB;IACjC;IACA,OAAO,cAAc,CAAC,YAAY,kBAAkB;QAClD,OAAO;QACP,UAAU;QACV,YAAY;QACZ,cAAc;IAChB;AACF;AAEA,SAAS;IACP,OAAO,UAAU,CAAC,iBAAiB;AACrC;AAEA,mEAAmE;AACnE,gEAAgE;AAChE,MAAM,mBACJ;IACE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAGH,OAAO,OAAO,GAAG;IACf;IACA;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7937, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/redirect.js"],"sourcesContent":["'use strict'\n\nconst RedirectHandler = require('../handler/redirect-handler')\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections } = {}) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections, ...rest } = opts\n\n      if (maxRedirections == null || maxRedirections === 0) {\n        return dispatch(opts, handler)\n      }\n\n      const dispatchOpts = { ...rest } // Stop sub dispatcher from also redirecting.\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler)\n      return dispatch(dispatchOpts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,SAAS,0BAA2B,EAAE,iBAAiB,sBAAsB,EAAE,GAAG,CAAC,CAAC;IAClF,OAAO,CAAC;QACN,OAAO,SAAS,UAAW,IAAI,EAAE,OAAO;YACtC,MAAM,EAAE,kBAAkB,sBAAsB,EAAE,GAAG,MAAM,GAAG;YAE9D,IAAI,mBAAmB,QAAQ,oBAAoB,GAAG;gBACpD,OAAO,SAAS,MAAM;YACxB;YAEA,MAAM,eAAe;gBAAE,GAAG,IAAI;YAAC,EAAE,6CAA6C;;YAC9E,MAAM,kBAAkB,IAAI,gBAAgB,UAAU,iBAAiB,cAAc;YACrF,OAAO,SAAS,cAAc;QAChC;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7959, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/response-error.js"],"sourcesContent":["'use strict'\n\n// const { parseHeaders } = require('../core/util')\nconst DecoratorHandler = require('../handler/decorator-handler')\nconst { ResponseError } = require('../core/errors')\n\nclass ResponseErrorHandler extends DecoratorHandler {\n  #statusCode\n  #contentType\n  #decoder\n  #headers\n  #body\n\n  constructor (_opts, { handler }) {\n    super(handler)\n  }\n\n  #checkContentType (contentType) {\n    return (this.#contentType ?? '').indexOf(contentType) === 0\n  }\n\n  onRequestStart (controller, context) {\n    this.#statusCode = 0\n    this.#contentType = null\n    this.#decoder = null\n    this.#headers = null\n    this.#body = ''\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.#statusCode = statusCode\n    this.#headers = headers\n    this.#contentType = headers['content-type']\n\n    if (this.#statusCode < 400) {\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    if (this.#checkContentType('application/json') || this.#checkContentType('text/plain')) {\n      this.#decoder = new TextDecoder('utf-8')\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#statusCode < 400) {\n      return super.onResponseData(controller, chunk)\n    }\n\n    this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? ''\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#statusCode >= 400) {\n      this.#body += this.#decoder?.decode(undefined, { stream: false }) ?? ''\n\n      if (this.#checkContentType('application/json')) {\n        try {\n          this.#body = JSON.parse(this.#body)\n        } catch {\n          // Do nothing...\n        }\n      }\n\n      let err\n      const stackTraceLimit = Error.stackTraceLimit\n      Error.stackTraceLimit = 0\n      try {\n        err = new ResponseError('Response Error', this.#statusCode, {\n          body: this.#body,\n          headers: this.#headers\n        })\n      } finally {\n        Error.stackTraceLimit = stackTraceLimit\n      }\n\n      super.onResponseError(controller, err)\n    } else {\n      super.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, err) {\n    super.onResponseError(controller, err)\n  }\n}\n\nmodule.exports = () => {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      return dispatch(opts, new ResponseErrorHandler(opts, { handler }))\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,mDAAmD;AACnD,MAAM;AACN,MAAM,EAAE,aAAa,EAAE;AAEvB,MAAM,6BAA6B;IACjC,CAAA,UAAW,CAAA;IACX,CAAA,WAAY,CAAA;IACZ,CAAA,OAAQ,CAAA;IACR,CAAA,OAAQ,CAAA;IACR,CAAA,IAAK,CAAA;IAEL,YAAa,KAAK,EAAE,EAAE,OAAO,EAAE,CAAE;QAC/B,KAAK,CAAC;IACR;IAEA,CAAA,gBAAiB,CAAE,WAAW;QAC5B,OAAO,CAAC,IAAI,CAAC,CAAA,WAAY,IAAI,EAAE,EAAE,OAAO,CAAC,iBAAiB;IAC5D;IAEA,eAAgB,UAAU,EAAE,OAAO,EAAE;QACnC,IAAI,CAAC,CAAA,UAAW,GAAG;QACnB,IAAI,CAAC,CAAA,WAAY,GAAG;QACpB,IAAI,CAAC,CAAA,OAAQ,GAAG;QAChB,IAAI,CAAC,CAAA,OAAQ,GAAG;QAChB,IAAI,CAAC,CAAA,IAAK,GAAG;QAEb,OAAO,KAAK,CAAC,eAAe,YAAY;IAC1C;IAEA,gBAAiB,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,aAAa,EAAE;QAC/D,IAAI,CAAC,CAAA,UAAW,GAAG;QACnB,IAAI,CAAC,CAAA,OAAQ,GAAG;QAChB,IAAI,CAAC,CAAA,WAAY,GAAG,OAAO,CAAC,eAAe;QAE3C,IAAI,IAAI,CAAC,CAAA,UAAW,GAAG,KAAK;YAC1B,OAAO,KAAK,CAAC,gBAAgB,YAAY,YAAY,SAAS;QAChE;QAEA,IAAI,IAAI,CAAC,CAAA,gBAAiB,CAAC,uBAAuB,IAAI,CAAC,CAAA,gBAAiB,CAAC,eAAe;YACtF,IAAI,CAAC,CAAA,OAAQ,GAAG,IAAI,YAAY;QAClC;IACF;IAEA,eAAgB,UAAU,EAAE,KAAK,EAAE;QACjC,IAAI,IAAI,CAAC,CAAA,UAAW,GAAG,KAAK;YAC1B,OAAO,KAAK,CAAC,eAAe,YAAY;QAC1C;QAEA,IAAI,CAAC,CAAA,IAAK,IAAI,IAAI,CAAC,CAAA,OAAQ,EAAE,OAAO,OAAO;YAAE,QAAQ;QAAK,MAAM;IAClE;IAEA,cAAe,UAAU,EAAE,QAAQ,EAAE;QACnC,IAAI,IAAI,CAAC,CAAA,UAAW,IAAI,KAAK;YAC3B,IAAI,CAAC,CAAA,IAAK,IAAI,IAAI,CAAC,CAAA,OAAQ,EAAE,OAAO,WAAW;gBAAE,QAAQ;YAAM,MAAM;YAErE,IAAI,IAAI,CAAC,CAAA,gBAAiB,CAAC,qBAAqB;gBAC9C,IAAI;oBACF,IAAI,CAAC,CAAA,IAAK,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,CAAA,IAAK;gBACpC,EAAE,OAAM;gBACN,gBAAgB;gBAClB;YACF;YAEA,IAAI;YACJ,MAAM,kBAAkB,MAAM,eAAe;YAC7C,MAAM,eAAe,GAAG;YACxB,IAAI;gBACF,MAAM,IAAI,cAAc,kBAAkB,IAAI,CAAC,CAAA,UAAW,EAAE;oBAC1D,MAAM,IAAI,CAAC,CAAA,IAAK;oBAChB,SAAS,IAAI,CAAC,CAAA,OAAQ;gBACxB;YACF,SAAU;gBACR,MAAM,eAAe,GAAG;YAC1B;YAEA,KAAK,CAAC,gBAAgB,YAAY;QACpC,OAAO;YACL,KAAK,CAAC,cAAc,YAAY;QAClC;IACF;IAEA,gBAAiB,UAAU,EAAE,GAAG,EAAE;QAChC,KAAK,CAAC,gBAAgB,YAAY;IACpC;AACF;AAEA,OAAO,OAAO,GAAG;IACf,OAAO,CAAC;QACN,OAAO,SAAS,UAAW,IAAI,EAAE,OAAO;YACtC,OAAO,SAAS,MAAM,IAAI,qBAAqB,MAAM;gBAAE;YAAQ;QACjE;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8046, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/retry.js"],"sourcesContent":["'use strict'\nconst RetryHandler = require('../handler/retry-handler')\n\nmodule.exports = globalOpts => {\n  return dispatch => {\n    return function retryInterceptor (opts, handler) {\n      return dispatch(\n        opts,\n        new RetryHandler(\n          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },\n          {\n            handler,\n            dispatch\n          }\n        )\n      )\n    }\n  }\n}\n"],"names":[],"mappings":"AACA,MAAM;AAEN,OAAO,OAAO,GAAG,CAAA;IACf,OAAO,CAAA;QACL,OAAO,SAAS,iBAAkB,IAAI,EAAE,OAAO;YAC7C,OAAO,SACL,MACA,IAAI,aACF;gBAAE,GAAG,IAAI;gBAAE,cAAc;oBAAE,GAAG,UAAU;oBAAE,GAAG,KAAK,YAAY;gBAAC;YAAE,GACjE;gBACE;gBACA;YACF;QAGN;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8067, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/dump.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, RequestAbortedError } = require('../core/errors')\nconst DecoratorHandler = require('../handler/decorator-handler')\n\nclass DumpHandler extends DecoratorHandler {\n  #maxSize = 1024 * 1024\n  #dumped = false\n  #size = 0\n  #controller = null\n  aborted = false\n  reason = false\n\n  constructor ({ maxSize, signal }, handler) {\n    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n      throw new InvalidArgumentError('maxSize must be a number greater than 0')\n    }\n\n    super(handler)\n\n    this.#maxSize = maxSize ?? this.#maxSize\n    // this.#handler = handler\n  }\n\n  #abort (reason) {\n    this.aborted = true\n    this.reason = reason\n  }\n\n  onRequestStart (controller, context) {\n    controller.abort = this.#abort.bind(this)\n    this.#controller = controller\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const contentLength = headers['content-length']\n\n    if (contentLength != null && contentLength > this.#maxSize) {\n      throw new RequestAbortedError(\n        `Response size (${contentLength}) larger than maxSize (${\n          this.#maxSize\n        })`\n      )\n    }\n\n    if (this.aborted === true) {\n      return true\n    }\n\n    return super.onResponseStart(controller, statusCode, headers, statusMessage)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#dumped) {\n      return\n    }\n\n    // On network errors before connect, controller will be null\n    err = this.#controller?.reason ?? err\n\n    super.onResponseError(controller, err)\n  }\n\n  onResponseData (controller, chunk) {\n    this.#size = this.#size + chunk.length\n\n    if (this.#size >= this.#maxSize) {\n      this.#dumped = true\n\n      if (this.aborted === true) {\n        super.onResponseError(controller, this.reason)\n      } else {\n        super.onResponseEnd(controller, {})\n      }\n    }\n\n    return true\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#dumped) {\n      return\n    }\n\n    if (this.#controller.aborted === true) {\n      super.onResponseError(controller, this.reason)\n      return\n    }\n\n    super.onResponseEnd(controller, trailers)\n  }\n}\n\nfunction createDumpInterceptor (\n  { maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n  }\n) {\n  return dispatch => {\n    return function Intercept (opts, handler) {\n      const { dumpMaxSize = defaultMaxSize } = opts\n\n      const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler)\n\n      return dispatch(opts, dumpHandler)\n    }\n  }\n}\n\nmodule.exports = createDumpInterceptor\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8153, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/dns.js"],"sourcesContent":["'use strict'\nconst { isIP } = require('node:net')\nconst { lookup } = require('node:dns')\nconst DecoratorHandler = require('../handler/decorator-handler')\nconst { InvalidArgumentError, InformationalError } = require('../core/errors')\nconst maxInt = Math.pow(2, 31) - 1\n\nclass DNSInstance {\n  #maxTTL = 0\n  #maxItems = 0\n  #records = new Map()\n  dualStack = true\n  affinity = null\n  lookup = null\n  pick = null\n\n  constructor (opts) {\n    this.#maxTTL = opts.maxTTL\n    this.#maxItems = opts.maxItems\n    this.dualStack = opts.dualStack\n    this.affinity = opts.affinity\n    this.lookup = opts.lookup ?? this.#defaultLookup\n    this.pick = opts.pick ?? this.#defaultPick\n  }\n\n  get full () {\n    return this.#records.size === this.#maxItems\n  }\n\n  runLookup (origin, opts, cb) {\n    const ips = this.#records.get(origin.hostname)\n\n    // If full, we just return the origin\n    if (ips == null && this.full) {\n      cb(null, origin)\n      return\n    }\n\n    const newOpts = {\n      affinity: this.affinity,\n      dualStack: this.dualStack,\n      lookup: this.lookup,\n      pick: this.pick,\n      ...opts.dns,\n      maxTTL: this.#maxTTL,\n      maxItems: this.#maxItems\n    }\n\n    // If no IPs we lookup\n    if (ips == null) {\n      this.lookup(origin, newOpts, (err, addresses) => {\n        if (err || addresses == null || addresses.length === 0) {\n          cb(err ?? new InformationalError('No DNS entries found'))\n          return\n        }\n\n        this.setRecords(origin, addresses)\n        const records = this.#records.get(origin.hostname)\n\n        const ip = this.pick(\n          origin,\n          records,\n          newOpts.affinity\n        )\n\n        let port\n        if (typeof ip.port === 'number') {\n          port = `:${ip.port}`\n        } else if (origin.port !== '') {\n          port = `:${origin.port}`\n        } else {\n          port = ''\n        }\n\n        cb(\n          null,\n          new URL(`${origin.protocol}//${\n            ip.family === 6 ? `[${ip.address}]` : ip.address\n          }${port}`)\n        )\n      })\n    } else {\n      // If there's IPs we pick\n      const ip = this.pick(\n        origin,\n        ips,\n        newOpts.affinity\n      )\n\n      // If no IPs we lookup - deleting old records\n      if (ip == null) {\n        this.#records.delete(origin.hostname)\n        this.runLookup(origin, opts, cb)\n        return\n      }\n\n      let port\n      if (typeof ip.port === 'number') {\n        port = `:${ip.port}`\n      } else if (origin.port !== '') {\n        port = `:${origin.port}`\n      } else {\n        port = ''\n      }\n\n      cb(\n        null,\n        new URL(`${origin.protocol}//${\n          ip.family === 6 ? `[${ip.address}]` : ip.address\n        }${port}`)\n      )\n    }\n  }\n\n  #defaultLookup (origin, opts, cb) {\n    lookup(\n      origin.hostname,\n      {\n        all: true,\n        family: this.dualStack === false ? this.affinity : 0,\n        order: 'ipv4first'\n      },\n      (err, addresses) => {\n        if (err) {\n          return cb(err)\n        }\n\n        const results = new Map()\n\n        for (const addr of addresses) {\n          // On linux we found duplicates, we attempt to remove them with\n          // the latest record\n          results.set(`${addr.address}:${addr.family}`, addr)\n        }\n\n        cb(null, results.values())\n      }\n    )\n  }\n\n  #defaultPick (origin, hostnameRecords, affinity) {\n    let ip = null\n    const { records, offset } = hostnameRecords\n\n    let family\n    if (this.dualStack) {\n      if (affinity == null) {\n        // Balance between ip families\n        if (offset == null || offset === maxInt) {\n          hostnameRecords.offset = 0\n          affinity = 4\n        } else {\n          hostnameRecords.offset++\n          affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4\n        }\n      }\n\n      if (records[affinity] != null && records[affinity].ips.length > 0) {\n        family = records[affinity]\n      } else {\n        family = records[affinity === 4 ? 6 : 4]\n      }\n    } else {\n      family = records[affinity]\n    }\n\n    // If no IPs we return null\n    if (family == null || family.ips.length === 0) {\n      return ip\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    ip = family.ips[position] ?? null\n\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n      return this.pick(origin, hostnameRecords, affinity)\n    }\n\n    return ip\n  }\n\n  pickFamily (origin, ipFamily) {\n    const records = this.#records.get(origin.hostname)?.records\n    if (!records) {\n      return null\n    }\n\n    const family = records[ipFamily]\n    if (!family) {\n      return null\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    const ip = family.ips[position] ?? null\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n    }\n\n    return ip\n  }\n\n  setRecords (origin, addresses) {\n    const timestamp = Date.now()\n    const records = { records: { 4: null, 6: null } }\n    for (const record of addresses) {\n      record.timestamp = timestamp\n      if (typeof record.ttl === 'number') {\n        // The record TTL is expected to be in ms\n        record.ttl = Math.min(record.ttl, this.#maxTTL)\n      } else {\n        record.ttl = this.#maxTTL\n      }\n\n      const familyRecords = records.records[record.family] ?? { ips: [] }\n\n      familyRecords.ips.push(record)\n      records.records[record.family] = familyRecords\n    }\n\n    this.#records.set(origin.hostname, records)\n  }\n\n  deleteRecords (origin) {\n    this.#records.delete(origin.hostname)\n  }\n\n  getHandler (meta, opts) {\n    return new DNSDispatchHandler(this, meta, opts)\n  }\n}\n\nclass DNSDispatchHandler extends DecoratorHandler {\n  #state = null\n  #opts = null\n  #dispatch = null\n  #origin = null\n  #controller = null\n  #newOrigin = null\n  #firstTry = true\n\n  constructor (state, { origin, handler, dispatch, newOrigin }, opts) {\n    super(handler)\n    this.#origin = origin\n    this.#newOrigin = newOrigin\n    this.#opts = { ...opts }\n    this.#state = state\n    this.#dispatch = dispatch\n  }\n\n  onResponseError (controller, err) {\n    switch (err.code) {\n      case 'ETIMEDOUT':\n      case 'ECONNREFUSED': {\n        if (this.#state.dualStack) {\n          if (!this.#firstTry) {\n            super.onResponseError(controller, err)\n            return\n          }\n          this.#firstTry = false\n\n          // Pick an ip address from the other family\n          const otherFamily = this.#newOrigin.hostname[0] === '[' ? 4 : 6\n          const ip = this.#state.pickFamily(this.#origin, otherFamily)\n          if (ip == null) {\n            super.onResponseError(controller, err)\n            return\n          }\n\n          let port\n          if (typeof ip.port === 'number') {\n            port = `:${ip.port}`\n          } else if (this.#origin.port !== '') {\n            port = `:${this.#origin.port}`\n          } else {\n            port = ''\n          }\n\n          const dispatchOpts = {\n            ...this.#opts,\n            origin: `${this.#origin.protocol}//${\n                ip.family === 6 ? `[${ip.address}]` : ip.address\n              }${port}`\n          }\n          this.#dispatch(dispatchOpts, this)\n          return\n        }\n\n        // if dual-stack disabled, we error out\n        super.onResponseError(controller, err)\n        break\n      }\n      case 'ENOTFOUND':\n        this.#state.deleteRecords(this.#origin)\n        super.onResponseError(controller, err)\n        break\n      default:\n        super.onResponseError(controller, err)\n        break\n    }\n  }\n}\n\nmodule.exports = interceptorOpts => {\n  if (\n    interceptorOpts?.maxTTL != null &&\n    (typeof interceptorOpts?.maxTTL !== 'number' || interceptorOpts?.maxTTL < 0)\n  ) {\n    throw new InvalidArgumentError('Invalid maxTTL. Must be a positive number')\n  }\n\n  if (\n    interceptorOpts?.maxItems != null &&\n    (typeof interceptorOpts?.maxItems !== 'number' ||\n      interceptorOpts?.maxItems < 1)\n  ) {\n    throw new InvalidArgumentError(\n      'Invalid maxItems. Must be a positive number and greater than zero'\n    )\n  }\n\n  if (\n    interceptorOpts?.affinity != null &&\n    interceptorOpts?.affinity !== 4 &&\n    interceptorOpts?.affinity !== 6\n  ) {\n    throw new InvalidArgumentError('Invalid affinity. Must be either 4 or 6')\n  }\n\n  if (\n    interceptorOpts?.dualStack != null &&\n    typeof interceptorOpts?.dualStack !== 'boolean'\n  ) {\n    throw new InvalidArgumentError('Invalid dualStack. Must be a boolean')\n  }\n\n  if (\n    interceptorOpts?.lookup != null &&\n    typeof interceptorOpts?.lookup !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid lookup. Must be a function')\n  }\n\n  if (\n    interceptorOpts?.pick != null &&\n    typeof interceptorOpts?.pick !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid pick. Must be a function')\n  }\n\n  const dualStack = interceptorOpts?.dualStack ?? true\n  let affinity\n  if (dualStack) {\n    affinity = interceptorOpts?.affinity ?? null\n  } else {\n    affinity = interceptorOpts?.affinity ?? 4\n  }\n\n  const opts = {\n    maxTTL: interceptorOpts?.maxTTL ?? 10e3, // Expressed in ms\n    lookup: interceptorOpts?.lookup ?? null,\n    pick: interceptorOpts?.pick ?? null,\n    dualStack,\n    affinity,\n    maxItems: interceptorOpts?.maxItems ?? Infinity\n  }\n\n  const instance = new DNSInstance(opts)\n\n  return dispatch => {\n    return function dnsInterceptor (origDispatchOpts, handler) {\n      const origin =\n        origDispatchOpts.origin.constructor === URL\n          ? origDispatchOpts.origin\n          : new URL(origDispatchOpts.origin)\n\n      if (isIP(origin.hostname) !== 0) {\n        return dispatch(origDispatchOpts, handler)\n      }\n\n      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {\n        if (err) {\n          return handler.onResponseError(null, err)\n        }\n\n        const dispatchOpts = {\n          ...origDispatchOpts,\n          servername: origin.hostname, // For SNI on TLS\n          origin: newOrigin.origin,\n          headers: {\n            host: origin.host,\n            ...origDispatchOpts.headers\n          }\n        }\n\n        dispatch(\n          dispatchOpts,\n          instance.getHandler(\n            { origin, dispatch, handler, newOrigin },\n            origDispatchOpts\n          )\n        )\n      })\n\n      return true\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8487, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/cache.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('node:stream')\nconst util = require('../core/util')\nconst CacheHandler = require('../handler/cache-handler')\nconst MemoryCacheStore = require('../cache/memory-cache-store')\nconst CacheRevalidationHandler = require('../handler/cache-revalidation-handler')\nconst { assertCacheStore, assertCacheMethods, makeCacheKey, normalizeHeaders, parseCacheControlHeader } = require('../util/cache.js')\nconst { AbortError } = require('../core/errors.js')\n\n/**\n * @typedef {(options: import('../../types/dispatcher.d.ts').default.DispatchOptions, handler: import('../../types/dispatcher.d.ts').default.DispatchHandler) => void} DispatchFn\n */\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} cacheControlDirectives\n * @returns {boolean}\n */\nfunction needsRevalidation (result, cacheControlDirectives) {\n  if (cacheControlDirectives?.['no-cache']) {\n    // Always revalidate requests with the no-cache request directive\n    return true\n  }\n\n  if (result.cacheControlDirectives?.['no-cache'] && !Array.isArray(result.cacheControlDirectives['no-cache'])) {\n    // Always revalidate requests with unqualified no-cache response directive\n    return true\n  }\n\n  const now = Date.now()\n  if (now > result.staleAt) {\n    // Response is stale\n    if (cacheControlDirectives?.['max-stale']) {\n      // There's a threshold where we can serve stale responses, let's see if\n      //  we're in it\n      // https://www.rfc-editor.org/rfc/rfc9111.html#name-max-stale\n      const gracePeriod = result.staleAt + (cacheControlDirectives['max-stale'] * 1000)\n      return now > gracePeriod\n    }\n\n    return true\n  }\n\n  if (cacheControlDirectives?.['min-fresh']) {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.3\n\n    // At this point, staleAt is always > now\n    const timeLeftTillStale = result.staleAt - now\n    const threshold = cacheControlDirectives['min-fresh'] * 1000\n\n    return timeLeftTillStale <= threshold\n  }\n\n  return false\n}\n\n/**\n * Check if we're within the stale-while-revalidate window for a stale response\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @returns {boolean}\n */\nfunction withinStaleWhileRevalidateWindow (result) {\n  const staleWhileRevalidate = result.cacheControlDirectives?.['stale-while-revalidate']\n  if (!staleWhileRevalidate) {\n    return false\n  }\n\n  const now = Date.now()\n  const staleWhileRevalidateExpiry = result.staleAt + (staleWhileRevalidate * 1000)\n  return now <= staleWhileRevalidateExpiry\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n */\nfunction handleUncachedResponse (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl\n) {\n  if (reqCacheControl?.['only-if-cached']) {\n    let aborted = false\n    try {\n      if (typeof handler.onConnect === 'function') {\n        handler.onConnect(() => {\n          aborted = true\n        })\n\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onHeaders === 'function') {\n        handler.onHeaders(504, [], () => {}, 'Gateway Timeout')\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onComplete === 'function') {\n        handler.onComplete([])\n      }\n    } catch (err) {\n      if (typeof handler.onError === 'function') {\n        handler.onError(err)\n      }\n    }\n\n    return true\n  }\n\n  return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n}\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {number} age\n * @param {any} context\n * @param {boolean} isStale\n */\nfunction sendCachedValue (handler, opts, result, age, context, isStale) {\n  // TODO (perf): Readable.from path can be optimized...\n  const stream = util.isStream(result.body)\n    ? result.body\n    : Readable.from(result.body ?? [])\n\n  assert(!stream.destroyed, 'stream should not be destroyed')\n  assert(!stream.readableDidRead, 'stream should not be readableDidRead')\n\n  const controller = {\n    resume () {\n      stream.resume()\n    },\n    pause () {\n      stream.pause()\n    },\n    get paused () {\n      return stream.isPaused()\n    },\n    get aborted () {\n      return stream.destroyed\n    },\n    get reason () {\n      return stream.errored\n    },\n    abort (reason) {\n      stream.destroy(reason ?? new AbortError())\n    }\n  }\n\n  stream\n    .on('error', function (err) {\n      if (!this.readableEnded) {\n        if (typeof handler.onResponseError === 'function') {\n          handler.onResponseError(controller, err)\n        } else {\n          throw err\n        }\n      }\n    })\n    .on('close', function () {\n      if (!this.errored) {\n        handler.onResponseEnd?.(controller, {})\n      }\n    })\n\n  handler.onRequestStart?.(controller, context)\n\n  if (stream.destroyed) {\n    return\n  }\n\n  // Add the age header\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-age\n  const headers = { ...result.headers, age: String(age) }\n\n  if (isStale) {\n    // Add warning header\n    //  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning\n    headers.warning = '110 - \"response is stale\"'\n  }\n\n  handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage)\n\n  if (opts.method === 'HEAD') {\n    stream.destroy()\n  } else {\n    stream.on('data', function (chunk) {\n      handler.onResponseData?.(controller, chunk)\n    })\n  }\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined} result\n */\nfunction handleResult (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl,\n  result\n) {\n  if (!result) {\n    return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl)\n  }\n\n  const now = Date.now()\n  if (now > result.deleteAt) {\n    // Response is expired, cache store shouldn't have given this to us\n    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n  }\n\n  const age = Math.round((now - result.cachedAt) / 1000)\n  if (reqCacheControl?.['max-age'] && age >= reqCacheControl['max-age']) {\n    // Response is considered expired for this specific request\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.1\n    return dispatch(opts, handler)\n  }\n\n  // Check if the response is stale\n  if (needsRevalidation(result, reqCacheControl)) {\n    if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {\n      // If body is a stream we can't revalidate...\n      // TODO (fix): This could be less strict...\n      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n    }\n\n    // RFC 5861: If we're within stale-while-revalidate window, serve stale immediately\n    // and revalidate in background\n    if (withinStaleWhileRevalidateWindow(result)) {\n      // Serve stale response immediately\n      sendCachedValue(handler, opts, result, age, null, true)\n\n      // Start background revalidation (fire-and-forget)\n      queueMicrotask(() => {\n        let headers = {\n          ...opts.headers,\n          'if-modified-since': new Date(result.cachedAt).toUTCString()\n        }\n\n        if (result.etag) {\n          headers['if-none-match'] = result.etag\n        }\n\n        if (result.vary) {\n          headers = {\n            ...headers,\n            ...result.vary\n          }\n        }\n\n        // Background revalidation - update cache if we get new data\n        dispatch(\n          {\n            ...opts,\n            headers\n          },\n          new CacheHandler(globalOpts, cacheKey, {\n            // Silent handler that just updates the cache\n            onRequestStart () {},\n            onRequestUpgrade () {},\n            onResponseStart () {},\n            onResponseData () {},\n            onResponseEnd () {},\n            onResponseError () {}\n          })\n        )\n      })\n\n      return true\n    }\n\n    let withinStaleIfErrorThreshold = false\n    const staleIfErrorExpiry = result.cacheControlDirectives['stale-if-error'] ?? reqCacheControl?.['stale-if-error']\n    if (staleIfErrorExpiry) {\n      withinStaleIfErrorThreshold = now < (result.staleAt + (staleIfErrorExpiry * 1000))\n    }\n\n    let headers = {\n      ...opts.headers,\n      'if-modified-since': new Date(result.cachedAt).toUTCString()\n    }\n\n    if (result.etag) {\n      headers['if-none-match'] = result.etag\n    }\n\n    if (result.vary) {\n      headers = {\n        ...headers,\n        ...result.vary\n      }\n    }\n\n    // We need to revalidate the response\n    return dispatch(\n      {\n        ...opts,\n        headers\n      },\n      new CacheRevalidationHandler(\n        (success, context) => {\n          if (success) {\n            sendCachedValue(handler, opts, result, age, context, true)\n          } else if (util.isStream(result.body)) {\n            result.body.on('error', () => {}).destroy()\n          }\n        },\n        new CacheHandler(globalOpts, cacheKey, handler),\n        withinStaleIfErrorThreshold\n      )\n    )\n  }\n\n  // Dump request body.\n  if (util.isStream(opts.body)) {\n    opts.body.on('error', () => {}).destroy()\n  }\n\n  sendCachedValue(handler, opts, result, age, null, false)\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions} [opts]\n * @returns {import('../../types/dispatcher.d.ts').default.DispatcherComposeInterceptor}\n */\nmodule.exports = (opts = {}) => {\n  const {\n    store = new MemoryCacheStore(),\n    methods = ['GET'],\n    cacheByDefault = undefined,\n    type = 'shared'\n  } = opts\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? 'null' : typeof opts}`)\n  }\n\n  assertCacheStore(store, 'opts.store')\n  assertCacheMethods(methods, 'opts.methods')\n\n  if (typeof cacheByDefault !== 'undefined' && typeof cacheByDefault !== 'number') {\n    throw new TypeError(`expected opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`)\n  }\n\n  if (typeof type !== 'undefined' && type !== 'shared' && type !== 'private') {\n    throw new TypeError(`expected opts.type to be shared, private, or undefined, got ${typeof type}`)\n  }\n\n  const globalOpts = {\n    store,\n    methods,\n    cacheByDefault,\n    type\n  }\n\n  const safeMethodsToNotCache = util.safeHTTPMethods.filter(method => methods.includes(method) === false)\n\n  return dispatch => {\n    return (opts, handler) => {\n      if (!opts.origin || safeMethodsToNotCache.includes(opts.method)) {\n        // Not a method we want to cache or we don't have the origin, skip\n        return dispatch(opts, handler)\n      }\n\n      opts = {\n        ...opts,\n        headers: normalizeHeaders(opts)\n      }\n\n      const reqCacheControl = opts.headers?.['cache-control']\n        ? parseCacheControlHeader(opts.headers['cache-control'])\n        : undefined\n\n      if (reqCacheControl?.['no-store']) {\n        return dispatch(opts, handler)\n      }\n\n      /**\n       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n       */\n      const cacheKey = makeCacheKey(opts)\n      const result = store.get(cacheKey)\n\n      if (result && typeof result.then === 'function') {\n        result.then(result => {\n          handleResult(dispatch,\n            globalOpts,\n            cacheKey,\n            handler,\n            opts,\n            reqCacheControl,\n            result\n          )\n        })\n      } else {\n        handleResult(\n          dispatch,\n          globalOpts,\n          cacheKey,\n          handler,\n          opts,\n          reqCacheControl,\n          result\n        )\n      }\n\n      return true\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8810, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/interceptor/decompress.js"],"sourcesContent":["'use strict'\n\nconst { createInflate, createGunzip, createBrotliDecompress, createZstdDecompress } = require('node:zlib')\nconst { pipeline } = require('node:stream')\nconst DecoratorHandler = require('../handler/decorator-handler')\n\n/** @typedef {import('node:stream').Transform} Transform */\n/** @typedef {import('node:stream').Transform} Controller */\n/** @typedef {Transform&import('node:zlib').Zlib} DecompressorStream */\n\n/** @type {Record<string, () => DecompressorStream>} */\nconst supportedEncodings = {\n  gzip: createGunzip,\n  'x-gzip': createGunzip,\n  br: createBrotliDecompress,\n  deflate: createInflate,\n  compress: createInflate,\n  'x-compress': createInflate,\n  ...(createZstdDecompress ? { zstd: createZstdDecompress } : {})\n}\n\nconst defaultSkipStatusCodes = /** @type {const} */ ([204, 304])\n\nlet warningEmitted = /** @type {boolean} */ (false)\n\n/**\n * @typedef {Object} DecompressHandlerOptions\n * @property {number[]|Readonly<number[]>} [skipStatusCodes=[204, 304]] - List of status codes to skip decompression for\n * @property {boolean} [skipErrorResponses] - Whether to skip decompression for error responses (status codes >= 400)\n */\n\nclass DecompressHandler extends DecoratorHandler {\n  /** @type {Transform[]} */\n  #decompressors = []\n  /** @type {NodeJS.WritableStream&NodeJS.ReadableStream|null} */\n  #pipelineStream\n  /** @type {Readonly<number[]>} */\n  #skipStatusCodes\n  /** @type {boolean} */\n  #skipErrorResponses\n\n  constructor (handler, { skipStatusCodes = defaultSkipStatusCodes, skipErrorResponses = true } = {}) {\n    super(handler)\n    this.#skipStatusCodes = skipStatusCodes\n    this.#skipErrorResponses = skipErrorResponses\n  }\n\n  /**\n   * Determines if decompression should be skipped based on encoding and status code\n   * @param {string} contentEncoding - Content-Encoding header value\n   * @param {number} statusCode - HTTP status code of the response\n   * @returns {boolean} - True if decompression should be skipped\n   */\n  #shouldSkipDecompression (contentEncoding, statusCode) {\n    if (!contentEncoding || statusCode < 200) return true\n    if (this.#skipStatusCodes.includes(statusCode)) return true\n    if (this.#skipErrorResponses && statusCode >= 400) return true\n    return false\n  }\n\n  /**\n   * Creates a chain of decompressors for multiple content encodings\n   *\n   * @param {string} encodings - Comma-separated list of content encodings\n   * @returns {Array<DecompressorStream>} - Array of decompressor streams\n   */\n  #createDecompressionChain (encodings) {\n    const parts = encodings.split(',')\n\n    /** @type {DecompressorStream[]} */\n    const decompressors = []\n\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const encoding = parts[i].trim()\n      if (!encoding) continue\n\n      if (!supportedEncodings[encoding]) {\n        decompressors.length = 0 // Clear if unsupported encoding\n        return decompressors // Unsupported encoding\n      }\n\n      decompressors.push(supportedEncodings[encoding]())\n    }\n\n    return decompressors\n  }\n\n  /**\n   * Sets up event handlers for a decompressor stream using readable events\n   * @param {DecompressorStream} decompressor - The decompressor stream\n   * @param {Controller} controller - The controller to coordinate with\n   * @returns {void}\n   */\n  #setupDecompressorEvents (decompressor, controller) {\n    decompressor.on('readable', () => {\n      let chunk\n      while ((chunk = decompressor.read()) !== null) {\n        const result = super.onResponseData(controller, chunk)\n        if (result === false) {\n          break\n        }\n      }\n    })\n\n    decompressor.on('error', (error) => {\n      super.onResponseError(controller, error)\n    })\n  }\n\n  /**\n   * Sets up event handling for a single decompressor\n   * @param {Controller} controller - The controller to handle events\n   * @returns {void}\n   */\n  #setupSingleDecompressor (controller) {\n    const decompressor = this.#decompressors[0]\n    this.#setupDecompressorEvents(decompressor, controller)\n\n    decompressor.on('end', () => {\n      super.onResponseEnd(controller, {})\n    })\n  }\n\n  /**\n   * Sets up event handling for multiple chained decompressors using pipeline\n   * @param {Controller} controller - The controller to handle events\n   * @returns {void}\n   */\n  #setupMultipleDecompressors (controller) {\n    const lastDecompressor = this.#decompressors[this.#decompressors.length - 1]\n    this.#setupDecompressorEvents(lastDecompressor, controller)\n\n    this.#pipelineStream = pipeline(this.#decompressors, (err) => {\n      if (err) {\n        super.onResponseError(controller, err)\n        return\n      }\n      super.onResponseEnd(controller, {})\n    })\n  }\n\n  /**\n   * Cleans up decompressor references to prevent memory leaks\n   * @returns {void}\n   */\n  #cleanupDecompressors () {\n    this.#decompressors.length = 0\n    this.#pipelineStream = null\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {number} statusCode\n   * @param {Record<string, string | string[] | undefined>} headers\n   * @param {string} statusMessage\n   * @returns {void}\n   */\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const contentEncoding = headers['content-encoding']\n\n    // If content encoding is not supported or status code is in skip list\n    if (this.#shouldSkipDecompression(contentEncoding, statusCode)) {\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    const decompressors = this.#createDecompressionChain(contentEncoding.toLowerCase())\n\n    if (decompressors.length === 0) {\n      this.#cleanupDecompressors()\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    this.#decompressors = decompressors\n\n    // Remove compression headers since we're decompressing\n    const { 'content-encoding': _, 'content-length': __, ...newHeaders } = headers\n\n    if (this.#decompressors.length === 1) {\n      this.#setupSingleDecompressor(controller)\n    } else {\n      this.#setupMultipleDecompressors(controller)\n    }\n\n    super.onResponseStart(controller, statusCode, newHeaders, statusMessage)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Buffer} chunk\n   * @returns {void}\n   */\n  onResponseData (controller, chunk) {\n    if (this.#decompressors.length > 0) {\n      this.#decompressors[0].write(chunk)\n      return\n    }\n    super.onResponseData(controller, chunk)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Record<string, string | string[]> | undefined} trailers\n   * @returns {void}\n   */\n  onResponseEnd (controller, trailers) {\n    if (this.#decompressors.length > 0) {\n      this.#decompressors[0].end()\n      this.#cleanupDecompressors()\n      return\n    }\n    super.onResponseEnd(controller, trailers)\n  }\n\n  /**\n   * @param {Controller} controller\n   * @param {Error} err\n   * @returns {void}\n   */\n  onResponseError (controller, err) {\n    if (this.#decompressors.length > 0) {\n      for (const decompressor of this.#decompressors) {\n        decompressor.destroy(err)\n      }\n      this.#cleanupDecompressors()\n    }\n    super.onResponseError(controller, err)\n  }\n}\n\n/**\n * Creates a decompression interceptor for HTTP responses\n * @param {DecompressHandlerOptions} [options] - Options for the interceptor\n * @returns {Function} - Interceptor function\n */\nfunction createDecompressInterceptor (options = {}) {\n  // Emit experimental warning only once\n  if (!warningEmitted) {\n    process.emitWarning(\n      'DecompressInterceptor is experimental and subject to change',\n      'ExperimentalWarning'\n    )\n    warningEmitted = true\n  }\n\n  return (dispatch) => {\n    return (opts, handler) => {\n      const decompressHandler = new DecompressHandler(handler, options)\n      return dispatch(opts, decompressHandler)\n    }\n  }\n}\n\nmodule.exports = createDecompressInterceptor\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9012, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/cache/memory-cache-store.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('node:stream')\nconst { EventEmitter } = require('node:events')\nconst { assertCacheKey, assertCacheValue } = require('../util/cache.js')\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheKey} CacheKey\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheValue} CacheValue\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @typedef {import('../../types/cache-interceptor.d.ts').default.GetResult} GetResult\n */\n\n/**\n * @implements {CacheStore}\n * @extends {EventEmitter}\n */\nclass MemoryCacheStore extends EventEmitter {\n  #maxCount = 1024\n  #maxSize = 104857600 // 100MB\n  #maxEntrySize = 5242880 // 5MB\n\n  #size = 0\n  #count = 0\n  #entries = new Map()\n  #hasEmittedMaxSizeEvent = false\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]\n   */\n  constructor (opts) {\n    super()\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('MemoryCacheStore options must be an object')\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n\n      if (opts.maxSize !== undefined) {\n        if (\n          typeof opts.maxSize !== 'number' ||\n          !Number.isInteger(opts.maxSize) ||\n          opts.maxSize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxSize must be a non-negative integer')\n        }\n        this.#maxSize = opts.maxSize\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n    }\n  }\n\n  /**\n   * Get the current size of the cache in bytes\n   * @returns {number} The current size of the cache in bytes\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * Check if the cache is full (either max size or max count reached)\n   * @returns {boolean} True if the cache is full, false otherwise\n   */\n  isFull () {\n    return this.#size >= this.#maxSize || this.#count >= this.#maxCount\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req\n   * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const now = Date.now()\n    const entries = this.#entries.get(topLevelKey)\n\n    const entry = entries ? findEntry(key, entries, now) : null\n\n    return entry == null\n      ? undefined\n      : {\n          statusMessage: entry.statusMessage,\n          statusCode: entry.statusCode,\n          headers: entry.headers,\n          body: entry.body,\n          vary: entry.vary ? entry.vary : undefined,\n          etag: entry.etag,\n          cacheControlDirectives: entry.cacheControlDirectives,\n          cachedAt: entry.cachedAt,\n          staleAt: entry.staleAt,\n          deleteAt: entry.deleteAt\n        }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, val) {\n    assertCacheKey(key)\n    assertCacheValue(val)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const store = this\n    const entry = { ...key, ...val, body: [], size: 0 }\n\n    return new Writable({\n      write (chunk, encoding, callback) {\n        if (typeof chunk === 'string') {\n          chunk = Buffer.from(chunk, encoding)\n        }\n\n        entry.size += chunk.byteLength\n\n        if (entry.size >= store.#maxEntrySize) {\n          this.destroy()\n        } else {\n          entry.body.push(chunk)\n        }\n\n        callback(null)\n      },\n      final (callback) {\n        let entries = store.#entries.get(topLevelKey)\n        if (!entries) {\n          entries = []\n          store.#entries.set(topLevelKey, entries)\n        }\n        const previousEntry = findEntry(key, entries, Date.now())\n        if (previousEntry) {\n          const index = entries.indexOf(previousEntry)\n          entries.splice(index, 1, entry)\n          store.#size -= previousEntry.size\n        } else {\n          entries.push(entry)\n          store.#count += 1\n        }\n\n        store.#size += entry.size\n\n        // Check if cache is full and emit event if needed\n        if (store.#size > store.#maxSize || store.#count > store.#maxCount) {\n          // Emit maxSizeExceeded event if we haven't already\n          if (!store.#hasEmittedMaxSizeEvent) {\n            store.emit('maxSizeExceeded', {\n              size: store.#size,\n              maxSize: store.#maxSize,\n              count: store.#count,\n              maxCount: store.#maxCount\n            })\n            store.#hasEmittedMaxSizeEvent = true\n          }\n\n          // Perform eviction\n          for (const [key, entries] of store.#entries) {\n            for (const entry of entries.splice(0, entries.length / 2)) {\n              store.#size -= entry.size\n              store.#count -= 1\n            }\n            if (entries.length === 0) {\n              store.#entries.delete(key)\n            }\n          }\n\n          // Reset the event flag after eviction\n          if (store.#size < store.#maxSize && store.#count < store.#maxCount) {\n            store.#hasEmittedMaxSizeEvent = false\n          }\n        }\n\n        callback(null)\n      }\n    })\n  }\n\n  /**\n   * @param {CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    for (const entry of this.#entries.get(topLevelKey) ?? []) {\n      this.#size -= entry.size\n      this.#count -= 1\n    }\n    this.#entries.delete(topLevelKey)\n  }\n}\n\nfunction findEntry (key, entries, now) {\n  return entries.find((entry) => (\n    entry.deleteAt > now &&\n    entry.method === key.method &&\n    (entry.vary == null || Object.keys(entry.vary).every(headerName => {\n      if (entry.vary[headerName] === null) {\n        return key.headers[headerName] === undefined\n      }\n\n      return entry.vary[headerName] === key.headers[headerName]\n    }))\n  ))\n}\n\nmodule.exports = MemoryCacheStore\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9197, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/cache/sqlite-cache-store.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('node:stream')\nconst { assertCacheKey, assertCacheValue } = require('../util/cache.js')\n\nlet DatabaseSync\n\nconst VERSION = 3\n\n// 2gb\nconst MAX_ENTRY_SIZE = 2 * 1000 * 1000 * 1000\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @implements {CacheStore}\n *\n * @typedef {{\n *  id: Readonly<number>,\n *  body?: Uint8Array\n *  statusCode: number\n *  statusMessage: string\n *  headers?: string\n *  vary?: string\n *  etag?: string\n *  cacheControlDirectives?: string\n *  cachedAt: number\n *  staleAt: number\n *  deleteAt: number\n * }} SqliteStoreValue\n */\nmodule.exports = class SqliteCacheStore {\n  #maxEntrySize = MAX_ENTRY_SIZE\n  #maxCount = Infinity\n\n  /**\n   * @type {import('node:sqlite').DatabaseSync}\n   */\n  #db\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #getValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #updateValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #insertValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteExpiredValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteByUrlQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #countEntriesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync | null}\n   */\n  #deleteOldValuesQuery\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts\n   */\n  constructor (opts) {\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('SqliteCacheStore options must be an object')\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n\n        if (opts.maxEntrySize > MAX_ENTRY_SIZE) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be less than 2gb')\n        }\n\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n    }\n\n    if (!DatabaseSync) {\n      DatabaseSync = require('node:sqlite').DatabaseSync\n    }\n    this.#db = new DatabaseSync(opts?.location ?? ':memory:')\n\n    this.#db.exec(`\n      PRAGMA journal_mode = WAL;\n      PRAGMA synchronous = NORMAL;\n      PRAGMA temp_store = memory;\n      PRAGMA optimize;\n\n      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (\n        -- Data specific to us\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        url TEXT NOT NULL,\n        method TEXT NOT NULL,\n\n        -- Data returned to the interceptor\n        body BUF NULL,\n        deleteAt INTEGER NOT NULL,\n        statusCode INTEGER NOT NULL,\n        statusMessage TEXT NOT NULL,\n        headers TEXT NULL,\n        cacheControlDirectives TEXT NULL,\n        etag TEXT NULL,\n        vary TEXT NULL,\n        cachedAt INTEGER NOT NULL,\n        staleAt INTEGER NOT NULL\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_getValuesQuery ON cacheInterceptorV${VERSION}(url, method, deleteAt);\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteByUrlQuery ON cacheInterceptorV${VERSION}(deleteAt);\n    `)\n\n    this.#getValuesQuery = this.#db.prepare(`\n      SELECT\n        id,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      FROM cacheInterceptorV${VERSION}\n      WHERE\n        url = ?\n        AND method = ?\n      ORDER BY\n        deleteAt ASC\n    `)\n\n    this.#updateValueQuery = this.#db.prepare(`\n      UPDATE cacheInterceptorV${VERSION} SET\n        body = ?,\n        deleteAt = ?,\n        statusCode = ?,\n        statusMessage = ?,\n        headers = ?,\n        etag = ?,\n        cacheControlDirectives = ?,\n        cachedAt = ?,\n        staleAt = ?\n      WHERE\n        id = ?\n    `)\n\n    this.#insertValueQuery = this.#db.prepare(`\n      INSERT INTO cacheInterceptorV${VERSION} (\n        url,\n        method,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `)\n\n    this.#deleteByUrlQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`\n    )\n\n    this.#countEntriesQuery = this.#db.prepare(\n      `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`\n    )\n\n    this.#deleteExpiredValuesQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`\n    )\n\n    this.#deleteOldValuesQuery = this.#maxCount === Infinity\n      ? null\n      : this.#db.prepare(`\n        DELETE FROM cacheInterceptorV${VERSION}\n        WHERE id IN (\n          SELECT\n            id\n          FROM cacheInterceptorV${VERSION}\n          ORDER BY cachedAt DESC\n          LIMIT ?\n        )\n      `)\n  }\n\n  close () {\n    this.#db.close()\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const value = this.#findValue(key)\n    return value\n      ? {\n          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : undefined,\n          statusCode: value.statusCode,\n          statusMessage: value.statusMessage,\n          headers: value.headers ? JSON.parse(value.headers) : undefined,\n          etag: value.etag ? value.etag : undefined,\n          vary: value.vary ? JSON.parse(value.vary) : undefined,\n          cacheControlDirectives: value.cacheControlDirectives\n            ? JSON.parse(value.cacheControlDirectives)\n            : undefined,\n          cachedAt: value.cachedAt,\n          staleAt: value.staleAt,\n          deleteAt: value.deleteAt\n        }\n      : undefined\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value\n   */\n  set (key, value) {\n    assertCacheKey(key)\n\n    const url = this.#makeValueUrl(key)\n    const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body\n    const size = body?.byteLength\n\n    if (size && size > this.#maxEntrySize) {\n      return\n    }\n\n    const existingValue = this.#findValue(key, true)\n    if (existingValue) {\n      // Updating an existing response, let's overwrite it\n      this.#updateValueQuery.run(\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.cachedAt,\n        value.staleAt,\n        existingValue.id\n      )\n    } else {\n      this.#prune()\n      // New response, let's insert it\n      this.#insertValueQuery.run(\n        url,\n        key.method,\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.vary ? JSON.stringify(value.vary) : null,\n        value.cachedAt,\n        value.staleAt\n      )\n    }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, value) {\n    assertCacheKey(key)\n    assertCacheValue(value)\n\n    let size = 0\n    /**\n     * @type {Buffer[] | null}\n     */\n    const body = []\n    const store = this\n\n    return new Writable({\n      decodeStrings: true,\n      write (chunk, encoding, callback) {\n        size += chunk.byteLength\n\n        if (size < store.#maxEntrySize) {\n          body.push(chunk)\n        } else {\n          this.destroy()\n        }\n\n        callback()\n      },\n      final (callback) {\n        store.set(key, { ...value, body })\n        callback()\n      }\n    })\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    this.#deleteByUrlQuery.run(this.#makeValueUrl(key))\n  }\n\n  #prune () {\n    if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {\n      return 0\n    }\n\n    {\n      const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    {\n      const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Counts the number of rows in the cache\n   * @returns {Number}\n   */\n  get size () {\n    const { total } = this.#countEntriesQuery.get()\n    return total\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {string}\n   */\n  #makeValueUrl (key) {\n    return `${key.origin}/${key.path}`\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {boolean} [canBeExpired=false]\n   * @returns {SqliteStoreValue | undefined}\n   */\n  #findValue (key, canBeExpired = false) {\n    const url = this.#makeValueUrl(key)\n    const { headers, method } = key\n\n    /**\n     * @type {SqliteStoreValue[]}\n     */\n    const values = this.#getValuesQuery.all(url, method)\n\n    if (values.length === 0) {\n      return undefined\n    }\n\n    const now = Date.now()\n    for (const value of values) {\n      if (now >= value.deleteAt && !canBeExpired) {\n        return undefined\n      }\n\n      let matches = true\n\n      if (value.vary) {\n        const vary = JSON.parse(value.vary)\n\n        for (const header in vary) {\n          if (!headerValueEquals(headers[header], vary[header])) {\n            matches = false\n            break\n          }\n        }\n      }\n\n      if (matches) {\n        return value\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * @param {string|string[]|null|undefined} lhs\n * @param {string|string[]|null|undefined} rhs\n * @returns {boolean}\n */\nfunction headerValueEquals (lhs, rhs) {\n  if (lhs == null && rhs == null) {\n    return true\n  }\n\n  if ((lhs == null && rhs != null) ||\n      (lhs != null && rhs == null)) {\n    return false\n  }\n\n  if (Array.isArray(lhs) && Array.isArray(rhs)) {\n    if (lhs.length !== rhs.length) {\n      return false\n    }\n\n    return lhs.every((x, i) => x === rhs[i])\n  }\n\n  return lhs === rhs\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}