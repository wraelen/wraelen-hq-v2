{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/constants.js"],"sourcesContent":["'use strict'\n\nconst corsSafeListedMethods = /** @type {const} */ (['GET', 'HEAD', 'POST'])\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods)\n\nconst nullBodyStatus = /** @type {const} */ ([101, 204, 205, 304])\n\nconst redirectStatus = /** @type {const} */ ([301, 302, 303, 307, 308])\nconst redirectStatusSet = new Set(redirectStatus)\n\n/**\n * @see https://fetch.spec.whatwg.org/#block-bad-port\n */\nconst badPorts = /** @type {const} */ ([\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '4190', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6679',\n  '6697', '10080'\n])\nconst badPortsSet = new Set(badPorts)\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header\n */\nconst referrerPolicyTokens = /** @type {const} */ ([\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n])\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\n */\nconst referrerPolicy = /** @type {const} */ ([\n  '',\n  ...referrerPolicyTokens\n])\nconst referrerPolicyTokensSet = new Set(referrerPolicyTokens)\n\nconst requestRedirect = /** @type {const} */ (['follow', 'manual', 'error'])\n\nconst safeMethods = /** @type {const} */ (['GET', 'HEAD', 'OPTIONS', 'TRACE'])\nconst safeMethodsSet = new Set(safeMethods)\n\nconst requestMode = /** @type {const} */ (['navigate', 'same-origin', 'no-cors', 'cors'])\n\nconst requestCredentials = /** @type {const} */ (['omit', 'same-origin', 'include'])\n\nconst requestCache = /** @type {const} */ ([\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-body-header-name\n */\nconst requestBodyHeader = /** @type {const} */ ([\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#enumdef-requestduplex\n */\nconst requestDuplex = /** @type {const} */ ([\n  'half'\n])\n\n/**\n * @see http://fetch.spec.whatwg.org/#forbidden-method\n */\nconst forbiddenMethods = /** @type {const} */ (['CONNECT', 'TRACE', 'TRACK'])\nconst forbiddenMethodsSet = new Set(forbiddenMethods)\n\nconst subresource = /** @type {const} */ ([\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n])\nconst subresourceSet = new Set(subresource)\n\nmodule.exports = {\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex,\n  subresourceSet,\n  badPortsSet,\n  redirectStatusSet,\n  corsSafeListedMethodsSet,\n  safeMethodsSet,\n  forbiddenMethodsSet,\n  referrerPolicyTokens: referrerPolicyTokensSet\n}\n"],"names":[],"mappings":"AAEA,MAAM,wBAA8C;IAAC;IAAO;IAAQ;CAAO;AAC3E,MAAM,2BAA2B,IAAI,IAAI;AAEzC,MAAM,iBAAuC;IAAC;IAAK;IAAK;IAAK;CAAI;AAEjE,MAAM,iBAAuC;IAAC;IAAK;IAAK;IAAK;IAAK;CAAI;AACtE,MAAM,oBAAoB,IAAI,IAAI;AAElC;;CAEC,GACD,MAAM,WAAiC;IACrC;IAAK;IAAK;IAAK;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAC/G;IAAM;IAAM;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IACvG;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAClG;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAQ;IAAQ;IACpG;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IAAQ;IACxG;IAAQ;CACT;AACD,MAAM,cAAc,IAAI,IAAI;AAE5B;;CAEC,GACD,MAAM,uBAA6C;IACjD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED;;CAEC,GACD,MAAM,iBAAuC;IAC3C;OACG;CACJ;AACD,MAAM,0BAA0B,IAAI,IAAI;AAExC,MAAM,kBAAwC;IAAC;IAAU;IAAU;CAAQ;AAE3E,MAAM,cAAoC;IAAC;IAAO;IAAQ;IAAW;CAAQ;AAC7E,MAAM,iBAAiB,IAAI,IAAI;AAE/B,MAAM,cAAoC;IAAC;IAAY;IAAe;IAAW;CAAO;AAExF,MAAM,qBAA2C;IAAC;IAAQ;IAAe;CAAU;AAEnF,MAAM,eAAqC;IACzC;IACA;IACA;IACA;IACA;IACA;CACD;AAED;;CAEC,GACD,MAAM,oBAA0C;IAC9C;IACA;IACA;IACA;IACA,mDAAmD;IACnD,kEAAkE;IAClE,iEAAiE;IACjE,yCAAyC;IACzC;CACD;AAED;;CAEC,GACD,MAAM,gBAAsC;IAC1C;CACD;AAED;;CAEC,GACD,MAAM,mBAAyC;IAAC;IAAW;IAAS;CAAQ;AAC5E,MAAM,sBAAsB,IAAI,IAAI;AAEpC,MAAM,cAAoC;IACxC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACD,MAAM,iBAAiB,IAAI,IAAI;AAE/B,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/global.js"],"sourcesContent":["'use strict'\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n"],"names":[],"mappings":"AAEA,oDAAoD;AACpD,6BAA6B;AAC7B,MAAM,eAAe,OAAO,GAAG,CAAC;AAEhC,SAAS;IACP,OAAO,UAAU,CAAC,aAAa;AACjC;AAEA,SAAS,gBAAiB,SAAS;IACjC,IAAI,cAAc,WAAW;QAC3B,OAAO,cAAc,CAAC,YAAY,cAAc;YAC9C,OAAO;YACP,UAAU;YACV,YAAY;YACZ,cAAc;QAChB;QAEA;IACF;IAEA,MAAM,YAAY,IAAI,IAAI;IAE1B,IAAI,UAAU,QAAQ,KAAK,WAAW,UAAU,QAAQ,KAAK,UAAU;QACrE,MAAM,IAAI,UAAU,CAAC,6CAA6C,EAAE,UAAU,QAAQ,EAAE;IAC1F;IAEA,OAAO,cAAc,CAAC,YAAY,cAAc;QAC9C,OAAO;QACP,UAAU;QACV,YAAY;QACZ,cAAc;IAChB;AACF;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/data-url.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  // 2. For each byte byte in input:\n  for (let i = 0; i < length; ++i) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')\n\n  let dataLength = data.length\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean} [extractValue=false]\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue = false) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */\nfunction isASCIIWhitespace (char) {\n  // \"\\r\\n\\t\\f \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''; let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeType’s essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeType’s essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeChars,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 836, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/webidl/index.js"],"sourcesContent":["'use strict'\n\nconst { types, inspect } = require('node:util')\nconst { markAsUncloneable } = require('node:worker_threads')\n\nconst UNDEFINED = 1\nconst BOOLEAN = 2\nconst STRING = 3\nconst SYMBOL = 4\nconst NUMBER = 5\nconst BIGINT = 6\nconst NULL = 7\nconst OBJECT = 8 // function and object\n\nconst FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance])\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {\n  converters: {},\n  util: {},\n  errors: {},\n  is: {}\n}\n\n/**\n * @description Instantiate an error.\n *\n * @param {Object} opts\n * @param {string} opts.header\n * @param {string} opts.message\n * @returns {TypeError}\n */\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\n/**\n * @description Instantiate an error when conversion from one type to another has failed.\n *\n * @param {Object} opts\n * @param {string} opts.prefix\n * @param {string} opts.argument\n * @param {string[]} opts.types\n * @returns {TypeError}\n */\nwebidl.errors.conversionFailed = function (opts) {\n  const plural = opts.types.length === 1 ? '' : ' one of'\n  const message =\n    `${opts.argument} could not be converted to` +\n    `${plural}: ${opts.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: opts.prefix,\n    message\n  })\n}\n\n/**\n * @description Instantiate an error when an invalid argument is provided\n *\n * @param {Object} context\n * @param {string} context.prefix\n * @param {string} context.value\n * @param {string} context.type\n * @returns {TypeError}\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I) {\n  if (!FunctionPrototypeSymbolHasInstance(I, V)) {\n    const err = new TypeError('Illegal invocation')\n    err.code = 'ERR_INVALID_THIS' // node compat.\n    throw err\n  }\n}\n\nwebidl.brandCheckMultiple = function (List) {\n  const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c))\n\n  return (V) => {\n    if (prototypes.every(typeCheck => !typeCheck(V))) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\nwebidl.util.MakeTypeAssertion = function (I) {\n  return (O) => FunctionPrototypeSymbolHasInstance(I, O)\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return UNDEFINED\n    case 'boolean': return BOOLEAN\n    case 'string': return STRING\n    case 'symbol': return SYMBOL\n    case 'number': return NUMBER\n    case 'bigint': return BIGINT\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return NULL\n      }\n\n      return OBJECT\n    }\n  }\n}\n\nwebidl.util.Types = {\n  UNDEFINED,\n  BOOLEAN,\n  STRING,\n  SYMBOL,\n  NUMBER,\n  BIGINT,\n  NULL,\n  OBJECT\n}\n\nwebidl.util.TypeValueToString = function (o) {\n  switch (webidl.util.Type(o)) {\n    case UNDEFINED: return 'Undefined'\n    case BOOLEAN: return 'Boolean'\n    case STRING: return 'String'\n    case SYMBOL: return 'Symbol'\n    case NUMBER: return 'Number'\n    case BIGINT: return 'BigInt'\n    case NULL: return 'Null'\n    case OBJECT: return 'Object'\n  }\n}\n\nwebidl.util.markAsUncloneable = markAsUncloneable || (() => {})\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, flags) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (webidl.util.HasFlag(flags, webidl.attributes.EnforceRange)) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && webidl.util.HasFlag(flags, webidl.attributes.Clamp)) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case SYMBOL:\n      return `Symbol(${V.description})`\n    case OBJECT:\n      return inspect(V)\n    case STRING:\n      return `\"${V}\"`\n    case BIGINT:\n      return `${V}n`\n    default:\n      return `${V}`\n  }\n}\n\nwebidl.util.IsResizableArrayBuffer = function (V) {\n  if (types.isArrayBuffer(V)) {\n    return V.resizable\n  }\n\n  if (types.isSharedArrayBuffer(V)) {\n    return V.growable\n  }\n\n  throw webidl.errors.exception({\n    header: 'IsResizableArrayBuffer',\n    message: `\"${webidl.util.Stringify(V)}\" is not an array buffer.`\n  })\n}\n\nwebidl.util.HasFlag = function (flags, attributes) {\n  return typeof flags === 'number' && (flags & attributes) === attributes\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.TypeValueToString(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        const keyName = webidl.util.Stringify(key)\n\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (TypeCheck, name) {\n  return (V, prefix, argument) => {\n    if (!TypeCheck(V)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const dict = {}\n\n    if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (dictionary == null || !Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary?.[key]\n      const hasDefault = defaultValue !== undefined\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value === undefined) {\n        value = defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nwebidl.is.USVString = function (value) {\n  return (\n    typeof value === 'string' &&\n    value.isWellFormed()\n  )\n}\n\nwebidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream)\nwebidl.is.Blob = webidl.util.MakeTypeAssertion(Blob)\nwebidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams)\nwebidl.is.File = webidl.util.MakeTypeAssertion(File)\nwebidl.is.URL = webidl.util.MakeTypeAssertion(URL)\nwebidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal)\nwebidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort)\n\nwebidl.is.BufferSource = function (V) {\n  return types.isArrayBuffer(V) || (\n    ArrayBuffer.isView(V) &&\n    types.isArrayBuffer(V.buffer)\n  )\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, flags) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && webidl.util.HasFlag(flags, webidl.attributes.LegacyNullToEmptyString)) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a ByteString.`\n    })\n  }\n\n  const x = String(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n * @see https://webidl.spec.whatwg.org/#es-USVString\n */\nwebidl.converters.USVString = function (value) {\n  // TODO: rewrite this so we can control the errors thrown\n  if (typeof value === 'string') {\n    return value.toWellFormed()\n  }\n  return `${value}`.toWellFormed()\n}\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  // https://262.ecma-international.org/10.0/index.html#table-10\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', 0, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', 0, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', 0, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, flags) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', flags, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, flags) {\n  // 1. If V is not an Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // 2. If IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a resizable ArrayBuffer.`\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#idl-SharedArrayBuffer\nwebidl.converters.SharedArrayBuffer = function (V, prefix, argument, flags) {\n  // 1. If V is not an Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // 2. If IsSharedArrayBuffer(V) is false, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isSharedArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['SharedArrayBuffer']\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a resizable SharedArrayBuffer.`\n    })\n  }\n\n  // 4. Return the IDL SharedArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#dfn-typed-array-type\nwebidl.converters.TypedArray = function (V, T, prefix, argument, flags) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#idl-DataView\nwebidl.converters.DataView = function (V, prefix, argument, flags) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['DataView']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#ArrayBufferView\nwebidl.converters.ArrayBufferView = function (V, prefix, argument, flags) {\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isArrayBufferView(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBufferView']\n    })\n  }\n\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a shared array buffer.`\n    })\n  }\n\n  if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a view on a resizable array buffer.`\n    })\n  }\n\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, argument, flags) {\n  if (types.isArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isArrayBufferView(V)) {\n    flags &= ~webidl.attributes.AllowShared\n\n    return webidl.converters.ArrayBufferView(V, prefix, argument, flags)\n  }\n\n  // Make this explicit for easier debugging\n  if (types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} cannot be a SharedArrayBuffer.`\n    })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['ArrayBuffer', 'ArrayBufferView']\n  })\n}\n\n// https://webidl.spec.whatwg.org/#AllowSharedBufferSource\nwebidl.converters.AllowSharedBufferSource = function (V, prefix, argument, flags) {\n  if (types.isArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isSharedArrayBuffer(V)) {\n    return webidl.converters.SharedArrayBuffer(V, prefix, argument, flags)\n  }\n\n  if (types.isArrayBufferView(V)) {\n    flags |= webidl.attributes.AllowShared\n    return webidl.converters.ArrayBufferView(V, prefix, argument, flags)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['ArrayBuffer', 'SharedArrayBuffer', 'ArrayBufferView']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nwebidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, 'Blob')\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  webidl.is.AbortSignal,\n  'AbortSignal'\n)\n\n/**\n * [LegacyTreatNonObjectAsNull]\n * callback EventHandlerNonNull = any (Event event);\n * typedef EventHandlerNonNull? EventHandler;\n * @param {*} V\n */\nwebidl.converters.EventHandlerNonNull = function (V) {\n  if (webidl.util.Type(V) !== OBJECT) {\n    return null\n  }\n\n  // [I]f the value is not an object, it will be converted to null, and if the value is not callable,\n  // it will be converted to a callback function value that does nothing when called.\n  if (typeof V === 'function') {\n    return V\n  }\n\n  return () => {}\n}\n\nwebidl.attributes = {\n  Clamp: 1 << 0,\n  EnforceRange: 1 << 1,\n  AllowShared: 1 << 2,\n  AllowResizable: 1 << 3,\n  LegacyNullToEmptyString: 1 << 4\n}\n\nmodule.exports = {\n  webidl\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1622, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { Transform } = require('node:stream')\nconst zlib = require('node:zlib')\nconst { redirectStatusSet, referrerPolicyTokens, badPortsSet } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require('./data-url')\nconst { performance } = require('node:perf_hooks')\nconst { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require('../../core/util')\nconst assert = require('node:assert')\nconst { isUint8Array } = require('node:util/types')\nconst { webidl } = require('../webidl')\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n/**\n * Parse a referrer policy from a Referrer-Policy header\n * @see https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n */\nfunction parseReferrerPolicy (actualResponse) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const policyHeader = (actualResponse.headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // 2. Let policy be the empty string.\n  let policy = ''\n\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  if (policyHeader.length) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 4. Return policy.\n  return policy\n}\n\n/**\n * Given a request request and a response actualResponse, this algorithm\n * updates request’s referrer policy according to the Referrer-Policy\n * header (if any) in actualResponse.\n * @see https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\n * @param {import('./request').Request} request\n * @param {import('./response').Response} actualResponse\n */\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  const policy = parseReferrerPolicy(actualResponse)\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n/**\n * Determine request’s Referrer\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\n */\nfunction determineRequestsReferrer (request) {\n  // Given a request request, we can determine the correct referrer information\n  // to send by examining its referrer policy as detailed in the following\n  // steps, which return either no referrer or a URL:\n\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n\n  // \"client\"\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // Note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  // a URL\n  } else if (webidl.is.URL(request.referrer)) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point\n  // to enforce arbitrary policy considerations in the interests of minimizing\n  // data leakage. For example, the user agent could strip the URL down to an\n  // origin, modify its host, replace it with an empty string, etc.\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'no-referrer':\n      // Return no referrer\n      return 'no-referrer'\n    case 'origin':\n      // Return referrerOrigin\n      if (referrerOrigin != null) {\n        return referrerOrigin\n      }\n      return stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url':\n      // Return referrerURL.\n      return referrerURL\n    case 'strict-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerOrigin\n      return referrerOrigin\n    }\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of request’s current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return no referrer.\n      return 'no-referrer'\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request’s current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return referrerOrigin.\n      return referrerOrigin\n    case 'no-referrer-when-downgrade': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerURL.\n      return referrerURL\n    }\n  }\n}\n\n/**\n * Certain portions of URLs must not be included when sending a URL as the\n * value of a `Referer` header: a URLs fragment, username, and password\n * components must be stripped from the URL before it’s sent out. This\n * algorithm accepts a origin-only flag, which defaults to false. If set to\n * true, the algorithm will additionally remove the URL’s path and query\n * components, leaving only the scheme, host, and port.\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean} [originOnly=false]\n */\nfunction stripURLForReferrer (url, originOnly = false) {\n  // 1. Assert: url is a URL.\n  assert(webidl.is.URL(url))\n\n  // Note: Create a new URL instance to avoid mutating the original URL.\n  url = new URL(url)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (urlIsLocal(url)) {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly === true) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nconst isPotentialleTrustworthyIPv4 = RegExp.prototype.test\n  .bind(/^127\\.(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.){2}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)$/)\n\nconst isPotentiallyTrustworthyIPv6 = RegExp.prototype.test\n  .bind(/^(?:(?:0{1,4}:){7}|(?:0{1,4}:){1,6}:|::)0{0,3}1$/)\n\n/**\n * Check if host matches one of the CIDR notations 127.0.0.0/8 or ::1/128.\n *\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginIPPotentiallyTrustworthy (origin) {\n  // IPv6\n  if (origin.includes(':')) {\n    // Remove brackets from IPv6 addresses\n    if (origin[0] === '[' && origin[origin.length - 1] === ']') {\n      origin = origin.slice(1, -1)\n    }\n    return isPotentiallyTrustworthyIPv6(origin)\n  }\n\n  // IPv4\n  return isPotentialleTrustworthyIPv4(origin)\n}\n\n/**\n * A potentially trustworthy origin is one which a user agent can generally\n * trust as delivering data securely.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginPotentiallyTrustworthy (origin) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  if (origin == null || origin === 'null') {\n    return false\n  }\n\n  // 2. Assert: origin is a tuple origin.\n  origin = new URL(origin)\n\n  // 3. If origin’s scheme is either \"https\" or \"wss\",\n  //    return \"Potentially Trustworthy\".\n  if (origin.protocol === 'https:' || origin.protocol === 'wss:') {\n    return true\n  }\n\n  // 4. If origin’s host matches one of the CIDR notations 127.0.0.0/8 or\n  // ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n  if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {\n    return true\n  }\n\n  // 5. If the user agent conforms to the name resolution rules in\n  //    [let-localhost-be-localhost] and one of the following is true:\n\n  //    origin’s host is \"localhost\" or \"localhost.\"\n  if (origin.hostname === 'localhost' || origin.hostname === 'localhost.') {\n    return true\n  }\n\n  //    origin’s host ends with \".localhost\" or \".localhost.\"\n  if (origin.hostname.endsWith('.localhost') || origin.hostname.endsWith('.localhost.')) {\n    return true\n  }\n\n  // 6. If origin’s scheme is \"file\", return \"Potentially Trustworthy\".\n  if (origin.protocol === 'file:') {\n    return true\n  }\n\n  // 7. If origin’s scheme component is one which the user agent considers to\n  // be authenticated, return \"Potentially Trustworthy\".\n\n  // 8. If origin has been configured as a trustworthy origin, return\n  //    \"Potentially Trustworthy\".\n\n  // 9. Return \"Not Trustworthy\".\n  return false\n}\n\n/**\n * A potentially trustworthy URL is one which either inherits context from its\n * creator (about:blank, about:srcdoc, data) or one whose origin is a\n * potentially trustworthy origin.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://www.w3.org/TR/secure-contexts/#is-url-trustworthy\n * @param {URL} url\n * @returns {boolean}\n */\nfunction isURLPotentiallyTrustworthy (url) {\n  // Given a URL record (url), the following algorithm returns \"Potentially\n  // Trustworthy\" or \"Not Trustworthy\" as appropriate:\n  if (!webidl.is.URL(url)) {\n    return false\n  }\n\n  // 1. If url is \"about:blank\" or \"about:srcdoc\",\n  //    return \"Potentially Trustworthy\".\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // 2. If url’s scheme is \"data\", return \"Potentially Trustworthy\".\n  if (url.protocol === 'data:') return true\n\n  // Note: The origin of blob: URLs is the origin of the context in which they\n  // were created. Therefore, blobs created in a trustworthy origin will\n  // themselves be potentially trustworthy.\n  if (url.protocol === 'blob:') return true\n\n  // 3. Return the result of executing § 3.1 Is origin potentially trustworthy?\n  // on url’s origin.\n  return isOriginPotentiallyTrustworthy(url.origin)\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {((target: any) => any)} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index\n      const values = kInternalIterator(this.#target)\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {(target: any) => any} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @param {import('./body').ExtractBodyResult} body\n * @param {(bytes: Uint8Array) => void} processBody\n * @param {(error: Error) => void} processBodyError\n * @returns {void}\n *\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  try {\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n    const reader = body.stream.getReader()\n\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    readAllBytes(reader, successSteps, errorSteps)\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStream<Uint8Array<ArrayBuffer>>} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n * @returns {Promise<void>}\n */\nasync function readAllBytes (reader, successSteps, failureSteps) {\n  try {\n    const bytes = []\n    let byteLength = 0\n\n    do {\n      const { done, value: chunk } = await reader.read()\n\n      if (done) {\n        // 1. Call successSteps with bytes.\n        successSteps(Buffer.concat(bytes, byteLength))\n        return\n      }\n\n      // 1. If chunk is not a Uint8Array object, call failureSteps\n      //    with a TypeError and abort these steps.\n      if (!isUint8Array(chunk)) {\n        failureSteps(new TypeError('Received non-Uint8Array chunk'))\n        return\n      }\n\n      // 2. Append the bytes represented by chunk to bytes.\n      bytes.push(chunk)\n      byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    } while (true)\n  } catch (e) {\n    // 1. Call failureSteps with e.\n    failureSteps(e)\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n * @returns {boolean}\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  // A URL is local if its scheme is a local scheme.\n  // A local scheme is \"about\", \"blob\", or \"data\".\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @typedef {Object} RangeHeaderValue\n * @property {number|null} rangeStartValue\n * @property {number|null} rangeEndValue\n */\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n * @return {RangeHeaderValue|'failure'}\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  #zlibOptions\n\n  /** @param {zlib.ZlibOptions} [zlibOptions] */\n  constructor (zlibOptions) {\n    super()\n    this.#zlibOptions = zlibOptions\n  }\n\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate(this.#zlibOptions)\n        : zlib.createInflateRaw(this.#zlibOptions)\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\n/**\n * @param {zlib.ZlibOptions} [zlibOptions]\n * @returns {InflateStream}\n */\nfunction createInflate (zlibOptions) {\n  return new InflateStream(zlibOptions)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject,\n  isOriginIPPotentiallyTrustworthy\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2867, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/formdata.js"],"sourcesContent":["'use strict'\n\nconst { iteratorMixin } = require('./util')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { webidl } = require('../webidl')\nconst nodeUtil = require('node:util')\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  #state = []\n\n  constructor (form = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.append'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this.#state.push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    this.#state = this.#state.filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.get'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this.#state[idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.getAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this.#state\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this.#state.findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.set'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this.#state = [\n        ...this.#state.slice(0, idx),\n        entry,\n        ...this.#state.slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this.#state.push(entry)\n    }\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    const state = this.#state.reduce((a, b) => {\n      if (a[b.name]) {\n        if (Array.isArray(a[b.name])) {\n          a[b.name].push(b.value)\n        } else {\n          a[b.name] = [a[b.name], b.value]\n        }\n      } else {\n        a[b.name] = b.value\n      }\n\n      return a\n    }, { __proto__: null })\n\n    options.depth ??= depth\n    options.colors ??= true\n\n    const output = nodeUtil.formatWithOptions(options, state)\n\n    // remove [Object null prototype]\n    return `FormData ${output.slice(output.indexOf(']') + 2)}`\n  }\n\n  /**\n   * @param {FormData} formData\n   */\n  static getFormDataState (formData) {\n    return formData.#state\n  }\n\n  /**\n   * @param {FormData} formData\n   * @param {any[]} newState\n   */\n  static setFormDataState (formData, newState) {\n    formData.#state = newState\n  }\n}\n\nconst { getFormDataState, setFormDataState } = FormData\nReflect.deleteProperty(FormData, 'getFormDataState')\nReflect.deleteProperty(FormData, 'setFormDataState')\n\niteratorMixin('FormData', FormData, getFormDataState, 'name', 'value')\n\nObject.defineProperties(FormData.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  getAll: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // Note: This operation was done by the webidl converter USVString.\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!webidl.is.File(value)) {\n      value = new File([value], 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = new File([value], filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nwebidl.is.FormData = webidl.util.MakeTypeAssertion(FormData)\n\nmodule.exports = { FormData, makeEntry, setFormDataState }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3087, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/formdata-parser.js"],"sourcesContent":["'use strict'\n\nconst { bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { utf8DecodeBytes } = require('./util')\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require('./data-url')\nconst { makeEntry } = require('./formdata')\nconst { webidl } = require('../webidl')\nconst assert = require('node:assert')\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    throw parsingError('missing boundary in content-type header')\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allows leading and trailing CRLFs.\n  while (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n    position.position += 2\n  }\n\n  let trailing = input.length\n\n  while (input[trailing - 1] === 0x0a && input[trailing - 2] === 0x0d) {\n    trailing -= 2\n  }\n\n  if (trailing !== input.length) {\n    input = input.subarray(0, trailing)\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      throw parsingError('expected a value starting with -- and the boundary')\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        throw parsingError('expected boundary after body')\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(webidl.is.USVString(name))\n    assert((typeof value === 'string' && webidl.is.USVString(value)) || webidl.is.File(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        throw parsingError('header name is null')\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      throw parsingError('header name does not match the field-name token production')\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      throw parsingError('expected :')\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          throw parsingError('expected form-data; name=\" for content-disposition header')\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (input[position.position] === 0x3b /* ; */ && input[position.position + 1] === 0x20 /* ' ' */) {\n          const at = { position: position.position + 2 }\n\n          if (bufferStartsWith(input, filenameBuffer, at)) {\n            if (input[at.position + 8] === 0x2a /* '*' */) {\n              at.position += 10 // skip past filename*=\n\n              // Remove leading http tab and spaces. See RFC for examples.\n              // https://datatracker.ietf.org/doc/html/rfc6266#section-5\n              collectASequenceOfBytes(\n                (char) => char === 0x20 || char === 0x09,\n                input,\n                at\n              )\n\n              const headerValue = collectASequenceOfBytes(\n                (char) => char !== 0x20 && char !== 0x0d && char !== 0x0a, // ' ' or CRLF\n                input,\n                at\n              )\n\n              if (\n                (headerValue[0] !== 0x75 && headerValue[0] !== 0x55) || // u or U\n                (headerValue[1] !== 0x74 && headerValue[1] !== 0x54) || // t or T\n                (headerValue[2] !== 0x66 && headerValue[2] !== 0x46) || // f or F\n                headerValue[3] !== 0x2d || // -\n                headerValue[4] !== 0x38 // 8\n              ) {\n                throw parsingError('unknown encoding, expected utf-8\\'\\'')\n              }\n\n              // skip utf-8''\n              filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)))\n\n              position.position = at.position\n            } else {\n              // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n              //    (the one in the sequence of bytes matched above).\n              position.position += 11\n\n              // Remove leading http tab and spaces. See RFC for examples.\n              // https://datatracker.ietf.org/doc/html/rfc6266#section-5\n              collectASequenceOfBytes(\n                (char) => char === 0x20 || char === 0x09,\n                input,\n                position\n              )\n\n              position.position++ // skip past \" after removing whitespace\n\n              // 2. Set filename to the result of parsing a multipart/form-data name given\n              //    input and position, if the result is not failure. Otherwise, return failure.\n              filename = parseMultipartFormDataName(input, position)\n            }\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    throw parsingError('expected \"')\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction parsingError (cause) {\n  return new TypeError('Failed to parse body as FormData.', { cause: new TypeError(cause) })\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3458, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst util = require('../../core/util')\nconst {\n  ReadableStreamFrom,\n  readableStreamClose,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = require('./util')\nconst { FormData, setFormDataState } = require('./formdata')\nconst { webidl } = require('../webidl')\nconst assert = require('node:assert')\nconst { isErrored, isDisturbed } = require('node:stream')\nconst { isArrayBuffer } = require('node:util/types')\nconst { serializeAMimeType } = require('./data-url')\nconst { multipartFormDataParser } = require('./formdata-parser')\nconst { createDeferredPromise } = require('../../util/promise')\n\nlet random\n\ntry {\n  const crypto = require('node:crypto')\n  random = (max) => crypto.randomInt(0, max)\n} catch {\n  random = (max) => Math.floor(Math.random() * max)\n}\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst streamRegistry = new FinalizationRegistry((weakRef) => {\n  const stream = weakRef.deref()\n  if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n    stream.cancel('Response object has been garbage collected').catch(noop)\n  }\n})\n\n/**\n * Extract a body with type from a byte sequence or BodyInit object\n *\n * @param {import('../../../types').BodyInit} object - The BodyInit object to extract from\n * @param {boolean} [keepalive=false] - If true, indicates that the body\n * @returns {[{stream: ReadableStream, source: any, length: number | null}, string | null]} - Returns a tuple containing the body and its type\n *\n * @see https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n */\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (webidl.is.ReadableStream(object)) {\n    stream = object\n  } else if (webidl.is.Blob(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(webidl.is.ReadableStream(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (webidl.is.URLSearchParams(object)) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (webidl.is.BufferSource(object)) {\n    source = isArrayBuffer(object)\n      ? new Uint8Array(object.slice())\n      : new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (webidl.is.FormData(object)) {\n    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const formdataEscape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${formdataEscape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${formdataEscape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${formdataEscape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    // CRLF is appended to the body to function with legacy servers and match other implementations.\n    // https://github.com/curl/curl/blob/3434c6b46e682452973972e8313613dfa58cd690/lib/mime.c#L1029-L1030\n    // https://github.com/form-data/form-data/issues/63\n    const chunk = textEncoder.encode(`--${boundary}--\\r\\n`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (webidl.is.Blob(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n/**\n * @typedef {object} ExtractBodyResult\n * @property {ReadableStream<Uint8Array<ArrayBuffer>>} stream - The ReadableStream containing the body data\n * @property {any} source - The original source of the body data\n * @property {number | null} length - The length of the body data, or null\n */\n\n/**\n * Safely extract a body with type from a byte sequence or BodyInit object.\n *\n * @param {import('../../../types').BodyInit} object - The BodyInit object to extract from\n * @param {boolean} [keepalive=false] - If true, indicates that the body\n * @returns {[ExtractBodyResult, string | null]} - Returns a tuple containing the body and its type\n *\n * @see https://fetch.spec.whatwg.org/#bodyinit-safely-extract\n */\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (webidl.is.ReadableStream(object)) {\n    // Assert: object is neither disturbed nor locked.\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const { 0: out1, 1: out2 } = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction bodyMixinMethods (instance, getInternalState) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(getInternalState(this))\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance, getInternalState)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance, getInternalState)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance, getInternalState)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance, getInternalState)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(getInternalState(this))\n\n        // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              // 2. If that fails for some reason, then throw a TypeError.\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              setFormDataState(fd, parsed)\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance, getInternalState)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in this’s relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance, getInternalState)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype, getInternalState) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {any} object internal state\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {any} instance\n * @param {(target: any) => any} getInternalState\n */\nfunction consumeBody (object, convertBytesToJSValue, instance, getInternalState) {\n  try {\n    webidl.brandCheck(object, instance)\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  const state = getInternalState(object)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(state)) {\n    return Promise.reject(new TypeError('Body is unusable: Body has already been read'))\n  }\n\n  if (state.aborted) {\n    return Promise.reject(new DOMException('The operation was aborted.', 'AbortError'))\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = promise.reject\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (state.body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  fullyReadBody(state.body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {any} object internal state\n */\nfunction bodyUnusable (object) {\n  const body = object.body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {any} requestOrResponse internal state\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse.headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  bodyUnusable\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3905, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/headers.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kConstruct } = require('../../core/symbols')\nconst { kEnumerableProperty } = require('../../core/util')\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst { webidl } = require('../webidl')\nconst assert = require('node:assert')\nconst util = require('node:util')\n\n/**\n * @param {number} code\n * @returns {code is (0x0a | 0x0d | 0x09 | 0x20)}\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x0a || code === 0x0d || code === 0x09 || code === 0x20\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n * @returns {string}\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\n/**\n * @param {Headers} headers\n * @param {Array|Object} object\n */\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n * @param {Headers} headers\n * @param {string} name\n * @param {string} value\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\n// https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n/**\n * @param {Headers} target\n */\nfunction headersListSortAndCombine (target) {\n  const headersList = getHeadersList(target)\n\n  if (!headersList) {\n    return []\n  }\n\n  if (headersList.sortedMap) {\n    return headersList.sortedMap\n  }\n\n  // 1. Let headers be an empty list of headers with the key being the name\n  //    and value the value.\n  const headers = []\n\n  // 2. Let names be the result of convert header names to a sorted-lowercase\n  //    set with all the names of the headers in list.\n  const names = headersList.toSortedArray()\n\n  const cookies = headersList.cookies\n\n  // fast-path\n  if (cookies === null || cookies.length === 1) {\n    // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n    return (headersList.sortedMap = names)\n  }\n\n  // 3. For each name of names:\n  for (let i = 0; i < names.length; ++i) {\n    const { 0: name, 1: value } = names[i]\n    // 1. If name is `set-cookie`, then:\n    if (name === 'set-cookie') {\n      // 1. Let values be a list of all values of headers in list whose name\n      //    is a byte-case-insensitive match for name, in order.\n\n      // 2. For each value of values:\n      // 1. Append (name, value) to headers.\n      for (let j = 0; j < cookies.length; ++j) {\n        headers.push([name, cookies[j]])\n      }\n    } else {\n      // 2. Otherwise:\n\n      // 1. Let value be the result of getting name from list.\n\n      // 2. Assert: value is non-null.\n      // Note: This operation was done by `HeadersList#toSortedArray`.\n\n      // 3. Append (name, value) to headers.\n      headers.push([name, value])\n    }\n  }\n\n  // 4. Return headers.\n  return (headersList.sortedMap = headers)\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  sortedMap\n  headersMap\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this.headersMap = new Map(init.headersMap)\n      this.sortedMap = init.sortedMap\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this.headersMap = new Map(init)\n      this.sortedMap = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this.headersMap.has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this.headersMap.clear()\n    this.sortedMap = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this.sortedMap = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this.headersMap.get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this.headersMap.set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this.headersMap.set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this.sortedMap = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this.headersMap.set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this.sortedMap = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this.headersMap.delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this.headersMap) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this.headersMap.size !== 0) {\n      for (const { name, value } of this.headersMap.values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this.headersMap.values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this.headersMap.size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this.headersMap.size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this.headersMap[Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this.headersMap) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  /**\n   * @type {HeadersList}\n   */\n  #headersList\n\n  /**\n   * @param {HeadersInit|Symbol} [init]\n   * @returns\n   */\n  constructor (init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers constructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  /**\n   * @param {Headers} o\n   */\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  /**\n   * @param {Headers} target\n   * @param {HeadersList} list\n   */\n  static setHeadersList (target, list) {\n    target.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, headersListSortAndCombine, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4535, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require('./headers')\nconst { extractBody, cloneBody, mixinBody, streamRegistry, bodyUnusable } = require('./body')\nconst util = require('../../core/util')\nconst nodeUtil = require('node:util')\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode,\n  environmentSettingsObject: relevantRealm\n} = require('./util')\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = require('./constants')\nconst { webidl } = require('../webidl')\nconst { URLSerializer } = require('./data-url')\nconst { kConstruct } = require('../../core/symbols')\nconst assert = require('node:assert')\n\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = undefined) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject.#state.status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject.#state.headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body, 'Response', 'body')\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set this’s response to a new response.\n    this.#state = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersGuard(this.#headers, 'response')\n    setHeadersList(this.#headers, this.#state.headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this.#state.type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this.#state.urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this.#state.urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this.#state.status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this.#state.status >= 200 && this.#state.status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this.#state.statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this.#headers\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this.#state)\n\n    // Note: To re-register because of a new stream.\n    if (this.#state.body?.stream) {\n      streamRegistry.register(this, new WeakRef(this.#state.body.stream))\n    }\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseHeaders (response) {\n    return response.#headers\n  }\n\n  /**\n   * @param {Response} response\n   * @param {Headers} newHeaders\n   */\n  static setResponseHeaders (response, newHeaders) {\n    response.#headers = newHeaders\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseState (response) {\n    return response.#state\n  }\n\n  /**\n   * @param {Response} response\n   * @param {any} newState\n   */\n  static setResponseState (response, newState) {\n    response.#state = newState\n  }\n}\n\nconst { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response\nReflect.deleteProperty(Response, 'getResponseHeaders')\nReflect.deleteProperty(Response, 'setResponseHeaders')\nReflect.deleteProperty(Response, 'getResponseState')\nReflect.deleteProperty(Response, 'setResponseState')\n\nmixinBody(Response, getResponseState)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    getResponseState(response).status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    getResponseState(response).statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(getResponseHeaders(response), init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    getResponseState(response).body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !getResponseState(response).headersList.contains('content-type', true)) {\n      getResponseState(response).headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  setResponseState(response, innerResponse)\n  const headers = new Headers(kConstruct)\n  setResponseHeaders(response, headers)\n  setHeadersList(headers, innerResponse.headersList)\n  setHeadersGuard(headers, guard)\n\n  if (innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    streamRegistry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (webidl.is.Blob(V)) {\n    return V\n  }\n\n  if (webidl.is.BufferSource(V)) {\n    return V\n  }\n\n  if (webidl.is.FormData(V)) {\n    return V\n  }\n\n  if (webidl.is.URLSearchParams(V)) {\n    return V\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (webidl.is.ReadableStream(V)) {\n    return V\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nwebidl.is.Response = webidl.util.MakeTypeAssertion(Response)\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse,\n  getResponseState\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5055, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/request.js"],"sourcesContent":["/* globals AbortController */\n\n'use strict'\n\nconst { extractBody, mixinBody, cloneBody, bodyUnusable } = require('./body')\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require('./headers')\nconst util = require('../../core/util')\nconst nodeUtil = require('node:util')\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = require('./util')\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = require('./constants')\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { webidl } = require('../webidl')\nconst { URLSerializer } = require('./data-url')\nconst { kConstruct } = require('../../core/symbols')\nconst assert = require('node:assert')\nconst { getMaxListeners, setMaxListeners, defaultMaxListeners } = require('node:events')\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nlet abortSignalHasEventHandlerLeakWarning\n\ntry {\n  abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0\n} catch {\n  abortSignalHasEventHandlerLeakWarning = false\n}\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  /** @type {AbortSignal} */\n  #signal\n\n  /** @type {import('../../dispatcher/dispatcher')} */\n  #dispatcher\n\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input)\n    init = webidl.converters.RequestInit(init)\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this.#dispatcher = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(webidl.is.Request(input))\n\n      // 8. Set request to input’s request.\n      request = input.#state\n\n      // 9. Set signal to input’s signal.\n      signal = input.#signal\n\n      this.#dispatcher = init.dispatcher || input.#dispatcher\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set request’s referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set request’s method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this.#state = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this.#signal = ac.signal\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // If the max amount of listeners is equal to the default, increase it\n        if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {\n          setMaxListeners(1500, signal)\n        }\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersList(this.#headers, request.headersList)\n    setHeadersGuard(this.#headers, 'request')\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      setHeadersGuard(this.#headers, 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this.#headers)\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty this’s headers’s header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this.#headers, headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = webidl.is.Request(input) ? input.#state.body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !getHeadersList(this.#headers).contains('content-type', true)) {\n        this.#headers.append('content-type', contentType, true)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (bodyUnusable(input.#state)) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this.#state.body = finalBody\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return this’s request’s method.\n    return this.#state.method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return URLSerializer(this.#state.url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return this’s headers.\n    return this.#headers\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return this’s request’s destination.\n    return this.#state.destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this.#state.referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this.#state.referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this.#state.referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this.#state.referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this.#state.mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    webidl.brandCheck(this, Request)\n\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this.#state.credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this.#state.cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this.#state.redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this.#state.integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this.#state.keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this.#state.reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this.#state.historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return this’s signal.\n    return this.#signal\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this.#state)\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Request} request\n   * @param {AbortSignal} newSignal\n   */\n  static setRequestSignal (request, newSignal) {\n    request.#signal = newSignal\n    return request\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestDispatcher (request) {\n    return request.#dispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {import('../../dispatcher/dispatcher')} newDispatcher\n   */\n  static setRequestDispatcher (request, newDispatcher) {\n    request.#dispatcher = newDispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {Headers} newHeaders\n   */\n  static setRequestHeaders (request, newHeaders) {\n    request.#headers = newHeaders\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestState (request) {\n    return request.#state\n  }\n\n  /**\n   * @param {Request} request\n   * @param {any} newState\n   */\n  static setRequestState (request, newState) {\n    request.#state = newState\n  }\n}\n\nconst { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request\nReflect.deleteProperty(Request, 'setRequestSignal')\nReflect.deleteProperty(Request, 'getRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestHeaders')\nReflect.deleteProperty(Request, 'getRequestState')\nReflect.deleteProperty(Request, 'setRequestState')\n\nmixinBody(Request, getRequestState)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {import('../../dispatcher/agent')} dispatcher\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, dispatcher, signal, guard) {\n  const request = new Request(kConstruct)\n  setRequestState(request, innerRequest)\n  setRequestDispatcher(request, dispatcher)\n  setRequestSignal(request, signal)\n  const headers = new Headers(kConstruct)\n  setRequestHeaders(request, headers)\n  setHeadersList(headers, innerRequest.headersList)\n  setHeadersGuard(headers, guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.is.Request = webidl.util.MakeTypeAssertion(Request)\n\n/**\n * @param {*} V\n * @returns {import('../../../types/fetch').Request|string}\n *\n * @see https://fetch.spec.whatwg.org/#requestinfo\n */\nwebidl.converters.RequestInfo = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (webidl.is.Request(V)) {\n    return V\n  }\n\n  return webidl.converters.USVString(V)\n}\n\n/**\n * @param {*} V\n * @returns {import('../../../types/fetch').RequestInit}\n * @see https://fetch.spec.whatwg.org/#requestinit\n */\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal'\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  Request,\n  makeRequest,\n  fromInnerRequest,\n  cloneRequest,\n  getRequestDispatcher,\n  getRequestState\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5956, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\n\n/**\n * @typedef {object} Metadata\n * @property {SRIHashAlgorithm} alg - The algorithm used for the hash.\n * @property {string} val - The base64-encoded hash value.\n */\n\n/**\n * @typedef {Metadata[]} MetadataList\n */\n\n/**\n * @typedef {('sha256' | 'sha384' | 'sha512')} SRIHashAlgorithm\n */\n\n/**\n * @type {Map<SRIHashAlgorithm, number>}\n *\n * The valid SRI hash algorithm token set is the ordered set « \"sha256\",\n * \"sha384\", \"sha512\" » (corresponding to SHA-256, SHA-384, and SHA-512\n * respectively). The ordering of this set is meaningful, with stronger\n * algorithms appearing later in the set.\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#valid-sri-hash-algorithm-token-set\n */\nconst validSRIHashAlgorithmTokenSet = new Map([['sha256', 0], ['sha384', 1], ['sha512', 2]])\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n  const cryptoHashes = crypto.getHashes()\n\n  // If no hashes are available, we cannot support SRI.\n  if (cryptoHashes.length === 0) {\n    validSRIHashAlgorithmTokenSet.clear()\n  }\n\n  for (const algorithm of validSRIHashAlgorithmTokenSet.keys()) {\n    // If the algorithm is not supported, remove it from the list.\n    if (cryptoHashes.includes(algorithm) === false) {\n      validSRIHashAlgorithmTokenSet.delete(algorithm)\n    }\n  }\n  /* c8 ignore next 4 */\n} catch {\n  // If crypto is not available, we cannot support SRI.\n  validSRIHashAlgorithmTokenSet.clear()\n}\n\n/**\n * @typedef GetSRIHashAlgorithmIndex\n * @type {(algorithm: SRIHashAlgorithm) => number}\n * @param {SRIHashAlgorithm} algorithm\n * @returns {number} The index of the algorithm in the valid SRI hash algorithm\n * token set.\n */\n\nconst getSRIHashAlgorithmIndex = /** @type {GetSRIHashAlgorithmIndex} */ (Map.prototype.get.bind(\n  validSRIHashAlgorithmTokenSet))\n\n/**\n * @typedef IsValidSRIHashAlgorithm\n * @type {(algorithm: string) => algorithm is SRIHashAlgorithm}\n * @param {*} algorithm\n * @returns {algorithm is SRIHashAlgorithm}\n */\n\nconst isValidSRIHashAlgorithm = /** @type {IsValidSRIHashAlgorithm} */ (\n  Map.prototype.has.bind(validSRIHashAlgorithmTokenSet)\n)\n\n/**\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n * @returns {boolean}\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n */\nconst bytesMatch = crypto === undefined || validSRIHashAlgorithmTokenSet.size === 0\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  ? () => true\n  : (bytes, metadataList) => {\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n      const parsedMetadata = parseMetadata(metadataList)\n\n      // 2. If parsedMetadata is empty set, return true.\n      if (parsedMetadata.length === 0) {\n        return true\n      }\n\n      // 3. Let metadata be the result of getting the strongest\n      //    metadata from parsedMetadata.\n      const metadata = getStrongestMetadata(parsedMetadata)\n\n      // 4. For each item in metadata:\n      for (const item of metadata) {\n      // 1. Let algorithm be the item[\"alg\"].\n        const algorithm = item.alg\n\n        // 2. Let expectedValue be the item[\"val\"].\n        const expectedValue = item.val\n\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n        // 3. Let actualValue be the result of applying algorithm to bytes .\n        const actualValue = applyAlgorithmToBytes(algorithm, bytes)\n\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (caseSensitiveMatch(actualValue, expectedValue)) {\n          return true\n        }\n      }\n\n      // 5. Return false.\n      return false\n    }\n\n/**\n * @param {MetadataList} metadataList\n * @returns {MetadataList} The strongest hash algorithm from the metadata list.\n */\nfunction getStrongestMetadata (metadataList) {\n  // 1. Let result be the empty set and strongest be the empty string.\n  const result = []\n  /** @type {Metadata|null} */\n  let strongest = null\n\n  // 2. For each item in set:\n  for (const item of metadataList) {\n    // 1. Assert: item[\"alg\"] is a valid SRI hash algorithm token.\n    assert(isValidSRIHashAlgorithm(item.alg), 'Invalid SRI hash algorithm token')\n\n    // 2. If result is the empty set, then:\n    if (result.length === 0) {\n      // 1. Append item to result.\n      result.push(item)\n\n      // 2. Set strongest to item.\n      strongest = item\n\n      // 3. Continue.\n      continue\n    }\n\n    // 3. Let currentAlgorithm be strongest[\"alg\"], and currentAlgorithmIndex be\n    // the index of currentAlgorithm in the valid SRI hash algorithm token set.\n    const currentAlgorithm = /** @type {Metadata} */ (strongest).alg\n    const currentAlgorithmIndex = getSRIHashAlgorithmIndex(currentAlgorithm)\n\n    // 4. Let newAlgorithm be the item[\"alg\"], and newAlgorithmIndex be the\n    // index of newAlgorithm in the valid SRI hash algorithm token set.\n    const newAlgorithm = item.alg\n    const newAlgorithmIndex = getSRIHashAlgorithmIndex(newAlgorithm)\n\n    // 5. If newAlgorithmIndex is less than currentAlgorithmIndex, then continue.\n    if (newAlgorithmIndex < currentAlgorithmIndex) {\n      continue\n\n    // 6. Otherwise, if newAlgorithmIndex is greater than\n    // currentAlgorithmIndex:\n    } else if (newAlgorithmIndex > currentAlgorithmIndex) {\n      // 1. Set strongest to item.\n      strongest = item\n\n      // 2. Set result to « item ».\n      result[0] = item\n      result.length = 1\n\n    // 7. Otherwise, newAlgorithmIndex and currentAlgorithmIndex are the same\n    // value. Append item to result.\n    } else {\n      result.push(item)\n    }\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * @param {string} metadata\n * @returns {MetadataList}\n *\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {MetadataList} */\n  const result = []\n\n  // 2. For each item returned by splitting metadata on spaces:\n  for (const item of metadata.split(' ')) {\n    // 1. Let expression-and-options be the result of splitting item on U+003F (?).\n    const expressionAndOptions = item.split('?', 1)\n\n    // 2. Let algorithm-expression be expression-and-options[0].\n    const algorithmExpression = expressionAndOptions[0]\n\n    // 3. Let base64-value be the empty string.\n    let base64Value = ''\n\n    // 4. Let algorithm-and-value be the result of splitting algorithm-expression on U+002D (-).\n    const algorithmAndValue = [algorithmExpression.slice(0, 6), algorithmExpression.slice(7)]\n\n    // 5. Let algorithm be algorithm-and-value[0].\n    const algorithm = algorithmAndValue[0]\n\n    // 6. If algorithm is not a valid SRI hash algorithm token, then continue.\n    if (!isValidSRIHashAlgorithm(algorithm)) {\n      continue\n    }\n\n    // 7. If algorithm-and-value[1] exists, set base64-value to\n    // algorithm-and-value[1].\n    if (algorithmAndValue[1]) {\n      base64Value = algorithmAndValue[1]\n    }\n\n    // 8. Let metadata be the ordered map\n    // «[\"alg\" → algorithm, \"val\" → base64-value]».\n    const metadata = {\n      alg: algorithm,\n      val: base64Value\n    }\n\n    // 9. Append metadata to result.\n    result.push(metadata)\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * Applies the specified hash algorithm to the given bytes\n *\n * @typedef {(algorithm: SRIHashAlgorithm, bytes: Uint8Array) => string} ApplyAlgorithmToBytes\n * @param {SRIHashAlgorithm} algorithm\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nconst applyAlgorithmToBytes = (algorithm, bytes) => {\n  return crypto.hash(algorithm, bytes, 'base64')\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n * @param {string} actualValue base64 encoded string\n * @param {string} expectedValue base64 or base64url encoded string\n * @returns {boolean}\n */\nfunction caseSensitiveMatch (actualValue, expectedValue) {\n  // Ignore padding characters from the end of the strings by\n  // decreasing the length by 1 or 2 if the last characters are `=`.\n  let actualValueLength = actualValue.length\n  if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === '=') {\n    actualValueLength -= 1\n  }\n  if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === '=') {\n    actualValueLength -= 1\n  }\n  let expectedValueLength = expectedValue.length\n  if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === '=') {\n    expectedValueLength -= 1\n  }\n  if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === '=') {\n    expectedValueLength -= 1\n  }\n\n  if (actualValueLength !== expectedValueLength) {\n    return false\n  }\n\n  for (let i = 0; i < actualValueLength; ++i) {\n    if (\n      actualValue[i] === expectedValue[i] ||\n      (actualValue[i] === '+' && expectedValue[i] === '-') ||\n      (actualValue[i] === '/' && expectedValue[i] === '_')\n    ) {\n      continue\n    }\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = {\n  applyAlgorithmToBytes,\n  bytesMatch,\n  caseSensitiveMatch,\n  isValidSRIHashAlgorithm,\n  getStrongestMetadata,\n  parseMetadata\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6203, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/fetch/index.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse,\n  getResponseState\n} = require('./response')\nconst { HeadersList } = require('./headers')\nconst { Request, cloneRequest, getRequestDispatcher, getRequestState } = require('./request')\nconst zlib = require('node:zlib')\nconst {\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = require('./util')\nconst assert = require('node:assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = require('./constants')\nconst EE = require('node:events')\nconst { Readable, pipeline, finished, isErrored, isReadable } = require('node:stream')\nconst { addAbortListener, bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require('./data-url')\nconst { getGlobalDispatcher } = require('../../global')\nconst { webidl } = require('../webidl')\nconst { STATUS_CODES } = require('node:http')\nconst { bytesMatch } = require('../subresource-integrity/subresource-integrity')\nconst { createDeferredPromise } = require('../../util/promise')\n\nconst hasZstd = typeof zlib.createZstdDecompress === 'function'\n\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = getRequestState(requestObject)\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: getRequestDispatcher(requestObject) // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState,\n    '', // bodyType\n    response.status\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body?.stream != null && isReadable(request.body.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = getResponseState(responseObject)\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body?.stream != null && isReadable(response.body.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams, false)\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive) {\n  try {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request\n\n    // 2. Let response be null.\n    let response = null\n\n    // 3. If request’s local-URLs-only flag is set and request’s current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n      response = makeNetworkError('local URLs only')\n    }\n\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === 'blocked') {\n      response = makeNetworkError('bad port')\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n\n    // 7. If request’s referrer policy is the empty string, then set request’s\n    // referrer policy to request’s policy container’s referrer policy.\n    if (request.referrerPolicy === '') {\n      request.referrerPolicy = request.policyContainer.referrerPolicy\n    }\n\n    // 8. If request’s referrer is not \"no-referrer\", then set request’s\n    // referrer to the result of invoking determine request’s referrer.\n    if (request.referrer !== 'no-referrer') {\n      request.referrer = determineRequestsReferrer(request)\n    }\n\n    // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n    // conditions are true:\n    // - request’s current URL’s scheme is \"http\"\n    // - request’s current URL’s host is a domain\n    // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n      const currentURL = requestCurrentURL(request)\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        response = await schemeFetch(fetchParams)\n\n      // request’s mode is \"same-origin\"\n      } else if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        response = makeNetworkError('request mode cannot be \"same-origin\"')\n\n      // request’s mode is \"no-cors\"\n      } else if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          response = makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        } else {\n          // 2. Set request’s response tainting to \"opaque\".\n          request.responseTainting = 'opaque'\n\n          // 3. Return the result of running scheme fetch given fetchParams.\n          response = await schemeFetch(fetchParams)\n        }\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        response = makeNetworkError('URL scheme must be a HTTP(S) scheme')\n\n        // - request’s use-CORS-preflight flag is set\n        // - request’s unsafe-request flag is set and either request’s method is\n        //   not a CORS-safelisted method or CORS-unsafe request-header names with\n        //   request’s header list is not empty\n        //    1. Set request’s response tainting to \"cors\".\n        //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n        //    given fetchParams and true.\n        //    3. If corsWithPreflightResponse is a network error, then clear cache\n        //    entries using request.\n        //    4. Return corsWithPreflightResponse.\n        // TODO\n\n      // Otherwise\n      } else {\n        //    1. Set request’s response tainting to \"cors\".\n        request.responseTainting = 'cors'\n\n        //    2. Return the result of running HTTP fetch given fetchParams.\n        response = await httpFetch(fetchParams)\n      }\n    }\n\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n      return response\n    }\n\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n      // If request’s response tainting is \"cors\", then:\n      if (request.responseTainting === 'cors') {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and response’s header list.\n        // TODO\n        // 2. If request’s credentials mode is not \"include\" and headerNames\n        // contains `*`, then set response’s CORS-exposed header-name list to\n        // all unique header names in response’s header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // response’s CORS-exposed header-name list to headerNames.\n        // TODO\n      }\n\n      // Set response to the following filtered response with response as its\n      // internal response, depending on request’s response tainting:\n      if (request.responseTainting === 'basic') {\n        response = filterResponse(response, 'basic')\n      } else if (request.responseTainting === 'cors') {\n        response = filterResponse(response, 'cors')\n      } else if (request.responseTainting === 'opaque') {\n        response = filterResponse(response, 'opaque')\n      } else {\n        assert(false)\n      }\n    }\n\n    // 14. Let internalResponse be response, if response is a network error,\n    // and response’s internal response otherwise.\n    let internalResponse =\n      response.status === 0 ? response : response.internalResponse\n\n    // 15. If internalResponse’s URL list is empty, then set it to a clone of\n    // request’s URL list.\n    if (internalResponse.urlList.length === 0) {\n      internalResponse.urlList.push(...request.urlList)\n    }\n\n    // 16. If request’s timing allow failed flag is unset, then set\n    // internalResponse’s timing allow passed flag.\n    if (!request.timingAllowFailed) {\n      response.timingAllowPassed = true\n    }\n\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n\n    // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n    // internalResponse’s range-requested flag is set, and request’s header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (\n      response.type === 'opaque' &&\n      internalResponse.status === 206 &&\n      internalResponse.rangeRequested &&\n      !request.headers.contains('range', true)\n    ) {\n      response = internalResponse = makeNetworkError()\n    }\n\n    // 19. If response is not a network error and either request’s method is\n    // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n    // set internalResponse’s body to null and disregard any enqueuing toward\n    // it (if any).\n    if (\n      response.status !== 0 &&\n      (request.method === 'HEAD' ||\n        request.method === 'CONNECT' ||\n        nullBodyStatus.includes(internalResponse.status))\n    ) {\n      internalResponse.body = null\n      fetchParams.controller.dump = true\n    }\n\n    // 20. If request’s integrity metadata is not the empty string, then:\n    if (request.integrity) {\n      // 1. Let processBodyError be this step: run fetch finale given fetchParams\n      // and a network error.\n      const processBodyError = (reason) =>\n        fetchFinale(fetchParams, makeNetworkError(reason))\n\n      // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n      // then run processBodyError and abort these steps.\n      if (request.responseTainting === 'opaque' || response.body == null) {\n        processBodyError(response.error)\n        return\n      }\n\n      // 3. Let processBody given bytes be these steps:\n      const processBody = (bytes) => {\n        // 1. If bytes do not match request’s integrity metadata,\n        // then run processBodyError and abort these steps. [SRI]\n        if (!bytesMatch(bytes, request.integrity)) {\n          processBodyError('integrity mismatch')\n          return\n        }\n\n        // 2. Set response’s body to bytes as a body.\n        response.body = safelyExtractBody(bytes)[0]\n\n        // 3. Run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response)\n      }\n\n      // 4. Fully read response’s body given processBody and processBodyError.\n      fullyReadBody(response.body, processBody, processBodyError)\n    } else {\n      // 21. Otherwise, run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n  } catch (err) {\n    fetchParams.controller.terminate(err)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = require('node:buffer').resolveObjectURL\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !webidl.is.Blob(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntry’s object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blob’s size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blob’s type.\n      const type = blob.type\n\n      // 8. If request’s header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set response’s status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set response’s body to bodyWithType’s body.\n        response.body = bodyWithType[0]\n\n        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set response’s range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength − rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength − 1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set response’s body to slicedBodyWithType’s body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set response’s status to 206.\n        response.status = 206\n\n        // 14. Set response’s status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {\n        return\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (webidl.is.URL(httpRequest.referrer)) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent, true)\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    return fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      pull: pullAlgorithm,\n      cancel: cancelAlgorithm,\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  if (!fetchParams.controller.resume) {\n    fetchParams.controller.on('terminated', onAborted)\n  }\n\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n          // time, and fetchParams’s cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfo’s final network-request start time to the coarsened shared current time given\n          // fetchParams’s cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfo’s final network-response start time to the coarsened shared current\n          // time given fetchParams’s cross-origin isolated capability, immediately after the\n          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return false\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          const decoders = []\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            const contentEncoding = headersList.get('content-encoding', true)\n            // \"All content-coding values are case-insensitive...\"\n            /** @type {string[]} */\n            const codings = contentEncoding ? contentEncoding.toLowerCase().split(',') : []\n            for (let i = codings.length - 1; i >= 0; --i) {\n              const coding = codings[i].trim()\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate({\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress({\n                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n                }))\n              } else if (coding === 'zstd' && hasZstd) {\n              // Node.js v23.8.0+ and v22.15.0+ supports Zstandard\n                decoders.push(zlib.createZstdDecompress({\n                  flush: zlib.constants.ZSTD_e_continue,\n                  finishFlush: zlib.constants.ZSTD_e_end\n                }))\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          const onError = this.onError.bind(this)\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, (err) => {\n                if (err) {\n                  this.onError(err)\n                }\n              }).on('error', onError)\n              : this.body.on('error', onError)\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7949, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cache/util.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { URLSerializer } = require('../fetch/data-url')\nconst { isValidHeaderName } = require('../fetch/util')\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction getFieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (isValidHeaderName(value)) {\n      values.push(value)\n    }\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  getFieldValues\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,EAAE,aAAa,EAAE;AACvB,MAAM,EAAE,iBAAiB,EAAE;AAE3B;;;;;;CAMC,GACD,SAAS,UAAW,CAAC,EAAE,CAAC,EAAE,kBAAkB,KAAK;IAC/C,MAAM,cAAc,cAAc,GAAG;IAErC,MAAM,cAAc,cAAc,GAAG;IAErC,OAAO,gBAAgB;AACzB;AAEA;;;CAGC,GACD,SAAS,eAAgB,MAAM;IAC7B,OAAO,WAAW;IAElB,MAAM,SAAS,EAAE;IAEjB,KAAK,IAAI,SAAS,OAAO,KAAK,CAAC,KAAM;QACnC,QAAQ,MAAM,IAAI;QAElB,IAAI,kBAAkB,QAAQ;YAC5B,OAAO,IAAI,CAAC;QACd;IACF;IAEA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7985, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cache/cache.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\n\nconst { kConstruct } = require('../../core/symbols')\nconst { urlEquals, getFieldValues } = require('./util')\nconst { kEnumerableProperty, isDisturbed } = require('../../core/util')\nconst { webidl } = require('../webidl')\nconst { cloneResponse, fromInnerResponse, getResponseState } = require('../fetch/response')\nconst { Request, fromInnerRequest, getRequestState } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { urlIsHttpHttpsScheme, readAllBytes } = require('../fetch/util')\nconst { createDeferredPromise } = require('../../util/promise')\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = getRequestState(request)\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = getRequestState(new Request(request))\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (webidl.is.Request(request)) {\n      innerRequest = getRequestState(request)\n    } else { // 3.\n      innerRequest = getRequestState(new Request(request))\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = getResponseState(response)\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (webidl.is.Request(request)) {\n      r = getRequestState(request)\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = getRequestState(new Request(request))\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          undefined,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(response, 'immutable')\n\n      responseList.push(responseObject.clone())\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(\n  webidl.is.Response,\n  'Response'\n)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,MAAM,EAAE,UAAU,EAAE;AACpB,MAAM,EAAE,SAAS,EAAE,cAAc,EAAE;AACnC,MAAM,EAAE,mBAAmB,EAAE,WAAW,EAAE;AAC1C,MAAM,EAAE,MAAM,EAAE;AAChB,MAAM,EAAE,aAAa,EAAE,iBAAiB,EAAE,gBAAgB,EAAE;AAC5D,MAAM,EAAE,OAAO,EAAE,gBAAgB,EAAE,eAAe,EAAE;AACpD,MAAM,EAAE,QAAQ,EAAE;AAClB,MAAM,EAAE,oBAAoB,EAAE,YAAY,EAAE;AAC5C,MAAM,EAAE,qBAAqB,EAAE;AAE/B;;;;;;;CAOC,GAED;;;CAGC,GAED,MAAM;IACJ;;;GAGC,GACD,CAAA,2BAA4B,CAAA;IAE5B,aAAe;QACb,IAAI,SAAS,CAAC,EAAE,KAAK,YAAY;YAC/B,OAAO,kBAAkB;QAC3B;QAEA,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI;QAClC,IAAI,CAAC,CAAA,2BAA4B,GAAG,SAAS,CAAC,EAAE;IAClD;IAEA,MAAM,MAAO,OAAO,EAAE,UAAU,CAAC,CAAC,EAAE;QAClC,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,OAAO,mBAAmB,CAAC,WAAW,GAAG;QAEzC,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QACxC,UAAU,OAAO,UAAU,CAAC,iBAAiB,CAAC,SAAS,QAAQ;QAE/D,MAAM,IAAI,IAAI,CAAC,CAAA,gBAAiB,CAAC,SAAS,SAAS;QAEnD,IAAI,EAAE,MAAM,KAAK,GAAG;YAClB;QACF;QAEA,OAAO,CAAC,CAAC,EAAE;IACb;IAEA,MAAM,SAAU,UAAU,SAAS,EAAE,UAAU,CAAC,CAAC,EAAE;QACjD,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,IAAI,YAAY,WAAW,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QACnE,UAAU,OAAO,UAAU,CAAC,iBAAiB,CAAC,SAAS,QAAQ;QAE/D,OAAO,IAAI,CAAC,CAAA,gBAAiB,CAAC,SAAS;IACzC;IAEA,MAAM,IAAK,OAAO,EAAE;QAClB,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,OAAO,mBAAmB,CAAC,WAAW,GAAG;QAEzC,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QAExC,KAAK;QACL,MAAM,WAAW;YAAC;SAAQ;QAE1B,KAAK;QACL,MAAM,uBAAuB,IAAI,CAAC,MAAM,CAAC;QAEzC,KAAK;QACL,OAAO,MAAM;IACf;IAEA,MAAM,OAAQ,QAAQ,EAAE;QACtB,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,OAAO,mBAAmB,CAAC,WAAW,GAAG;QAEzC,KAAK;QACL,MAAM,mBAAmB,EAAE;QAE3B,KAAK;QACL,MAAM,cAAc,EAAE;QAEtB,KAAK;QACL,KAAK,IAAI,WAAW,SAAU;YAC5B,IAAI,YAAY,WAAW;gBACzB,MAAM,OAAO,MAAM,CAAC,gBAAgB,CAAC;oBACnC;oBACA,UAAU;oBACV,OAAO;wBAAC;qBAA2B;gBACrC;YACF;YAEA,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;YAExC,IAAI,OAAO,YAAY,UAAU;gBAC/B;YACF;YAEA,MAAM;YACN,MAAM,IAAI,gBAAgB;YAE1B,MAAM;YACN,IAAI,CAAC,qBAAqB,EAAE,GAAG,KAAK,EAAE,MAAM,KAAK,OAAO;gBACtD,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;oBAC5B,QAAQ;oBACR,SAAS;gBACX;YACF;QACF;QAEA,KAAK;QACL,0CAA0C,GAC1C,MAAM,mBAAmB,EAAE;QAE3B,KAAK;QACL,KAAK,MAAM,WAAW,SAAU;YAC9B,MAAM;YACN,MAAM,IAAI,gBAAgB,IAAI,QAAQ;YAEtC,MAAM;YACN,IAAI,CAAC,qBAAqB,EAAE,GAAG,GAAG;gBAChC,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;oBAC5B,QAAQ;oBACR,SAAS;gBACX;YACF;YAEA,MAAM;YACN,EAAE,SAAS,GAAG;YACd,EAAE,WAAW,GAAG;YAEhB,MAAM;YACN,YAAY,IAAI,CAAC;YAEjB,MAAM;YACN,MAAM,kBAAkB;YAExB,MAAM;YACN,iBAAiB,IAAI,CAAC,SAAS;gBAC7B,SAAS;gBACT,iBAAiB,QAAQ;oBACvB,KAAK;oBACL,IAAI,SAAS,IAAI,KAAK,WAAW,SAAS,MAAM,KAAK,OAAO,SAAS,MAAM,GAAG,OAAO,SAAS,MAAM,GAAG,KAAK;wBAC1G,gBAAgB,MAAM,CAAC,OAAO,MAAM,CAAC,SAAS,CAAC;4BAC7C,QAAQ;4BACR,SAAS;wBACX;oBACF,OAAO,IAAI,SAAS,WAAW,CAAC,QAAQ,CAAC,SAAS;wBAChD,MAAM;wBACN,MAAM,cAAc,eAAe,SAAS,WAAW,CAAC,GAAG,CAAC;wBAE5D,MAAM;wBACN,KAAK,MAAM,cAAc,YAAa;4BACpC,QAAQ;4BACR,IAAI,eAAe,KAAK;gCACtB,gBAAgB,MAAM,CAAC,OAAO,MAAM,CAAC,SAAS,CAAC;oCAC7C,QAAQ;oCACR,SAAS;gCACX;gCAEA,KAAK,MAAM,cAAc,iBAAkB;oCACzC,WAAW,KAAK;gCAClB;gCAEA;4BACF;wBACF;oBACF;gBACF;gBACA,0BAA0B,QAAQ;oBAChC,KAAK;oBACL,IAAI,SAAS,OAAO,EAAE;wBACpB,gBAAgB,MAAM,CAAC,IAAI,aAAa,WAAW;wBACnD;oBACF;oBAEA,KAAK;oBACL,gBAAgB,OAAO,CAAC;gBAC1B;YACF;YAEA,MAAM;YACN,iBAAiB,IAAI,CAAC,gBAAgB,OAAO;QAC/C;QAEA,KAAK;QACL,MAAM,IAAI,QAAQ,GAAG,CAAC;QAEtB,KAAK;QACL,MAAM,YAAY,MAAM;QAExB,MAAM;QACN,MAAM,aAAa,EAAE;QAErB,MAAM;QACN,IAAI,QAAQ;QAEZ,MAAM;QACN,KAAK,MAAM,YAAY,UAAW;YAChC,QAAQ;YACR,gCAAgC,GAChC,MAAM,YAAY;gBAChB,MAAM;gBACN,SAAS,WAAW,CAAC,MAAM;gBAC3B;YACF;YAEA,WAAW,IAAI,CAAC,YAAW,QAAQ;YAEnC,SAAQ,QAAQ;QAClB;QAEA,MAAM;QACN,MAAM,kBAAkB;QAExB,QAAQ;QACR,IAAI,YAAY;QAEhB,QAAQ;QACR,IAAI;YACF,IAAI,CAAC,CAAA,oBAAqB,CAAC;QAC7B,EAAE,OAAO,GAAG;YACV,YAAY;QACd;QAEA,QAAQ;QACR,eAAe;YACb,UAAU;YACV,IAAI,cAAc,MAAM;gBACtB,gBAAgB,OAAO,CAAC;YAC1B,OAAO;gBACL,UAAU;gBACV,gBAAgB,MAAM,CAAC;YACzB;QACF;QAEA,MAAM;QACN,OAAO,gBAAgB,OAAO;IAChC;IAEA,MAAM,IAAK,OAAO,EAAE,QAAQ,EAAE;QAC5B,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,OAAO,mBAAmB,CAAC,WAAW,GAAG;QAEzC,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QACxC,WAAW,OAAO,UAAU,CAAC,QAAQ,CAAC,UAAU,QAAQ;QAExD,KAAK;QACL,IAAI,eAAe;QAEnB,KAAK;QACL,IAAI,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU;YAC9B,eAAe,gBAAgB;QACjC,OAAO;YACL,eAAe,gBAAgB,IAAI,QAAQ;QAC7C;QAEA,KAAK;QACL,IAAI,CAAC,qBAAqB,aAAa,GAAG,KAAK,aAAa,MAAM,KAAK,OAAO;YAC5E,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;gBAC5B,QAAQ;gBACR,SAAS;YACX;QACF;QAEA,KAAK;QACL,MAAM,gBAAgB,iBAAiB;QAEvC,KAAK;QACL,IAAI,cAAc,MAAM,KAAK,KAAK;YAChC,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;gBAC5B,QAAQ;gBACR,SAAS;YACX;QACF;QAEA,KAAK;QACL,IAAI,cAAc,WAAW,CAAC,QAAQ,CAAC,SAAS;YAC9C,OAAO;YACP,MAAM,cAAc,eAAe,cAAc,WAAW,CAAC,GAAG,CAAC;YAEjE,OAAO;YACP,KAAK,MAAM,cAAc,YAAa;gBACpC,QAAQ;gBACR,IAAI,eAAe,KAAK;oBACtB,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;wBAC5B,QAAQ;wBACR,SAAS;oBACX;gBACF;YACF;QACF;QAEA,KAAK;QACL,IAAI,cAAc,IAAI,IAAI,CAAC,YAAY,cAAc,IAAI,CAAC,MAAM,KAAK,cAAc,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;YACtG,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;gBAC5B,QAAQ;gBACR,SAAS;YACX;QACF;QAEA,KAAK;QACL,MAAM,iBAAiB,cAAc;QAErC,MAAM;QACN,MAAM,kBAAkB;QAExB,MAAM;QACN,IAAI,cAAc,IAAI,IAAI,MAAM;YAC9B,OAAO;YACP,MAAM,SAAS,cAAc,IAAI,CAAC,MAAM;YAExC,OAAO;YACP,MAAM,SAAS,OAAO,SAAS;YAE/B,OAAO;YACP,aAAa,QAAQ,gBAAgB,OAAO,EAAE,gBAAgB,MAAM;QACtE,OAAO;YACL,gBAAgB,OAAO,CAAC;QAC1B;QAEA,MAAM;QACN,kCAAkC,GAClC,MAAM,aAAa,EAAE;QAErB,MAAM;QACN,gCAAgC,GAChC,MAAM,YAAY;YAChB,MAAM;YACN,SAAS;YACT,UAAU,eAAe,MAAM;QACjC;QAEA,MAAM;QACN,WAAW,IAAI,CAAC;QAEhB,MAAM;QACN,MAAM,QAAQ,MAAM,gBAAgB,OAAO;QAE3C,IAAI,eAAe,IAAI,IAAI,MAAM;YAC/B,eAAe,IAAI,CAAC,MAAM,GAAG;QAC/B;QAEA,OAAO;QACP,MAAM,kBAAkB;QAExB,SAAS;QACT,IAAI,YAAY;QAEhB,SAAS;QACT,IAAI;YACF,IAAI,CAAC,CAAA,oBAAqB,CAAC;QAC7B,EAAE,OAAO,GAAG;YACV,YAAY;QACd;QAEA,SAAS;QACT,eAAe;YACb,WAAW;YACX,IAAI,cAAc,MAAM;gBACtB,gBAAgB,OAAO;YACzB,OAAO;gBACL,gBAAgB,MAAM,CAAC;YACzB;QACF;QAEA,OAAO,gBAAgB,OAAO;IAChC;IAEA,MAAM,OAAQ,OAAO,EAAE,UAAU,CAAC,CAAC,EAAE;QACnC,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QACf,OAAO,mBAAmB,CAAC,WAAW,GAAG;QAEzC,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QACxC,UAAU,OAAO,UAAU,CAAC,iBAAiB,CAAC,SAAS,QAAQ;QAE/D;;KAEC,GACD,IAAI,IAAI;QAER,IAAI,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU;YAC9B,IAAI,gBAAgB;YAEpB,IAAI,EAAE,MAAM,KAAK,SAAS,CAAC,QAAQ,YAAY,EAAE;gBAC/C,OAAO;YACT;QACF,OAAO;YACL,OAAO,OAAO,YAAY;YAE1B,IAAI,gBAAgB,IAAI,QAAQ;QAClC;QAEA,kCAAkC,GAClC,MAAM,aAAa,EAAE;QAErB,gCAAgC,GAChC,MAAM,YAAY;YAChB,MAAM;YACN,SAAS;YACT;QACF;QAEA,WAAW,IAAI,CAAC;QAEhB,MAAM,kBAAkB;QAExB,IAAI,YAAY;QAChB,IAAI;QAEJ,IAAI;YACF,mBAAmB,IAAI,CAAC,CAAA,oBAAqB,CAAC;QAChD,EAAE,OAAO,GAAG;YACV,YAAY;QACd;QAEA,eAAe;YACb,IAAI,cAAc,MAAM;gBACtB,gBAAgB,OAAO,CAAC,CAAC,CAAC,kBAAkB;YAC9C,OAAO;gBACL,gBAAgB,MAAM,CAAC;YACzB;QACF;QAEA,OAAO,gBAAgB,OAAO;IAChC;IAEA;;;;;GAKC,GACD,MAAM,KAAM,UAAU,SAAS,EAAE,UAAU,CAAC,CAAC,EAAE;QAC7C,OAAO,UAAU,CAAC,IAAI,EAAE;QAExB,MAAM,SAAS;QAEf,IAAI,YAAY,WAAW,UAAU,OAAO,UAAU,CAAC,WAAW,CAAC;QACnE,UAAU,OAAO,UAAU,CAAC,iBAAiB,CAAC,SAAS,QAAQ;QAE/D,KAAK;QACL,IAAI,IAAI;QAER,KAAK;QACL,IAAI,YAAY,WAAW;YACzB,MAAM;YACN,IAAI,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU;gBAC9B,QAAQ;gBACR,IAAI,gBAAgB;gBAEpB,QAAQ;gBACR,IAAI,EAAE,MAAM,KAAK,SAAS,CAAC,QAAQ,YAAY,EAAE;oBAC/C,OAAO,EAAE;gBACX;YACF,OAAO,IAAI,OAAO,YAAY,UAAU;gBACtC,IAAI,gBAAgB,IAAI,QAAQ;YAClC;QACF;QAEA,KAAK;QACL,MAAM,UAAU;QAEhB,KAAK;QACL,MAAM;QACN,MAAM,WAAW,EAAE;QAEnB,MAAM;QACN,IAAI,YAAY,WAAW;YACzB,QAAQ;YACR,KAAK,MAAM,mBAAmB,IAAI,CAAC,CAAA,2BAA4B,CAAE;gBAC/D,UAAU;gBACV,SAAS,IAAI,CAAC,eAAe,CAAC,EAAE;YAClC;QACF,OAAO;YACL,QAAQ;YACR,MAAM,mBAAmB,IAAI,CAAC,CAAA,UAAW,CAAC,GAAG;YAE7C,QAAQ;YACR,KAAK,MAAM,mBAAmB,iBAAkB;gBAC9C,UAAU;gBACV,SAAS,IAAI,CAAC,eAAe,CAAC,EAAE;YAClC;QACF;QAEA,MAAM;QACN,eAAe;YACb,QAAQ;YACR,MAAM,cAAc,EAAE;YAEtB,QAAQ;YACR,KAAK,MAAM,WAAW,SAAU;gBAC9B,MAAM,gBAAgB,iBACpB,SACA,WACA,IAAI,kBAAkB,MAAM,EAC5B;gBAEF,UAAU;gBACV,YAAY,IAAI,CAAC;YACnB;YAEA,QAAQ;YACR,QAAQ,OAAO,CAAC,OAAO,MAAM,CAAC;QAChC;QAEA,OAAO,QAAQ,OAAO;IACxB;IAEA;;;;GAIC,GACD,CAAA,oBAAqB,CAAE,UAAU;QAC/B,KAAK;QACL,MAAM,QAAQ,IAAI,CAAC,CAAA,2BAA4B;QAE/C,KAAK;QACL,MAAM,cAAc;eAAI;SAAM;QAE9B,KAAK;QACL,MAAM,aAAa,EAAE;QAErB,MAAM;QACN,MAAM,aAAa,EAAE;QAErB,IAAI;YACF,MAAM;YACN,KAAK,MAAM,aAAa,WAAY;gBAClC,QAAQ;gBACR,IAAI,UAAU,IAAI,KAAK,YAAY,UAAU,IAAI,KAAK,OAAO;oBAC3D,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;wBAC5B,QAAQ;wBACR,SAAS;oBACX;gBACF;gBAEA,QAAQ;gBACR,IAAI,UAAU,IAAI,KAAK,YAAY,UAAU,QAAQ,IAAI,MAAM;oBAC7D,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;wBAC5B,QAAQ;wBACR,SAAS;oBACX;gBACF;gBAEA,QAAQ;gBACR,IAAI,IAAI,CAAC,CAAA,UAAW,CAAC,UAAU,OAAO,EAAE,UAAU,OAAO,EAAE,YAAY,MAAM,EAAE;oBAC7E,MAAM,IAAI,aAAa,OAAO;gBAChC;gBAEA,QAAQ;gBACR,IAAI;gBAEJ,QAAQ;gBACR,IAAI,UAAU,IAAI,KAAK,UAAU;oBAC/B,UAAU;oBACV,mBAAmB,IAAI,CAAC,CAAA,UAAW,CAAC,UAAU,OAAO,EAAE,UAAU,OAAO;oBAExE,uDAAuD;oBACvD,IAAI,iBAAiB,MAAM,KAAK,GAAG;wBACjC,OAAO,EAAE;oBACX;oBAEA,UAAU;oBACV,KAAK,MAAM,mBAAmB,iBAAkB;wBAC9C,MAAM,MAAM,MAAM,OAAO,CAAC;wBAC1B,OAAO,QAAQ,CAAC;wBAEhB,YAAY;wBACZ,MAAM,MAAM,CAAC,KAAK;oBACpB;gBACF,OAAO,IAAI,UAAU,IAAI,KAAK,OAAO;oBACnC,UAAU;oBACV,IAAI,UAAU,QAAQ,IAAI,MAAM;wBAC9B,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;4BAC5B,QAAQ;4BACR,SAAS;wBACX;oBACF;oBAEA,UAAU;oBACV,MAAM,IAAI,UAAU,OAAO;oBAE3B,UAAU;oBACV,IAAI,CAAC,qBAAqB,EAAE,GAAG,GAAG;wBAChC,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;4BAC5B,QAAQ;4BACR,SAAS;wBACX;oBACF;oBAEA,UAAU;oBACV,IAAI,EAAE,MAAM,KAAK,OAAO;wBACtB,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;4BAC5B,QAAQ;4BACR,SAAS;wBACX;oBACF;oBAEA,UAAU;oBACV,IAAI,UAAU,OAAO,IAAI,MAAM;wBAC7B,MAAM,OAAO,MAAM,CAAC,SAAS,CAAC;4BAC5B,QAAQ;4BACR,SAAS;wBACX;oBACF;oBAEA,UAAU;oBACV,mBAAmB,IAAI,CAAC,CAAA,UAAW,CAAC,UAAU,OAAO;oBAErD,UAAU;oBACV,KAAK,MAAM,mBAAmB,iBAAkB;wBAC9C,MAAM,MAAM,MAAM,OAAO,CAAC;wBAC1B,OAAO,QAAQ,CAAC;wBAEhB,YAAY;wBACZ,MAAM,MAAM,CAAC,KAAK;oBACpB;oBAEA,UAAU;oBACV,MAAM,IAAI,CAAC;wBAAC,UAAU,OAAO;wBAAE,UAAU,QAAQ;qBAAC;oBAElD,WAAW;oBACX,WAAW,IAAI,CAAC;wBAAC,UAAU,OAAO;wBAAE,UAAU,QAAQ;qBAAC;gBACzD;gBAEA,QAAQ;gBACR,WAAW,IAAI,CAAC;oBAAC,UAAU,OAAO;oBAAE,UAAU,QAAQ;iBAAC;YACzD;YAEA,MAAM;YACN,OAAO;QACT,EAAE,OAAO,GAAG;YACV,MAAM;YACN,IAAI,CAAC,CAAA,2BAA4B,CAAC,MAAM,GAAG;YAE3C,MAAM;YACN,IAAI,CAAC,CAAA,2BAA4B,GAAG;YAEpC,MAAM;YACN,MAAM;QACR;IACF;IAEA;;;;;;GAMC,GACD,CAAA,UAAW,CAAE,YAAY,EAAE,OAAO,EAAE,aAAa;QAC/C,gCAAgC,GAChC,MAAM,aAAa,EAAE;QAErB,MAAM,UAAU,iBAAiB,IAAI,CAAC,CAAA,2BAA4B;QAElE,KAAK,MAAM,mBAAmB,QAAS;YACrC,MAAM,CAAC,eAAe,eAAe,GAAG;YACxC,IAAI,IAAI,CAAC,CAAA,wBAAyB,CAAC,cAAc,eAAe,gBAAgB,UAAU;gBACxF,WAAW,IAAI,CAAC;YAClB;QACF;QAEA,OAAO;IACT;IAEA;;;;;;;GAOC,GACD,CAAA,wBAAyB,CAAE,YAAY,EAAE,OAAO,EAAE,WAAW,IAAI,EAAE,OAAO;QACxE,qEAAqE;QACrE,iBAAiB;QACjB,IAAI;QAEJ,MAAM,WAAW,IAAI,IAAI,aAAa,GAAG;QAEzC,MAAM,YAAY,IAAI,IAAI,QAAQ,GAAG;QAErC,IAAI,SAAS,cAAc;YACzB,UAAU,MAAM,GAAG;YAEnB,SAAS,MAAM,GAAG;QACpB;QAEA,IAAI,CAAC,UAAU,UAAU,WAAW,OAAO;YACzC,OAAO;QACT;QAEA,IACE,YAAY,QACZ,SAAS,cACT,CAAC,SAAS,WAAW,CAAC,QAAQ,CAAC,SAC/B;YACA,OAAO;QACT;QAEA,MAAM,cAAc,eAAe,SAAS,WAAW,CAAC,GAAG,CAAC;QAE5D,KAAK,MAAM,cAAc,YAAa;YACpC,IAAI,eAAe,KAAK;gBACtB,OAAO;YACT;YAEA,MAAM,eAAe,QAAQ,WAAW,CAAC,GAAG,CAAC;YAC7C,MAAM,aAAa,aAAa,WAAW,CAAC,GAAG,CAAC;YAEhD,0DAA0D;YAC1D,iDAAiD;YACjD,IAAI,iBAAiB,YAAY;gBAC/B,OAAO;YACT;QACF;QAEA,OAAO;IACT;IAEA,CAAA,gBAAiB,CAAE,OAAO,EAAE,OAAO,EAAE,eAAe,QAAQ;QAC1D,KAAK;QACL,IAAI,IAAI;QAER,KAAK;QACL,IAAI,YAAY,WAAW;YACzB,IAAI,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU;gBAC9B,QAAQ;gBACR,IAAI,gBAAgB;gBAEpB,QAAQ;gBACR,IAAI,EAAE,MAAM,KAAK,SAAS,CAAC,QAAQ,YAAY,EAAE;oBAC/C,OAAO,EAAE;gBACX;YACF,OAAO,IAAI,OAAO,YAAY,UAAU;gBACtC,QAAQ;gBACR,IAAI,gBAAgB,IAAI,QAAQ;YAClC;QACF;QAEA,KAAK;QACL,MAAM;QACN,MAAM,YAAY,EAAE;QAEpB,MAAM;QACN,IAAI,YAAY,WAAW;YACzB,QAAQ;YACR,KAAK,MAAM,mBAAmB,IAAI,CAAC,CAAA,2BAA4B,CAAE;gBAC/D,UAAU,IAAI,CAAC,eAAe,CAAC,EAAE;YACnC;QACF,OAAO;YACL,QAAQ;YACR,MAAM,mBAAmB,IAAI,CAAC,CAAA,UAAW,CAAC,GAAG;YAE7C,QAAQ;YACR,KAAK,MAAM,mBAAmB,iBAAkB;gBAC9C,UAAU,IAAI,CAAC,eAAe,CAAC,EAAE;YACnC;QACF;QAEA,MAAM;QACN,4EAA4E;QAE5E,QAAQ;QACR,MAAM,eAAe,EAAE;QAEvB,QAAQ;QACR,KAAK,MAAM,YAAY,UAAW;YAChC,UAAU;YACV,MAAM,iBAAiB,kBAAkB,UAAU;YAEnD,aAAa,IAAI,CAAC,eAAe,KAAK;YAEtC,IAAI,aAAa,MAAM,IAAI,cAAc;gBACvC;YACF;QACF;QAEA,KAAK;QACL,OAAO,OAAO,MAAM,CAAC;IACvB;AACF;AAEA,OAAO,gBAAgB,CAAC,MAAM,SAAS,EAAE;IACvC,CAAC,OAAO,WAAW,CAAC,EAAE;QACpB,OAAO;QACP,cAAc;IAChB;IACA,OAAO;IACP,UAAU;IACV,KAAK;IACL,QAAQ;IACR,KAAK;IACL,QAAQ;IACR,MAAM;AACR;AAEA,MAAM,6BAA6B;IACjC;QACE,KAAK;QACL,WAAW,OAAO,UAAU,CAAC,OAAO;QACpC,cAAc,IAAM;IACtB;IACA;QACE,KAAK;QACL,WAAW,OAAO,UAAU,CAAC,OAAO;QACpC,cAAc,IAAM;IACtB;IACA;QACE,KAAK;QACL,WAAW,OAAO,UAAU,CAAC,OAAO;QACpC,cAAc,IAAM;IACtB;CACD;AAED,OAAO,UAAU,CAAC,iBAAiB,GAAG,OAAO,mBAAmB,CAAC;AAEjE,OAAO,UAAU,CAAC,sBAAsB,GAAG,OAAO,mBAAmB,CAAC;OACjE;IACH;QACE,KAAK;QACL,WAAW,OAAO,UAAU,CAAC,SAAS;IACxC;CACD;AAED,OAAO,UAAU,CAAC,QAAQ,GAAG,OAAO,kBAAkB,CACpD,OAAO,EAAE,CAAC,QAAQ,EAClB;AAGF,OAAO,UAAU,CAAC,wBAAwB,GAAG,OAAO,iBAAiB,CACnE,OAAO,UAAU,CAAC,WAAW;AAG/B,OAAO,OAAO,GAAG;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8668, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cache/cachestorage.js"],"sourcesContent":["'use strict'\n\nconst { Cache } = require('./cache')\nconst { webidl } = require('../webidl')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { kConstruct } = require('../../core/symbols')\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match')\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.open'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8788, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cookies/constants.js"],"sourcesContent":["'use strict'\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n"],"names":[],"mappings":"AAEA,2EAA2E;AAC3E,MAAM,wBAAwB;AAE9B,2EAA2E;AAC3E,MAAM,uBAAuB;AAE7B,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8800, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cookies/util.js"],"sourcesContent":["'use strict'\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction isCTLExcludingHtab (value) {\n  for (let i = 0; i < value.length; ++i) {\n    const code = value.charCodeAt(i)\n\n    if (\n      (code >= 0x00 && code <= 0x08) ||\n      (code >= 0x0A && code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (let i = 0; i < name.length; ++i) {\n    const code = name.charCodeAt(i)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31), SP and HT\n      code > 0x7E || // exclude non-ascii and DEL\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x3C || // <\n      code === 0x3E || // >\n      code === 0x40 || // @\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x3A || // :\n      code === 0x5C || // \\\n      code === 0x2F || // /\n      code === 0x5B || // [\n      code === 0x5D || // ]\n      code === 0x3F || // ?\n      code === 0x3D || // =\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  let len = value.length\n  let i = 0\n\n  // if the value is wrapped in DQUOTE\n  if (value[0] === '\"') {\n    if (len === 1 || value[len - 1] !== '\"') {\n      throw new Error('Invalid cookie value')\n    }\n    --len\n    ++i\n  }\n\n  while (i < len) {\n    const code = value.charCodeAt(i++)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code > 0x7E || // non-ascii and DEL (127)\n      code === 0x22 || // \"\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x5C // \\\n    ) {\n      throw new Error('Invalid cookie value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (let i = 0; i < path.length; ++i) {\n    const code = path.charCodeAt(i)\n\n    if (\n      code < 0x20 || // exclude CTLs (0-31)\n      code === 0x7F || // DEL\n      code === 0x3B // ;\n    ) {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\nconst IMFDays = [\n  'Sun', 'Mon', 'Tue', 'Wed',\n  'Thu', 'Fri', 'Sat'\n]\n\nconst IMFMonths = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  validateCookieName,\n  validateCookiePath,\n  validateCookieValue,\n  toIMFDate,\n  stringify\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9049, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cookies/parse.js"],"sourcesContent":["'use strict'\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = require('./constants')\nconst { isCTLExcludingHtab } = require('./util')\nconst { collectASequenceOfCodePointsFast } = require('../fetch/data-url')\nconst assert = require('node:assert')\nconst { unescape: qsUnescape } = require('node:querystring')\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns {import('./index').Cookie|null} if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  // https://datatracker.ietf.org/doc/html/rfc6265\n  // To maximize compatibility with user agents, servers that wish to\n  // store arbitrary data in a cookie-value SHOULD encode that data, for\n  // example, using Base64 [RFC4648].\n  return {\n    name, value: qsUnescape(value), ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {Object.<string, unknown>} [cookieAttributeList={}]\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9319, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/cookies/index.js"],"sourcesContent":["'use strict'\n\nconst { parseSetCookie } = require('./parse')\nconst { stringify } = require('./util')\nconst { webidl } = require('../webidl')\nconst { Headers } = require('../fetch/headers')\n\nconst brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean))\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number} [expires]\n * @property {number} [maxAge]\n * @property {string} [domain]\n * @property {string} [path]\n * @property {boolean} [secure]\n * @property {boolean} [httpOnly]\n * @property {'Strict'|'Lax'|'None'} [sameSite]\n * @property {string[]} [unparsed]\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getCookies')\n\n  brandChecks(headers)\n\n  const cookie = headers.get('cookie')\n\n  /** @type {Record<string, string>} */\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  brandChecks(headers)\n\n  const prefix = 'deleteCookie'\n  webidl.argumentLengthCheck(arguments, 2, prefix)\n\n  name = webidl.converters.DOMString(name, prefix, 'name')\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getSetCookies')\n\n  brandChecks(headers)\n\n  const cookies = headers.getSetCookie()\n\n  if (!cookies) {\n    return []\n  }\n\n  return cookies.map((pair) => parseSetCookie(pair))\n}\n\n/**\n * Parses a cookie string\n * @param {string} cookie\n */\nfunction parseCookie (cookie) {\n  cookie = webidl.converters.DOMString(cookie)\n\n  return parseSetCookie(cookie)\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, 'setCookie')\n\n  brandChecks(headers)\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('set-cookie', str, true)\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: () => []\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie,\n  parseCookie\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9490, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/events.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../webidl')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { kConstruct } = require('../../core/symbols')\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    if (type === kConstruct) {\n      super(arguments[1], arguments[2])\n      webidl.util.markAsUncloneable(this)\n      return\n    }\n\n    const prefix = 'MessageEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict')\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent')\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n\n  static createFastMessageEvent (type, init) {\n    const messageEvent = new MessageEvent(kConstruct, type, init)\n    messageEvent.#eventInit = init\n    messageEvent.#eventInit.data ??= null\n    messageEvent.#eventInit.origin ??= ''\n    messageEvent.#eventInit.lastEventId ??= ''\n    messageEvent.#eventInit.source ??= null\n    messageEvent.#eventInit.ports ??= []\n    return messageEvent\n  }\n}\n\nconst { createFastMessageEvent } = MessageEvent\ndelete MessageEvent.createFastMessageEvent\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    const prefix = 'CloseEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    const prefix = 'ErrorEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    super(type, eventInitDict)\n    webidl.util.markAsUncloneable(this)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(\n  webidl.is.MessagePort,\n  'MessagePort'\n)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: () => null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: () => null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    defaultValue: () => []\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent,\n  createFastMessageEvent\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9755, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/constants.js"],"sourcesContent":["'use strict'\n\n/**\n * This is a Globally Unique Identifier unique used to validate that the\n * endpoint accepts websocket connections.\n * @see https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\n * @type {'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'}\n */\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/**\n * @type {PropertyDescriptor}\n */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * The states of the WebSocket connection.\n *\n * @readonly\n * @enum\n * @property {0} CONNECTING\n * @property {1} OPEN\n * @property {2} CLOSING\n * @property {3} CLOSED\n */\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\n/**\n * @readonly\n * @enum\n * @property {0} NOT_SENT\n * @property {1} PROCESSING\n * @property {2} SENT\n */\nconst sentCloseFrameState = {\n  SENT: 1,\n  RECEIVED: 2\n}\n\n/**\n * The WebSocket opcodes.\n *\n * @readonly\n * @enum\n * @property {0x0} CONTINUATION\n * @property {0x1} TEXT\n * @property {0x2} BINARY\n * @property {0x8} CLOSE\n * @property {0x9} PING\n * @property {0xA} PONG\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n */\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\n/**\n * The maximum value for an unsigned 16-bit integer.\n *\n * @type {65535} 2 ** 16 - 1\n */\nconst maxUnsigned16Bit = 65535\n\n/**\n * The states of the parser.\n *\n * @readonly\n * @enum\n * @property {0} INFO\n * @property {2} PAYLOADLENGTH_16\n * @property {3} PAYLOADLENGTH_64\n * @property {4} READ_DATA\n */\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\n/**\n * An empty buffer.\n *\n * @type {Buffer}\n */\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n/**\n * @readonly\n * @property {1} text\n * @property {2} typedArray\n * @property {3} arrayBuffer\n * @property {4} blob\n */\nconst sendHints = {\n  text: 1,\n  typedArray: 2,\n  arrayBuffer: 3,\n  blob: 4\n}\n\nmodule.exports = {\n  uid,\n  sentCloseFrameState,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer,\n  sendHints\n}\n"],"names":[],"mappings":"AAEA;;;;;CAKC,GACD,MAAM,MAAM;AAEZ;;CAEC,GACD,MAAM,4BAA4B;IAChC,YAAY;IACZ,UAAU;IACV,cAAc;AAChB;AAEA;;;;;;;;;CASC,GACD,MAAM,SAAS;IACb,YAAY;IACZ,MAAM;IACN,SAAS;IACT,QAAQ;AACV;AAEA;;;;;;CAMC,GACD,MAAM,sBAAsB;IAC1B,MAAM;IACN,UAAU;AACZ;AAEA;;;;;;;;;;;;CAYC,GACD,MAAM,UAAU;IACd,cAAc;IACd,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;IACN,MAAM;AACR;AAEA;;;;CAIC,GACD,MAAM,mBAAmB;AAEzB;;;;;;;;;CASC,GACD,MAAM,eAAe;IACnB,MAAM;IACN,kBAAkB;IAClB,kBAAkB;IAClB,WAAW;AACb;AAEA;;;;CAIC,GACD,MAAM,cAAc,OAAO,WAAW,CAAC;AAEvC;;;;;;CAMC,GACD,MAAM,YAAY;IAChB,MAAM;IACN,YAAY;IACZ,aAAa;IACb,MAAM;AACR;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9865, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/util.js"],"sourcesContent":["'use strict'\n\nconst { states, opcodes } = require('./constants')\nconst { isUtf8 } = require('node:buffer')\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require('../fetch/data-url')\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isConnecting (readyState) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return readyState === states.CONNECTING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isEstablished (readyState) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return readyState === states.OPEN\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosing (readyState) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return readyState === states.CLOSING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosed (readyState) {\n  return readyState === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n * @returns {void}\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').Handler} handler\n * @param {number} type Opcode\n * @param {Buffer} data application data\n * @returns {void}\n */\nfunction websocketMessageReceived (handler, type, data) {\n  handler.onMessage(type, data)\n}\n\n/**\n * @param {Buffer} buffer\n * @returns {ArrayBuffer}\n */\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return new Uint8Array(buffer).buffer\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n * @returns {boolean}\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n * @returns {boolean}\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\n/**\n *\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=', 2)\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://whatpr.org/websockets/48/7b748d3...d5570f3.html#get-a-url-record\n * @param {string} url\n * @param {string} [baseURL]\n */\nfunction getURLRecord (url, baseURL) {\n  // 1. Let urlRecord be the result of applying the URL parser to url with baseURL .\n  // 2. If urlRecord is failure, then throw a \" SyntaxError \" DOMException .\n  let urlRecord\n\n  try {\n    urlRecord = new URL(url, baseURL)\n  } catch (e) {\n    throw new DOMException(e, 'SyntaxError')\n  }\n\n  // 3. If urlRecord ’s scheme is \" http \", then set urlRecord ’s scheme to \" ws \".\n  // 4. Otherwise, if urlRecord ’s scheme is \" https \", set urlRecord ’s scheme to \" wss \".\n  if (urlRecord.protocol === 'http:') {\n    urlRecord.protocol = 'ws:'\n  } else if (urlRecord.protocol === 'https:') {\n    urlRecord.protocol = 'wss:'\n  }\n\n  // 5. If urlRecord ’s scheme is not \" ws \" or \" wss \", then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n    throw new DOMException('expected a ws: or wss: url', 'SyntaxError')\n  }\n\n  // If urlRecord ’s fragment is non-null, then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.hash.length || urlRecord.href.endsWith('#')) {\n    throw new DOMException('hash', 'SyntaxError')\n  }\n\n  // Return urlRecord .\n  return urlRecord\n}\n\n// https://whatpr.org/websockets/48.html#validate-close-code-and-reason\nfunction validateCloseCodeAndReason (code, reason) {\n  // 1. If code is not null, but is neither an integer equal to\n  //    1000 nor an integer in the range 3000 to 4999, inclusive,\n  //    throw an \"InvalidAccessError\" DOMException.\n  if (code !== null) {\n    if (code !== 1000 && (code < 3000 || code > 4999)) {\n      throw new DOMException('invalid code', 'InvalidAccessError')\n    }\n  }\n\n  // 2. If reason is not null, then:\n  if (reason !== null) {\n    // 2.1. Let reasonBytes be the result of UTF-8 encoding reason.\n    // 2.2. If reasonBytes is longer than 123 bytes, then throw a\n    //      \"SyntaxError\" DOMException.\n    const reasonBytesLength = Buffer.byteLength(reason)\n\n    if (reasonBytesLength > 123) {\n      throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, 'SyntaxError')\n    }\n  }\n}\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @type {(buffer: Buffer) => string}\n */\nconst utf8Decode = (() => {\n  if (typeof process.versions.icu === 'string') {\n    const fatalDecoder = new TextDecoder('utf-8', { fatal: true })\n    return fatalDecoder.decode.bind(fatalDecoder)\n  }\n  return function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n})()\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits,\n  toArrayBuffer,\n  getURLRecord,\n  validateCloseCodeAndReason\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE;AACzB,MAAM,EAAE,MAAM,EAAE;AAChB,MAAM,EAAE,gCAAgC,EAAE,oBAAoB,EAAE;AAEhE;;;CAGC,GACD,SAAS,aAAc,UAAU;IAC/B,yEAAyE;IACzE,+EAA+E;IAC/E,OAAO,eAAe,OAAO,UAAU;AACzC;AAEA;;;CAGC,GACD,SAAS,cAAe,UAAU;IAChC,qEAAqE;IACrE,mEAAmE;IACnE,6CAA6C;IAC7C,OAAO,eAAe,OAAO,IAAI;AACnC;AAEA;;;CAGC,GACD,SAAS,UAAW,UAAU;IAC5B,qEAAqE;IACrE,iEAAiE;IACjE,gDAAgD;IAChD,OAAO,eAAe,OAAO,OAAO;AACtC;AAEA;;;CAGC,GACD,SAAS,SAAU,UAAU;IAC3B,OAAO,eAAe,OAAO,MAAM;AACrC;AAEA;;;;;;;CAOC,GACD,SAAS,UAAW,CAAC,EAAE,MAAM,EAAE,eAAe,CAAC,MAAM,OAAS,IAAI,MAAM,MAAM,KAAK,EAAE,gBAAgB,CAAC,CAAC;IACrG,2EAA2E;IAE3E,0EAA0E;IAC1E,sCAAsC;IACtC,6CAA6C;IAC7C,MAAM,QAAQ,aAAa,GAAG;IAE9B,sEAAsE;IACtE,mCAAmC;IAEnC,0EAA0E;IAC1E,+BAA+B;IAC/B,OAAO,aAAa,CAAC;AACvB;AAEA;;;;;;CAMC,GACD,SAAS,yBAA0B,OAAO,EAAE,IAAI,EAAE,IAAI;IACpD,QAAQ,SAAS,CAAC,MAAM;AAC1B;AAEA;;;CAGC,GACD,SAAS,cAAe,MAAM;IAC5B,IAAI,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC,UAAU,EAAE;QAClD,OAAO,OAAO,MAAM;IACtB;IACA,OAAO,IAAI,WAAW,QAAQ,MAAM;AACtC;AAEA;;;;;;CAMC,GACD,SAAS,mBAAoB,QAAQ;IACnC,uCAAuC;IACvC,kEAAkE;IAClE,gEAAgE;IAChE,mEAAmE;IACnE,0DAA0D;IAC1D,4CAA4C;IAC5C,IAAI,SAAS,MAAM,KAAK,GAAG;QACzB,OAAO;IACT;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,EAAE,EAAG;QACxC,MAAM,OAAO,SAAS,UAAU,CAAC;QAEjC,IACE,OAAO,QAAQ,wCAAwC;QACvD,OAAO,QACP,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,QAAQ,IAAI;QACrB,SAAS,KAAK,IAAI;UAClB;YACA,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA;;;;CAIC,GACD,SAAS,kBAAmB,IAAI;IAC9B,IAAI,QAAQ,QAAQ,OAAO,MAAM;QAC/B,OACE,SAAS,QAAQ,WAAW;QAC5B,SAAS,QAAQ,qCAAqC;QACtD,SAAS,KAAK,qCAAqC;;IAEvD;IAEA,OAAO,QAAQ,QAAQ,QAAQ;AACjC;AAEA;;;;CAIC,GACD,SAAS,eAAgB,MAAM;IAC7B,OACE,WAAW,QAAQ,KAAK,IACxB,WAAW,QAAQ,IAAI,IACvB,WAAW,QAAQ,IAAI;AAE3B;AAEA;;;CAGC,GACD,SAAS,oBAAqB,MAAM;IAClC,OAAO,WAAW,QAAQ,YAAY;AACxC;AAEA;;;CAGC,GACD,SAAS,kBAAmB,MAAM;IAChC,OAAO,WAAW,QAAQ,IAAI,IAAI,WAAW,QAAQ,MAAM;AAC7D;AAEA;;;;CAIC,GACD,SAAS,cAAe,MAAM;IAC5B,OAAO,kBAAkB,WAAW,oBAAoB,WAAW,eAAe;AACpF;AAEA;;;;CAIC,GACD,uGAAuG;AACvG,SAAS,gBAAiB,UAAU;IAClC,MAAM,WAAW;QAAE,UAAU;IAAE;IAC/B,MAAM,gBAAgB,IAAI;IAE1B,MAAO,SAAS,QAAQ,GAAG,WAAW,MAAM,CAAE;QAC5C,MAAM,OAAO,iCAAiC,KAAK,YAAY;QAC/D,MAAM,CAAC,MAAM,QAAQ,EAAE,CAAC,GAAG,KAAK,KAAK,CAAC,KAAK;QAE3C,cAAc,GAAG,CACf,qBAAqB,MAAM,MAAM,QACjC,qBAAqB,OAAO,OAAO;QAGrC,SAAS,QAAQ;IACnB;IAEA,OAAO;AACT;AAEA;;;;;CAKC,GACD,SAAS,wBAAyB,KAAK;IACrC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,MAAM,OAAO,MAAM,UAAU,CAAC;QAE9B,IAAI,OAAO,QAAQ,OAAO,MAAM;YAC9B,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA;;;;CAIC,GACD,SAAS,aAAc,GAAG,EAAE,OAAO;IACjC,kFAAkF;IAClF,0EAA0E;IAC1E,IAAI;IAEJ,IAAI;QACF,YAAY,IAAI,IAAI,KAAK;IAC3B,EAAE,OAAO,GAAG;QACV,MAAM,IAAI,aAAa,GAAG;IAC5B;IAEA,iFAAiF;IACjF,yFAAyF;IACzF,IAAI,UAAU,QAAQ,KAAK,SAAS;QAClC,UAAU,QAAQ,GAAG;IACvB,OAAO,IAAI,UAAU,QAAQ,KAAK,UAAU;QAC1C,UAAU,QAAQ,GAAG;IACvB;IAEA,kGAAkG;IAClG,IAAI,UAAU,QAAQ,KAAK,SAAS,UAAU,QAAQ,KAAK,QAAQ;QACjE,MAAM,IAAI,aAAa,8BAA8B;IACvD;IAEA,oFAAoF;IACpF,IAAI,UAAU,IAAI,CAAC,MAAM,IAAI,UAAU,IAAI,CAAC,QAAQ,CAAC,MAAM;QACzD,MAAM,IAAI,aAAa,QAAQ;IACjC;IAEA,qBAAqB;IACrB,OAAO;AACT;AAEA,uEAAuE;AACvE,SAAS,2BAA4B,IAAI,EAAE,MAAM;IAC/C,6DAA6D;IAC7D,+DAA+D;IAC/D,iDAAiD;IACjD,IAAI,SAAS,MAAM;QACjB,IAAI,SAAS,QAAQ,CAAC,OAAO,QAAQ,OAAO,IAAI,GAAG;YACjD,MAAM,IAAI,aAAa,gBAAgB;QACzC;IACF;IAEA,kCAAkC;IAClC,IAAI,WAAW,MAAM;QACnB,+DAA+D;QAC/D,6DAA6D;QAC7D,mCAAmC;QACnC,MAAM,oBAAoB,OAAO,UAAU,CAAC;QAE5C,IAAI,oBAAoB,KAAK;YAC3B,MAAM,IAAI,aAAa,CAAC,6CAA6C,EAAE,mBAAmB,EAAE;QAC9F;IACF;AACF;AAEA;;;CAGC,GACD,MAAM,aAAa,CAAC;IAClB,IAAI,OAAO,QAAQ,QAAQ,CAAC,GAAG,KAAK,UAAU;QAC5C,MAAM,eAAe,IAAI,YAAY,SAAS;YAAE,OAAO;QAAK;QAC5D,OAAO,aAAa,MAAM,CAAC,IAAI,CAAC;IAClC;IACA,OAAO,SAAU,MAAM;QACrB,IAAI,OAAO,SAAS;YAClB,OAAO,OAAO,QAAQ,CAAC;QACzB;QACA,MAAM,IAAI,UAAU;IACtB;AACF,CAAC;AAED,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10143, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/frame.js"],"sourcesContent":["'use strict'\n\nconst { maxUnsigned16Bit, opcodes } = require('./constants')\n\nconst BUFFER_SIZE = 8 * 1024\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n\n  /**\n   * @param {Uint8Array} buffer\n   */\n  static createFastTextFrame (buffer) {\n    const maskKey = generateMask()\n\n    const bodyLength = buffer.length\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[i] ^= maskKey[i & 3]\n    }\n\n    let payloadLength = bodyLength\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n    const head = Buffer.allocUnsafeSlow(offset)\n\n    head[0] = 0x80 /* FIN */ | opcodes.TEXT /* opcode TEXT */\n    head[1] = payloadLength | 0x80 /* MASK */\n    head[offset - 4] = maskKey[0]\n    head[offset - 3] = maskKey[1]\n    head[offset - 2] = maskKey[2]\n    head[offset - 1] = maskKey[3]\n\n    if (payloadLength === 126) {\n      head.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      head[2] = head[3] = 0\n      head.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    return [head, buffer]\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend,\n  generateMask // for benchmark\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10262, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/connection.js"],"sourcesContent":["'use strict'\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require('./constants')\nconst { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = require('./util')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { Headers, getHeadersList } = require('../fetch/headers')\nconst { getDecodeSplit } = require('../fetch/util')\nconst { WebsocketFrameSend } = require('./frame')\nconst assert = require('node:assert')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').Handler} handler\n * @param {Partial<import('../../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, handler, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue, true)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13', true)\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol, true)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate, true)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      if (response.type === 'error') {\n        // If the WebSocket connection could not be established, it is also said\n        // that _The WebSocket Connection is Closed_, but not _cleanly_.\n        handler.readyState = states.CLOSED\n      }\n\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(handler, 1002, 'Received network error or non-101 status code.', response.error)\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(handler, 1002, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(handler, 1002, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(handler, 1002, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(handler, 1002, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', handler.onSocketData)\n      response.socket.on('close', handler.onSocketClose)\n      response.socket.on('error', handler.onSocketError)\n\n      handler.wasEverConnected = true\n      handler.onConnectionEstablished(response, extensions)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @see https://whatpr.org/websockets/48.html#close-the-websocket\n * @param {import('./websocket').Handler} object\n * @param {number} [code=null]\n * @param {string} [reason='']\n */\nfunction closeWebSocketConnection (object, code, reason, validate = false) {\n  // 1. If code was not supplied, let code be null.\n  code ??= null\n\n  // 2. If reason was not supplied, let reason be the empty string.\n  reason ??= ''\n\n  // 3. Validate close code and reason with code and reason.\n  if (validate) validateCloseCodeAndReason(code, reason)\n\n  // 4. Run the first matching steps from the following list:\n  //     - If object’s ready state is CLOSING (2) or CLOSED (3)\n  //     - If the WebSocket connection is not yet established [WSP]\n  //     - If the WebSocket closing handshake has not yet been started [WSP]\n  //     - Otherwise\n  if (isClosed(object.readyState) || isClosing(object.readyState)) {\n    // Do nothing.\n  } else if (!isEstablished(object.readyState)) {\n    // Fail the WebSocket connection and set object’s ready state to CLOSING (2). [WSP]\n    failWebsocketConnection(object)\n    object.readyState = states.CLOSING\n  } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    // If code is null and reason is the empty string, the WebSocket Close frame must not have a body.\n    // If reason is non-empty but code is null, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // If code is set, then the status code to use in the WebSocket Close frame must be the integer given by code.\n    assert(code === null || Number.isInteger(code))\n\n    if (code === null && reason.length === 0) {\n      frame.frameData = emptyBuffer\n    } else if (code !== null && reason === null) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== null && reason !== null) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason))\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    object.socket.write(frame.createFrame(opcodes.CLOSE))\n\n    object.closeState.add(sentCloseFrameState.SENT)\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    object.readyState = states.CLOSING\n  } else {\n    // Set object’s ready state to CLOSING (2).\n    object.readyState = states.CLOSING\n  }\n}\n\n/**\n * @param {import('./websocket').Handler} handler\n * @param {number} code\n * @param {string|undefined} reason\n * @param {unknown} cause\n * @returns {void}\n */\nfunction failWebsocketConnection (handler, code, reason, cause) {\n  // If _The WebSocket Connection is Established_ prior to the point where\n  // the endpoint is required to _Fail the WebSocket Connection_, the\n  // endpoint SHOULD send a Close frame with an appropriate status code\n  // (Section 7.4) before proceeding to _Close the WebSocket Connection_.\n  if (isEstablished(handler.readyState)) {\n    closeWebSocketConnection(handler, code, reason, false)\n  }\n\n  handler.controller.abort()\n\n  if (!handler.socket) {\n    // If the connection was not established, we must still emit an 'error' and 'close' events\n    handler.onSocketClose()\n  } else if (handler.socket.destroyed === false) {\n    handler.socket.destroy()\n  }\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  failWebsocketConnection,\n  closeWebSocketConnection\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10532, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/permessage-deflate.js"],"sourcesContent":["'use strict'\n\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require('node:zlib')\nconst { isValidClientWindowBits } = require('./util')\n\nconst tail = Buffer.from([0x00, 0x00, 0xff, 0xff])\nconst kBuffer = Symbol('kBuffer')\nconst kLength = Symbol('kLength')\n\nclass PerMessageDeflate {\n  /** @type {import('node:zlib').InflateRaw} */\n  #inflate\n\n  #options = {}\n\n  constructor (extensions) {\n    this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover')\n    this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits')\n  }\n\n  decompress (chunk, fin, callback) {\n    // An endpoint uses the following algorithm to decompress a message.\n    // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n    //     payload of the message.\n    // 2.  Decompress the resulting data using DEFLATE.\n\n    if (!this.#inflate) {\n      let windowBits = Z_DEFAULT_WINDOWBITS\n\n      if (this.#options.serverMaxWindowBits) { // empty values default to Z_DEFAULT_WINDOWBITS\n        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n          callback(new Error('Invalid server_max_window_bits'))\n          return\n        }\n\n        windowBits = Number.parseInt(this.#options.serverMaxWindowBits)\n      }\n\n      this.#inflate = createInflateRaw({ windowBits })\n      this.#inflate[kBuffer] = []\n      this.#inflate[kLength] = 0\n\n      this.#inflate.on('data', (data) => {\n        this.#inflate[kBuffer].push(data)\n        this.#inflate[kLength] += data.length\n      })\n\n      this.#inflate.on('error', (err) => {\n        this.#inflate = null\n        callback(err)\n      })\n    }\n\n    this.#inflate.write(chunk)\n    if (fin) {\n      this.#inflate.write(tail)\n    }\n\n    this.#inflate.flush(() => {\n      const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength])\n\n      this.#inflate[kBuffer].length = 0\n      this.#inflate[kLength] = 0\n\n      callback(null, full)\n    })\n  }\n}\n\nmodule.exports = { PerMessageDeflate }\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,gBAAgB,EAAE,oBAAoB,EAAE;AAChD,MAAM,EAAE,uBAAuB,EAAE;AAEjC,MAAM,OAAO,OAAO,IAAI,CAAC;IAAC;IAAM;IAAM;IAAM;CAAK;AACjD,MAAM,UAAU,OAAO;AACvB,MAAM,UAAU,OAAO;AAEvB,MAAM;IACJ,2CAA2C,GAC3C,CAAA,OAAQ,CAAA;IAER,CAAA,OAAQ,GAAG,CAAC,EAAC;IAEb,YAAa,UAAU,CAAE;QACvB,IAAI,CAAC,CAAA,OAAQ,CAAC,uBAAuB,GAAG,WAAW,GAAG,CAAC;QACvD,IAAI,CAAC,CAAA,OAAQ,CAAC,mBAAmB,GAAG,WAAW,GAAG,CAAC;IACrD;IAEA,WAAY,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE;QAChC,oEAAoE;QACpE,oEAAoE;QACpE,8BAA8B;QAC9B,mDAAmD;QAEnD,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,EAAE;YAClB,IAAI,aAAa;YAEjB,IAAI,IAAI,CAAC,CAAA,OAAQ,CAAC,mBAAmB,EAAE;gBACrC,IAAI,CAAC,wBAAwB,IAAI,CAAC,CAAA,OAAQ,CAAC,mBAAmB,GAAG;oBAC/D,SAAS,IAAI,MAAM;oBACnB;gBACF;gBAEA,aAAa,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAA,OAAQ,CAAC,mBAAmB;YAChE;YAEA,IAAI,CAAC,CAAA,OAAQ,GAAG,iBAAiB;gBAAE;YAAW;YAC9C,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,GAAG,EAAE;YAC3B,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,GAAG;YAEzB,IAAI,CAAC,CAAA,OAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC;gBACxB,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;gBAC5B,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,IAAI,KAAK,MAAM;YACvC;YAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,EAAE,CAAC,SAAS,CAAC;gBACzB,IAAI,CAAC,CAAA,OAAQ,GAAG;gBAChB,SAAS;YACX;QACF;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,KAAK,CAAC;QACpB,IAAI,KAAK;YACP,IAAI,CAAC,CAAA,OAAQ,CAAC,KAAK,CAAC;QACtB;QAEA,IAAI,CAAC,CAAA,OAAQ,CAAC,KAAK,CAAC;YAClB,MAAM,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ;YAEzE,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG;YAChC,IAAI,CAAC,CAAA,OAAQ,CAAC,QAAQ,GAAG;YAEzB,SAAS,MAAM;QACjB;IACF;AACF;AAEA,OAAO,OAAO,GAAG;IAAE;AAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10596, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/receiver.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('node:stream')\nconst assert = require('node:assert')\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require('./constants')\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = require('./util')\nconst { failWebsocketConnection } = require('./connection')\nconst { WebsocketFrameSend } = require('./frame')\nconst { PerMessageDeflate } = require('./permessage-deflate')\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #fragmentsBytes = 0\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  /** @type {import('./websocket').Handler} */\n  #handler\n\n  constructor (handler, extensions) {\n    super()\n\n    this.#handler = handler\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.#handler, 1002, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.#handler, 1002, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.#handler, 1002, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.#handler, 1002, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.#handler, 1002, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.#handler, 1009, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.writeFragments(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                failWebsocketConnection(this.#handler, 1007, error.message)\n                return\n              }\n\n              this.writeFragments(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    this.#byteOffset -= n\n\n    const first = this.#buffers[0]\n\n    if (first.length > n) {\n      // replace with remaining buffer\n      this.#buffers[0] = first.subarray(n, first.length)\n      return first.subarray(0, n)\n    } else if (first.length === n) {\n      // prefect match\n      return this.#buffers.shift()\n    } else {\n      let offset = 0\n      // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n      const buffer = Buffer.allocUnsafeSlow(n)\n      while (offset !== n) {\n        const next = this.#buffers[0]\n        const length = next.length\n\n        if (length + offset === n) {\n          buffer.set(this.#buffers.shift(), offset)\n          break\n        } else if (length + offset > n) {\n          buffer.set(next.subarray(0, n - offset), offset)\n          this.#buffers[0] = next.subarray(n - offset)\n          break\n        } else {\n          buffer.set(this.#buffers.shift(), offset)\n          offset += length\n        }\n      }\n\n      return buffer\n    }\n  }\n\n  writeFragments (fragment) {\n    this.#fragmentsBytes += fragment.length\n    this.#fragments.push(fragment)\n  }\n\n  consumeFragments () {\n    const fragments = this.#fragments\n\n    if (fragments.length === 1) {\n      // single fragment\n      this.#fragmentsBytes = 0\n      return fragments.shift()\n    }\n\n    let offset = 0\n    // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n    const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes)\n\n    for (let i = 0; i < fragments.length; ++i) {\n      const buffer = fragments[i]\n      output.set(buffer, offset)\n      offset += buffer.length\n    }\n\n    this.#fragments = []\n    this.#fragmentsBytes = 0\n\n    return output\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.#handler, 1002, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        failWebsocketConnection(this.#handler, code, reason)\n        return false\n      }\n\n      // Upon receiving such a frame, the other peer sends a\n      // Close frame in response, if it hasn't already sent one.\n      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE))\n        this.#handler.closeState.add(sentCloseFrameState.SENT)\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.#handler.readyState = states.CLOSING\n      this.#handler.closeState.add(sentCloseFrameState.RECEIVED)\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(frame.createFrame(opcodes.PONG))\n\n        this.#handler.onPing(body)\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n      this.#handler.onPong(body)\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10960, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/sender.js"],"sourcesContent":["'use strict'\n\nconst { WebsocketFrameSend } = require('./frame')\nconst { opcodes, sendHints } = require('./constants')\nconst FixedQueue = require('../../dispatcher/fixed-queue')\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      if (!this.#running) {\n        // TODO(@tsctx): support fast-path for string on running\n        if (hint === sendHints.text) {\n          // special fast-path for string\n          const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item)\n          this.#socket.cork()\n          this.#socket.write(head)\n          this.#socket.write(body, cb)\n          this.#socket.uncork()\n        } else {\n          // direct writing\n          this.#socket.write(createFrame(item, hint), cb)\n        }\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame: createFrame(item, hint)\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.text:\n    case sendHints.typedArray:\n      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new Uint8Array(data)\n  }\n}\n\nmodule.exports = { SendQueue }\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,kBAAkB,EAAE;AAC5B,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE;AAC5B,MAAM;AAEN;;;;;CAKC,GAED,MAAM;IACJ;;GAEC,GACD,CAAA,KAAM,GAAG,IAAI,aAAY;IAEzB;;GAEC,GACD,CAAA,OAAQ,GAAG,MAAK;IAEhB,sCAAsC,GACtC,CAAA,MAAO,CAAA;IAEP,YAAa,MAAM,CAAE;QACnB,IAAI,CAAC,CAAA,MAAO,GAAG;IACjB;IAEA,IAAK,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE;QACnB,IAAI,SAAS,UAAU,IAAI,EAAE;YAC3B,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,EAAE;gBAClB,wDAAwD;gBACxD,IAAI,SAAS,UAAU,IAAI,EAAE;oBAC3B,+BAA+B;oBAC/B,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,mBAAmB,mBAAmB,CAAC;oBACpE,IAAI,CAAC,CAAA,MAAO,CAAC,IAAI;oBACjB,IAAI,CAAC,CAAA,MAAO,CAAC,KAAK,CAAC;oBACnB,IAAI,CAAC,CAAA,MAAO,CAAC,KAAK,CAAC,MAAM;oBACzB,IAAI,CAAC,CAAA,MAAO,CAAC,MAAM;gBACrB,OAAO;oBACL,iBAAiB;oBACjB,IAAI,CAAC,CAAA,MAAO,CAAC,KAAK,CAAC,YAAY,MAAM,OAAO;gBAC9C;YACF,OAAO;gBACL,0BAA0B,GAC1B,MAAM,OAAO;oBACX,SAAS;oBACT,UAAU;oBACV,OAAO,YAAY,MAAM;gBAC3B;gBACA,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI,CAAC;YACnB;YACA;QACF;QAEA,0BAA0B,GAC1B,MAAM,OAAO;YACX,SAAS,KAAK,WAAW,GAAG,IAAI,CAAC,CAAC;gBAChC,KAAK,OAAO,GAAG;gBACf,KAAK,KAAK,GAAG,YAAY,IAAI;YAC/B;YACA,UAAU;YACV,OAAO;QACT;QAEA,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI,CAAC;QAEjB,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,EAAE;YAClB,IAAI,CAAC,CAAA,GAAI;QACX;IACF;IAEA,MAAM,CAAA,GAAI;QACR,IAAI,CAAC,CAAA,OAAQ,GAAG;QAChB,MAAM,QAAQ,IAAI,CAAC,CAAA,KAAM;QACzB,MAAO,CAAC,MAAM,OAAO,GAAI;YACvB,MAAM,OAAO,MAAM,KAAK;YACxB,uBAAuB;YACvB,IAAI,KAAK,OAAO,KAAK,MAAM;gBACzB,MAAM,KAAK,OAAO;YACpB;YACA,QAAQ;YACR,IAAI,CAAC,CAAA,MAAO,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,KAAK,QAAQ;YAC5C,UAAU;YACV,KAAK,QAAQ,GAAG,KAAK,KAAK,GAAG;QAC/B;QACA,IAAI,CAAC,CAAA,OAAQ,GAAG;IAClB;AACF;AAEA,SAAS,YAAa,IAAI,EAAE,IAAI;IAC9B,OAAO,IAAI,mBAAmB,SAAS,MAAM,OAAO,WAAW,CAAC,SAAS,UAAU,IAAI,GAAG,QAAQ,IAAI,GAAG,QAAQ,MAAM;AACzH;AAEA,SAAS,SAAU,IAAI,EAAE,IAAI;IAC3B,OAAQ;QACN,KAAK,UAAU,IAAI;QACnB,KAAK,UAAU,UAAU;YACvB,OAAO,IAAI,WAAW,KAAK,MAAM,EAAE,KAAK,UAAU,EAAE,KAAK,UAAU;QACrE,KAAK,UAAU,WAAW;QAC1B,KAAK,UAAU,IAAI;YACjB,OAAO,IAAI,WAAW;IAC1B;AACF;AAEA,OAAO,OAAO,GAAG;IAAE;AAAU","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11054, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { isArrayBuffer } = require('node:util/types')\nconst { webidl } = require('../webidl')\nconst { URLSerializer } = require('../fetch/data-url')\nconst { environmentSettingsObject } = require('../fetch/util')\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = require('./constants')\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  isValidSubprotocol,\n  fireEvent,\n  utf8Decode,\n  toArrayBuffer,\n  getURLRecord\n} = require('./util')\nconst { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = require('./connection')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { getGlobalDispatcher } = require('../../global')\nconst { ErrorEvent, CloseEvent, createFastMessageEvent } = require('./events')\nconst { SendQueue } = require('./sender')\nconst { WebsocketFrameSend } = require('./frame')\nconst { channels } = require('../../core/diagnostics')\n\n/**\n * @typedef {object} Handler\n * @property {(response: any, extensions?: string[]) => void} onConnectionEstablished\n * @property {(opcode: number, data: Buffer) => void} onMessage\n * @property {(error: Error) => void} onParserError\n * @property {() => void} onParserDrain\n * @property {(chunk: Buffer) => void} onSocketData\n * @property {(err: Error) => void} onSocketError\n * @property {() => void} onSocketClose\n * @property {(body: Buffer) => void} onPing\n * @property {(body: Buffer) => void} onPong\n *\n * @property {number} readyState\n * @property {import('stream').Duplex} socket\n * @property {Set<number>} closeState\n * @property {import('../fetch/index').Fetch} controller\n * @property {boolean} [wasEverConnected=false]\n */\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /** @type {Handler} */\n  #handler = {\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#onParserDrain(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n    onPing: (body) => {\n      if (channels.ping.hasSubscribers) {\n        channels.ping.publish({\n          payload: body,\n          websocket: this\n        })\n      }\n    },\n    onPong: (body) => {\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body,\n          websocket: this\n        })\n      }\n    },\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  #url\n  #binaryType\n  /** @type {import('./receiver').ByteParser} */\n  #parser\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL.\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 4. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this's url to urlRecord.\n    this.#url = new URL(urlRecord.href)\n\n    // 6. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 7. Run this step in parallel:\n    // 7.1. Establish a WebSocket connection given urlRecord, protocols,\n    //      and client.\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this.#handler.readyState = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this.#binaryType = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', webidl.attributes.Clamp)\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is the special value \"missing\", then set code to null.\n    code ??= null\n\n    // 2. If reason is the special value \"missing\", then set reason to the empty string.\n    reason ??= ''\n\n    // 3. Close the WebSocket with this, code, and reason.\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this.#handler.readyState)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const buffer = Buffer.from(data)\n\n      this.#bufferedAmount += buffer.byteLength\n      this.#sendQueue.add(buffer, () => {\n        this.#bufferedAmount -= buffer.byteLength\n      }, sendHints.text)\n    } else if (isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (webidl.is.Blob(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this.#handler.readyState\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this.#url)\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n      this.#events.open = fn\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n      this.#events.error = fn\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('close', listener)\n      this.#events.close = fn\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n      this.#events.message = fn\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#binaryType\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this.#binaryType = 'blob'\n    } else {\n      this.#binaryType = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n\n    if (channels.open.hasSubscribers) {\n      // Convert headers to a plain object for the event\n      const headers = response.headersList.entries\n      channels.open.publish({\n        address: response.socket.address(),\n        protocol: this.#protocol,\n        extensions: this.#extensions,\n        websocket: this,\n        handshakeResponse: {\n          status: response.status,\n          statusText: response.statusText,\n          headers\n        }\n      })\n    }\n  }\n\n  #onMessage (type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent\n\n    if (type === opcodes.TEXT) {\n      // -> type indicates that the data is Text\n      //      a new DOMString containing data\n      try {\n        dataForEvent = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 1007, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      if (this.#binaryType === 'blob') {\n        // -> type indicates that the data is Binary and binary type is \"blob\"\n        //      a new Blob object, created in the relevant Realm of the WebSocket\n        //      object, that represents data as its raw data\n        dataForEvent = new Blob([data])\n      } else {\n        // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n        //      a new ArrayBuffer object, created in the relevant Realm of the\n        //      WebSocket object, whose contents are data\n        dataForEvent = toArrayBuffer(data)\n      }\n    }\n\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    object’s url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent('message', this, createFastMessageEvent, {\n      origin: this.#url.origin,\n      data: dataForEvent\n    })\n  }\n\n  #onParserDrain () {\n    this.#handler.socket.resume()\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n   */\n  #onSocketClose () {\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    let code = 1005\n    let reason = ''\n\n    const result = this.#parser?.closingInfo\n\n    if (result && !result.error) {\n      code = result.code ?? 1005\n      reason = result.reason\n    }\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      // If _The WebSocket\n      // Connection is Closed_ and no Close control frame was received by the\n      // endpoint (such as could occur if the underlying transport connection\n      // is lost), _The WebSocket Connection Close Code_ is considered to be\n      // 1006.\n      code = 1006\n\n      fireEvent('error', this, (type, init) => new ErrorEvent(type, init), {\n        error: new TypeError(reason)\n      })\n    }\n\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    // TODO: process.nextTick\n    fireEvent('close', this, (type, init) => new CloseEvent(type, init), {\n      wasClean, code, reason\n    })\n\n    if (channels.close.hasSubscribers) {\n      channels.close.publish({\n        websocket: this,\n        code,\n        reason\n      })\n    }\n  }\n\n  /**\n   * @param {WebSocket} ws\n   * @param {Buffer|undefined} buffer\n   */\n  static ping (ws, buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      if (buffer.length > 125) {\n        throw new TypeError('A PING frame cannot have a body larger than 125 bytes.')\n      }\n    } else if (buffer !== undefined) {\n      throw new TypeError('Expected buffer payload')\n    }\n\n    // An endpoint MAY send a Ping frame any time after the connection is\n    // established and before the connection is closed.\n    const readyState = ws.#handler.readyState\n\n    if (isEstablished(readyState) && !isClosing(readyState) && !isClosed(readyState)) {\n      const frame = new WebsocketFrameSend(buffer)\n      ws.#handler.socket.write(frame.createFrame(opcodes.PING))\n    }\n  }\n}\n\nconst { ping } = WebSocket\nReflect.deleteProperty(WebSocket, 'ping')\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => []\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    if (webidl.is.Blob(V)) {\n      return V\n    }\n\n    if (webidl.is.BufferSource(V)) {\n      return V\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket,\n  ping\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11649, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/stream/websocketerror.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../../webidl')\nconst { validateCloseCodeAndReason } = require('../util')\nconst { kConstruct } = require('../../../core/symbols')\nconst { kEnumerableProperty } = require('../../../core/util')\n\nfunction createInheritableDOMException () {\n  // https://github.com/nodejs/node/issues/59677\n  class Test extends DOMException {\n    get reason () {\n      return ''\n    }\n  }\n\n  if (new Test().reason !== undefined) {\n    return DOMException\n  }\n\n  return new Proxy(DOMException, {\n    construct (target, args, newTarget) {\n      const instance = Reflect.construct(target, args, target)\n      Object.setPrototypeOf(instance, newTarget.prototype)\n      return instance\n    }\n  })\n}\n\nclass WebSocketError extends createInheritableDOMException() {\n  #closeCode\n  #reason\n\n  constructor (message = '', init = undefined) {\n    message = webidl.converters.DOMString(message, 'WebSocketError', 'message')\n\n    // 1. Set this 's name to \" WebSocketError \".\n    // 2. Set this 's message to message .\n    super(message, 'WebSocketError')\n\n    if (init === kConstruct) {\n      return\n    } else if (init !== null) {\n      init = webidl.converters.WebSocketCloseInfo(init)\n    }\n\n    // 3. Let code be init [\" closeCode \"] if it exists , or null otherwise.\n    let code = init.closeCode ?? null\n\n    // 4. Let reason be init [\" reason \"] if it exists , or the empty string otherwise.\n    const reason = init.reason ?? ''\n\n    // 5. Validate close code and reason with code and reason .\n    validateCloseCodeAndReason(code, reason)\n\n    // 6. If reason is non-empty, but code is not set, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // 7. Set this 's closeCode to code .\n    this.#closeCode = code\n\n    // 8. Set this 's reason to reason .\n    this.#reason = reason\n  }\n\n  get closeCode () {\n    return this.#closeCode\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  /**\n   * @param {string} message\n   * @param {number|null} code\n   * @param {string} reason\n   */\n  static createUnvalidatedWebSocketError (message, code, reason) {\n    const error = new WebSocketError(message, kConstruct)\n    error.#closeCode = code\n    error.#reason = reason\n    return error\n  }\n}\n\nconst { createUnvalidatedWebSocketError } = WebSocketError\ndelete WebSocketError.createUnvalidatedWebSocketError\n\nObject.defineProperties(WebSocketError.prototype, {\n  closeCode: kEnumerableProperty,\n  reason: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketError',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError)\n\nmodule.exports = { WebSocketError, createUnvalidatedWebSocketError }\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,MAAM,EAAE;AAChB,MAAM,EAAE,0BAA0B,EAAE;AACpC,MAAM,EAAE,UAAU,EAAE;AACpB,MAAM,EAAE,mBAAmB,EAAE;AAE7B,SAAS;IACP,8CAA8C;IAC9C,MAAM,aAAa;QACjB,IAAI,SAAU;YACZ,OAAO;QACT;IACF;IAEA,IAAI,IAAI,OAAO,MAAM,KAAK,WAAW;QACnC,OAAO;IACT;IAEA,OAAO,IAAI,MAAM,cAAc;QAC7B,WAAW,MAAM,EAAE,IAAI,EAAE,SAAS;YAChC,MAAM,WAAW,QAAQ,SAAS,CAAC,QAAQ,MAAM;YACjD,OAAO,cAAc,CAAC,UAAU,UAAU,SAAS;YACnD,OAAO;QACT;IACF;AACF;AAEA,MAAM,uBAAuB;IAC3B,CAAA,SAAU,CAAA;IACV,CAAA,MAAO,CAAA;IAEP,YAAa,UAAU,EAAE,EAAE,OAAO,SAAS,CAAE;QAC3C,UAAU,OAAO,UAAU,CAAC,SAAS,CAAC,SAAS,kBAAkB;QAEjE,6CAA6C;QAC7C,sCAAsC;QACtC,KAAK,CAAC,SAAS;QAEf,IAAI,SAAS,YAAY;YACvB;QACF,OAAO,IAAI,SAAS,MAAM;YACxB,OAAO,OAAO,UAAU,CAAC,kBAAkB,CAAC;QAC9C;QAEA,wEAAwE;QACxE,IAAI,OAAO,KAAK,SAAS,IAAI;QAE7B,mFAAmF;QACnF,MAAM,SAAS,KAAK,MAAM,IAAI;QAE9B,2DAA2D;QAC3D,2BAA2B,MAAM;QAEjC,4FAA4F;QAC5F,IAAI,OAAO,MAAM,KAAK,KAAK,SAAS,MAAM;YACxC,OAAO;QACT;QAEA,qCAAqC;QACrC,IAAI,CAAC,CAAA,SAAU,GAAG;QAElB,oCAAoC;QACpC,IAAI,CAAC,CAAA,MAAO,GAAG;IACjB;IAEA,IAAI,YAAa;QACf,OAAO,IAAI,CAAC,CAAA,SAAU;IACxB;IAEA,IAAI,SAAU;QACZ,OAAO,IAAI,CAAC,CAAA,MAAO;IACrB;IAEA;;;;GAIC,GACD,OAAO,gCAAiC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE;QAC7D,MAAM,QAAQ,IAAI,eAAe,SAAS;QAC1C,MAAM,CAAA,SAAU,GAAG;QACnB,MAAM,CAAA,MAAO,GAAG;QAChB,OAAO;IACT;AACF;AAEA,MAAM,EAAE,+BAA+B,EAAE,GAAG;AAC5C,OAAO,eAAe,+BAA+B;AAErD,OAAO,gBAAgB,CAAC,eAAe,SAAS,EAAE;IAChD,WAAW;IACX,QAAQ;IACR,CAAC,OAAO,WAAW,CAAC,EAAE;QACpB,OAAO;QACP,UAAU;QACV,YAAY;QACZ,cAAc;IAChB;AACF;AAEA,OAAO,EAAE,CAAC,cAAc,GAAG,OAAO,IAAI,CAAC,iBAAiB,CAAC;AAEzD,OAAO,OAAO,GAAG;IAAE;IAAgB;AAAgC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11737, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/websocket/stream/websocketstream.js"],"sourcesContent":["'use strict'\n\nconst { createDeferredPromise } = require('../../../util/promise')\nconst { environmentSettingsObject } = require('../../fetch/util')\nconst { states, opcodes, sentCloseFrameState } = require('../constants')\nconst { webidl } = require('../../webidl')\nconst { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = require('../util')\nconst { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = require('../connection')\nconst { channels } = require('../../../core/diagnostics')\nconst { WebsocketFrameSend } = require('../frame')\nconst { ByteParser } = require('../receiver')\nconst { WebSocketError, createUnvalidatedWebSocketError } = require('./websocketerror')\nconst { utf8DecodeBytes } = require('../../fetch/util')\nconst { kEnumerableProperty } = require('../../../core/util')\n\nlet emittedExperimentalWarning = false\n\nclass WebSocketStream {\n  // Each WebSocketStream object has an associated url , which is a URL record .\n  /** @type {URL} */\n  #url\n\n  // Each WebSocketStream object has an associated opened promise , which is a promise.\n  /** @type {import('../../../util/promise').DeferredPromise} */\n  #openedPromise\n\n  // Each WebSocketStream object has an associated closed promise , which is a promise.\n  /** @type {import('../../../util/promise').DeferredPromise} */\n  #closedPromise\n\n  // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .\n  /** @type {ReadableStream} */\n  #readableStream\n  /** @type {ReadableStreamDefaultController} */\n  #readableStreamController\n\n  // Each WebSocketStream object has an associated writable stream , which is a WritableStream .\n  /** @type {WritableStream} */\n  #writableStream\n\n  // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.\n  #handshakeAborted = false\n\n  /** @type {import('../websocket').Handler} */\n  #handler = {\n    // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#handler.socket.resume(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n    onPing: () => {},\n    onPong: () => {},\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  /** @type {import('../receiver').ByteParser} */\n  #parser\n\n  constructor (url, options = undefined) {\n    if (!emittedExperimentalWarning) {\n      process.emitWarning('WebSocketStream is experimental! Expect it to change at any time.', {\n        code: 'UNDICI-WSS'\n      })\n      emittedExperimentalWarning = true\n    }\n\n    webidl.argumentLengthCheck(arguments, 1, 'WebSocket')\n\n    url = webidl.converters.USVString(url)\n    if (options !== null) {\n      options = webidl.converters.WebSocketStreamOptions(options)\n    }\n\n    // 1. Let baseURL be this 's relevant settings object 's API base URL .\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL .\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. Let protocols be options [\" protocols \"] if it exists , otherwise an empty sequence.\n    const protocols = options.protocols\n\n    // 4. If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of ` Sec-WebSocket-Protocol ` fields as defined by The WebSocket Protocol , then throw a \" SyntaxError \" DOMException . [WSP]\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this 's url to urlRecord .\n    this.#url = urlRecord.toString()\n\n    // 6. Set this 's opened promise and closed promise to new promises.\n    this.#openedPromise = createDeferredPromise()\n    this.#closedPromise = createDeferredPromise()\n\n    // 7. Apply backpressure to the WebSocket.\n    // TODO\n\n    // 8.  If options [\" signal \"] exists ,\n    if (options.signal != null) {\n      // 8.1. Let signal be options [\" signal \"].\n      const signal = options.signal\n\n      // 8.2. If signal is aborted , then reject this 's opened promise and closed promise with signal ’s abort reason\n      //      and return.\n      if (signal.aborted) {\n        this.#openedPromise.reject(signal.reason)\n        this.#closedPromise.reject(signal.reason)\n        return\n      }\n\n      // 8.3. Add the following abort steps to signal :\n      signal.addEventListener('abort', () => {\n        // 8.3.1. If the WebSocket connection is not yet established : [WSP]\n        if (!isEstablished(this.#handler.readyState)) {\n          // 8.3.1.1. Fail the WebSocket connection .\n          failWebsocketConnection(this.#handler)\n\n          // Set this 's ready state to CLOSING .\n          this.#handler.readyState = states.CLOSING\n\n          // Reject this 's opened promise and closed promise with signal ’s abort reason .\n          this.#openedPromise.reject(signal.reason)\n          this.#closedPromise.reject(signal.reason)\n\n          // Set this 's handshake aborted to true.\n          this.#handshakeAborted = true\n        }\n      }, { once: true })\n    }\n\n    // 9.  Let client be this 's relevant settings object .\n    const client = environmentSettingsObject.settingsObject\n\n    // 10. Run this step in parallel :\n    // 10.1. Establish a WebSocket connection given urlRecord , protocols , and client . [FETCH]\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n  }\n\n  // The url getter steps are to return this 's url , serialized .\n  get url () {\n    return this.#url.toString()\n  }\n\n  // The opened getter steps are to return this 's opened promise .\n  get opened () {\n    return this.#openedPromise.promise\n  }\n\n  // The closed getter steps are to return this 's closed promise .\n  get closed () {\n    return this.#closedPromise.promise\n  }\n\n  // The close( closeInfo ) method steps are:\n  close (closeInfo = undefined) {\n    if (closeInfo !== null) {\n      closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo)\n    }\n\n    // 1. Let code be closeInfo [\" closeCode \"] if present, or null otherwise.\n    const code = closeInfo.closeCode ?? null\n\n    // 2. Let reason be closeInfo [\" reason \"].\n    const reason = closeInfo.reason\n\n    // 3. Close the WebSocket with this , code , and reason .\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  #write (chunk) {\n    // See /websockets/stream/tentative/write.any.html\n    chunk = webidl.converters.WebSocketStreamWrite(chunk)\n\n    // 1. Let promise be a new promise created in stream ’s relevant realm .\n    const promise = createDeferredPromise()\n\n    // 2. Let data be null.\n    let data = null\n\n    // 3. Let opcode be null.\n    let opcode = null\n\n    // 4. If chunk is a BufferSource ,\n    if (webidl.is.BufferSource(chunk)) {\n      // 4.1. Set data to a copy of the bytes given chunk .\n      data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk.slice())\n\n      // 4.2. Set opcode to a binary frame opcode.\n      opcode = opcodes.BINARY\n    } else {\n      // 5. Otherwise,\n\n      // 5.1. Let string be the result of converting chunk to an IDL USVString .\n      //    If this throws an exception, return a promise rejected with the exception.\n      let string\n\n      try {\n        string = webidl.converters.DOMString(chunk)\n      } catch (e) {\n        promise.reject(e)\n        return promise.promise\n      }\n\n      // 5.2. Set data to the result of UTF-8 encoding string .\n      data = new TextEncoder().encode(string)\n\n      // 5.3. Set opcode to a text frame opcode.\n      opcode = opcodes.TEXT\n    }\n\n    // 6. In parallel,\n    // 6.1. Wait until there is sufficient buffer space in stream to send the message.\n\n    // 6.2. If the closing handshake has not yet started , Send a WebSocket Message to stream comprised of data using opcode .\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      const frame = new WebsocketFrameSend(data)\n\n      this.#handler.socket.write(frame.createFrame(opcode), () => {\n        promise.resolve(undefined)\n      })\n    }\n\n    // 6.3. Queue a global task on the WebSocket task source given stream ’s relevant global object to resolve promise with undefined.\n    return promise.promise\n  }\n\n  /** @type {import('../websocket').Handler['onConnectionEstablished']} */\n  #onConnectionEstablished (response, parsedExtensions) {\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n\n    // 1. Change stream ’s ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Set stream ’s was ever connected to true.\n    // This is done in the opening handshake.\n\n    // 3. Let extensions be the extensions in use .\n    const extensions = parsedExtensions ?? ''\n\n    // 4. Let protocol be the subprotocol in use .\n    const protocol = response.headersList.get('sec-websocket-protocol') ?? ''\n\n    // 5. Let pullAlgorithm be an action that pulls bytes from stream .\n    // 6. Let cancelAlgorithm be an action that cancels stream with reason , given reason .\n    // 7. Let readable be a new ReadableStream .\n    // 8. Set up readable with pullAlgorithm and cancelAlgorithm .\n    const readable = new ReadableStream({\n      start: (controller) => {\n        this.#readableStreamController = controller\n      },\n      pull (controller) {\n        let chunk\n        while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {\n          controller.enqueue(chunk)\n        }\n      },\n      cancel: (reason) => this.#cancel(reason)\n    })\n\n    // 9. Let writeAlgorithm be an action that writes chunk to stream , given chunk .\n    // 10. Let closeAlgorithm be an action that closes stream .\n    // 11. Let abortAlgorithm be an action that aborts stream with reason , given reason .\n    // 12. Let writable be a new WritableStream .\n    // 13. Set up writable with writeAlgorithm , closeAlgorithm , and abortAlgorithm .\n    const writable = new WritableStream({\n      write: (chunk) => this.#write(chunk),\n      close: () => closeWebSocketConnection(this.#handler, null, null),\n      abort: (reason) => this.#closeUsingReason(reason)\n    })\n\n    // Set stream ’s readable stream to readable .\n    this.#readableStream = readable\n\n    // Set stream ’s writable stream to writable .\n    this.#writableStream = writable\n\n    // Resolve stream ’s opened promise with WebSocketOpenInfo «[ \" extensions \" → extensions , \" protocol \" → protocol , \" readable \" → readable , \" writable \" → writable ]».\n    this.#openedPromise.resolve({\n      extensions,\n      protocol,\n      readable,\n      writable\n    })\n  }\n\n  /** @type {import('../websocket').Handler['onMessage']} */\n  #onMessage (type, data) {\n    // 1. If stream’s ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let chunk be determined by switching on type:\n    //      - type indicates that the data is Text\n    //          a new DOMString containing data\n    //      - type indicates that the data is Binary\n    //          a new Uint8Array object, created in the relevant Realm of the\n    //          WebSocketStream object, whose contents are data\n    let chunk\n\n    if (type === opcodes.TEXT) {\n      try {\n        chunk = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    }\n\n    // 3. Enqueue chunk into stream’s readable stream.\n    this.#readableStreamController.enqueue(chunk)\n\n    // 4. Apply backpressure to the WebSocket.\n  }\n\n  /** @type {import('../websocket').Handler['onSocketClose']} */\n  #onSocketClose () {\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If stream ’s handshake aborted is true, then return.\n    if (this.#handshakeAborted) {\n      return\n    }\n\n    // 3. If stream ’s was ever connected is false, then reject stream ’s opened promise with a new WebSocketError.\n    if (!this.#handler.wasEverConnected) {\n      this.#openedPromise.reject(new WebSocketError('Socket never opened'))\n    }\n\n    const result = this.#parser.closingInfo\n\n    // 4. Let code be the WebSocket connection close code .\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    // If this Close control frame contains no status code, _The WebSocket\n    // Connection Close Code_ is considered to be 1005. If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    let code = result?.code ?? 1005\n\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      code = 1006\n    }\n\n    // 5. Let reason be the result of applying UTF-8 decode without BOM to the WebSocket connection close reason .\n    const reason = result?.reason == null ? '' : utf8DecodeBytes(Buffer.from(result.reason))\n\n    // 6. If the connection was closed cleanly ,\n    if (wasClean) {\n      // 6.1. Close stream ’s readable stream .\n      this.#readableStreamController.close()\n\n      // 6.2. Error stream ’s writable stream with an \" InvalidStateError \" DOMException indicating that a closed WebSocketStream cannot be written to.\n      if (!this.#writableStream.locked) {\n        this.#writableStream.abort(new DOMException('A closed WebSocketStream cannot be written to', 'InvalidStateError'))\n      }\n\n      // 6.3. Resolve stream ’s closed promise with WebSocketCloseInfo «[ \" closeCode \" → code , \" reason \" → reason ]».\n      this.#closedPromise.resolve({\n        closeCode: code,\n        reason\n      })\n    } else {\n      // 7. Otherwise,\n\n      // 7.1. Let error be a new WebSocketError whose closeCode is code and reason is reason .\n      const error = createUnvalidatedWebSocketError('unclean close', code, reason)\n\n      // 7.2. Error stream ’s readable stream with error .\n      this.#readableStreamController.error(error)\n\n      // 7.3. Error stream ’s writable stream with error .\n      this.#writableStream.abort(error)\n\n      // 7.4. Reject stream ’s closed promise with error .\n      this.#closedPromise.reject(error)\n    }\n  }\n\n  #closeUsingReason (reason) {\n    // 1. Let code be null.\n    let code = null\n\n    // 2. Let reasonString be the empty string.\n    let reasonString = ''\n\n    // 3. If reason implements WebSocketError ,\n    if (webidl.is.WebSocketError(reason)) {\n      // 3.1. Set code to reason ’s closeCode .\n      code = reason.closeCode\n\n      // 3.2. Set reasonString to reason ’s reason .\n      reasonString = reason.reason\n    }\n\n    // 4. Close the WebSocket with stream , code , and reasonString . If this throws an exception,\n    //    discard code and reasonString and close the WebSocket with stream .\n    closeWebSocketConnection(this.#handler, code, reasonString)\n  }\n\n  //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .\n  #cancel (reason) {\n    this.#closeUsingReason(reason)\n  }\n}\n\nObject.defineProperties(WebSocketStream.prototype, {\n  url: kEnumerableProperty,\n  opened: kEnumerableProperty,\n  closed: kEnumerableProperty,\n  close: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketStream',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.sequenceConverter(webidl.converters.USVString),\n    defaultValue: () => []\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(webidl.converters.AbortSignal),\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([\n  {\n    key: 'closeCode',\n    converter: (V) => webidl.converters['unsigned short'](V, webidl.attributes.EnforceRange)\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.WebSocketStreamWrite = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  return webidl.converters.BufferSource(V)\n}\n\nmodule.exports = { WebSocketStream }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12125, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/eventsource/util.js"],"sourcesContent":["'use strict'\n\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidLastEventId (value) {\n  // LastEventId should not contain U+0000 NULL\n  return value.indexOf('\\u0000') === -1\n}\n\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isASCIINumber (value) {\n  if (value.length === 0) return false\n  for (let i = 0; i < value.length; i++) {\n    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false\n  }\n  return true\n}\n\nmodule.exports = {\n  isValidLastEventId,\n  isASCIINumber\n}\n"],"names":[],"mappings":"AAEA;;;;CAIC,GACD,SAAS,mBAAoB,KAAK;IAChC,6CAA6C;IAC7C,OAAO,MAAM,OAAO,CAAC,cAAc,CAAC;AACtC;AAEA;;;;CAIC,GACD,SAAS,cAAe,KAAK;IAC3B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,IAAI,MAAM,UAAU,CAAC,KAAK,QAAQ,MAAM,UAAU,CAAC,KAAK,MAAM,OAAO;IACvE;IACA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12152, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js"],"sourcesContent":["'use strict'\nconst { Transform } = require('node:stream')\nconst { isASCIINumber, isValidLastEventId } = require('./util')\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} [lastEventId] The last event ID received from the server.\n * @property {string} [origin] The origin of the event source.\n * @property {number} [reconnectionTime] The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer|null}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {boolean} [options.readableObjectMode]\n   * @param {eventSourceSettings} [options.eventSourceSettings]\n   * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id !== undefined || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventSourceStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id !== undefined && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12482, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/undici%407.16.0/node_modules/undici/lib/web/eventsource/eventsource.js"],"sourcesContent":["'use strict'\n\nconst { pipeline } = require('node:stream')\nconst { fetching } = require('../fetch')\nconst { makeRequest } = require('../fetch/request')\nconst { webidl } = require('../webidl')\nconst { EventSourceStream } = require('./eventsource-stream')\nconst { parseMIMEType } = require('../fetch/data-url')\nconst { createFastMessageEvent } = require('../websocket/events')\nconst { isNetworkError } = require('../fetch/response')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { environmentSettingsObject } = require('../fetch/util')\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @typedef ReadyState\n * @type {0|1|2}\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url\n  #withCredentials = false\n\n  /**\n   * @type {ReadyState}\n   */\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict={}]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url)\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.node.dispatcher || eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: eventSourceInitDict.node.reconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials === true) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {ReadyState}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (!isNetworkError(response)) {\n        return this.#reconnect()\n      }\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {void}\n   */\n  #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    setTimeout(() => {\n      // 5. Queue a task to run the following steps:\n\n      //   1. If the EventSource object's readyState attribute is not set to\n      //      CONNECTING, then return.\n      if (this.#readyState !== CONNECTING) return\n\n      //   2. Let request be the EventSource object's request.\n      //   3. If the EventSource object's last event ID string is not the empty\n      //      string, then:\n      //      1. Let lastEventIDValue be the EventSource object's last event ID\n      //         string, encoded as UTF-8.\n      //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n      //         list.\n      if (this.#state.lastEventId.length) {\n        this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n      }\n\n      //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n      this.#connect()\n    }, this.#state.reconnectionTime)?.unref()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n      this.#events.open = fn\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n      this.#events.message = fn\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    const listener = webidl.converters.EventHandlerNonNull(fn)\n\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n      this.#events.error = fn\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  },\n  {\n    key: 'node', // undici only\n    converter: webidl.dictionaryConverter([\n      {\n        key: 'reconnectionTime',\n        converter: webidl.converters['unsigned long'],\n        defaultValue: () => defaultReconnectionTime\n      },\n      {\n        key: 'dispatcher',\n        converter: webidl.converters.any\n      }\n    ]),\n    defaultValue: () => ({})\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}