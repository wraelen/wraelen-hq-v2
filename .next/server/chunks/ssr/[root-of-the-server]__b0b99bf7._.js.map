{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/components/ui/button.tsx"],"sourcesContent":["import { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AAGA;;;;;AAEA,MAAM,iBAAiB,IAAA,kPAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,4SAAI,GAAG;IAE9B,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,6bAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/components/ui/table.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Table({ className, ...props }: React.ComponentProps<\"table\">) {\n  return (\n    <div\n      data-slot=\"table-container\"\n      className=\"relative w-full overflow-x-auto\"\n    >\n      <table\n        data-slot=\"table\"\n        className={cn(\"w-full caption-bottom text-sm\", className)}\n        {...props}\n      />\n    </div>\n  )\n}\n\nfunction TableHeader({ className, ...props }: React.ComponentProps<\"thead\">) {\n  return (\n    <thead\n      data-slot=\"table-header\"\n      className={cn(\"[&_tr]:border-b\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableBody({ className, ...props }: React.ComponentProps<\"tbody\">) {\n  return (\n    <tbody\n      data-slot=\"table-body\"\n      className={cn(\"[&_tr:last-child]:border-0\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableFooter({ className, ...props }: React.ComponentProps<\"tfoot\">) {\n  return (\n    <tfoot\n      data-slot=\"table-footer\"\n      className={cn(\n        \"bg-muted/50 border-t font-medium [&>tr]:last:border-b-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableRow({ className, ...props }: React.ComponentProps<\"tr\">) {\n  return (\n    <tr\n      data-slot=\"table-row\"\n      className={cn(\n        \"hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableHead({ className, ...props }: React.ComponentProps<\"th\">) {\n  return (\n    <th\n      data-slot=\"table-head\"\n      className={cn(\n        \"text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCell({ className, ...props }: React.ComponentProps<\"td\">) {\n  return (\n    <td\n      data-slot=\"table-cell\"\n      className={cn(\n        \"p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCaption({\n  className,\n  ...props\n}: React.ComponentProps<\"caption\">) {\n  return (\n    <caption\n      data-slot=\"table-caption\"\n      className={cn(\"text-muted-foreground mt-4 text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA;AAJA;;;AAMA,SAAS,MAAM,EAAE,SAAS,EAAE,GAAG,OAAsC;IACnE,qBACE,6bAAC;QACC,aAAU;QACV,WAAU;kBAEV,cAAA,6bAAC;YACC,aAAU;YACV,WAAW,IAAA,yHAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIjB;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,mBAAmB;QAChC,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAsC;IACvE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAmC;IACnE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,+EACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,sJACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OAC6B;IAChC,qBACE,6bAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/components/ui/data-table.tsx"],"sourcesContent":["// components/ui/data-table.tsx – Shadcn wrapper for TanStack React Table (headless, feature-rich: sort/pagination/search; best for your properties table – gamified filtering like quest search). No jQuery, React-native. Use as <DataTable data={properties} columns={columns} />.\n// Logic: Exports DataTable component (takes data/columns props; handles UI with Shadcn Table). Add all schema cols in page.tsx columns array. For theme: Relies on Tailwind (dark bg, blue accents via classes).\n\"use client\"\n\nimport {\n  ColumnDef,\n  flexRender,\n  getCoreRowModel,\n  getFilteredRowModel, // New: For global search (add input above table)\n  getPaginationRowModel, // New: For built-in pagination (add to table options if needed)\n  getSortedRowModel, // New: For sorting (click headers)\n  useReactTable,\n} from \"@tanstack/react-table\"\n\nimport React from \"react\"\nimport { Button } from \"@/components/ui/button\" // New: For pagination buttons (styled)\nimport { Input } from \"@/components/ui/input\" // New: For search input (if enabling filter)\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\"\n\ninterface DataTableProps<TData, TValue> {\n  columns: ColumnDef<TData, TValue>[]\n  data: TData[]\n}\n\nexport function DataTable<TData, TValue>({\n  columns,\n  data,\n}: DataTableProps<TData, TValue>) {\n  const [globalFilter, setGlobalFilter] = React.useState('') // New: State for global search (filter all cols)\n\n  const table = useReactTable({\n    data,\n    columns,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(), // New: Enable pagination (best for large datasets like 100+ properties)\n    getSortedRowModel: getSortedRowModel(), // New: Enable sorting (clickable headers – gamified quick sort by equity/AVM)\n    getFilteredRowModel: getFilteredRowModel(), // New: Enable filtering (ties to search input)\n    state: { globalFilter }, // New: Bind filter state\n    onGlobalFilterChange: setGlobalFilter, // New: Update on input change\n  })\n\n  return (\n    <div>\n      <Input // New: Search input (global filter – type to search all columns; UX like quest log search)\n        placeholder=\"Search properties...\"\n        value={globalFilter ?? ''}\n        onChange={(event) => setGlobalFilter(event.target.value)}\n        className=\"max-w-sm mb-4\" // Theme tie-in (dark input via Shadcn)\n      />\n      <div className=\"rounded-md border\"> {/* Wrapper for table (subtle border – matches console aesthetic) */}\n        <Table>\n          <TableHeader>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <TableRow key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <TableHead key={header.id}>\n                      {header.isPlaceholder\n                        ? null\n                        : flexRender(\n                            header.column.columnDef.header,\n                            header.getContext()\n                          )}\n                    </TableHead>\n                  )\n                })}\n              </TableRow>\n            ))}\n          </TableHeader>\n          <TableBody>\n            {table.getRowModel().rows?.length ? (\n              table.getRowModel().rows.map((row) => (\n                <TableRow\n                  key={row.id}\n                  data-state={row.getIsSelected() && \"selected\"} // For selection if added later (gamified row highlights)\n                >\n                  {row.getVisibleCells().map((cell) => (\n                    <TableCell key={cell.id}>\n                      {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                    </TableCell>\n                  ))}\n                </TableRow>\n              ))\n            ) : (\n              <TableRow>\n                <TableCell colSpan={columns.length} className=\"h-24 text-center\">\n                  No results.\n                </TableCell>\n              </TableRow>\n            )}\n          </TableBody>\n        </Table>\n      </div>\n      <div className=\"flex items-center justify-end space-x-2 py-4\"> {/* New: Pagination controls (next/prev buttons – Shadcn styled) */}\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={() => table.previousPage()}\n          disabled={!table.getCanPreviousPage()}\n        >\n          Previous\n        </Button>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={() => table.nextPage()}\n          disabled={!table.getCanNextPage()}\n        >\n          Next\n        </Button>\n      </div>\n    </div>\n  )\n}"],"names":[],"mappings":"AAAA,qRAAqR;AACrR,iNAAiN;;;;;;AAGjN;AAAA;AAUA;AACA,mOAAgD,uCAAuC;AACvF,iOAA8C,6CAA6C;AAC3F;AAfA;;;;;;;AA6BO,SAAS,UAAyB,EACvC,OAAO,EACP,IAAI,EAC0B;IAC9B,MAAM,CAAC,cAAc,gBAAgB,GAAG,+ZAAK,CAAC,QAAQ,CAAC,IAAI,iDAAiD;;IAE5G,MAAM,QAAQ,IAAA,8VAAa,EAAC;QAC1B;QACA;QACA,iBAAiB,IAAA,iQAAe;QAChC,uBAAuB,IAAA,uQAAqB;QAC5C,mBAAmB,IAAA,mQAAiB;QACpC,qBAAqB,IAAA,qQAAmB;QACxC,OAAO;YAAE;QAAa;QACtB,sBAAsB;IACxB;IAEA,qBACE,6bAAC;;0BACC,6bAAC,0IAAK,CAAC,2FAA2F;;gBAChG,aAAY;gBACZ,OAAO,gBAAgB;gBACvB,UAAU,CAAC,QAAU,gBAAgB,MAAM,MAAM,CAAC,KAAK;gBACvD,WAAU;;;;;;0BAEZ,6bAAC;gBAAI,WAAU;;oBAAoB;kCACjC,6bAAC,0IAAK;;0CACJ,6bAAC,gJAAW;0CACT,MAAM,eAAe,GAAG,GAAG,CAAC,CAAC,4BAC5B,6bAAC,6IAAQ;kDACN,YAAY,OAAO,CAAC,GAAG,CAAC,CAAC;4CACxB,qBACE,6bAAC,8IAAS;0DACP,OAAO,aAAa,GACjB,OACA,IAAA,2VAAU,EACR,OAAO,MAAM,CAAC,SAAS,CAAC,MAAM,EAC9B,OAAO,UAAU;+CALT,OAAO,EAAE;;;;;wCAS7B;uCAZa,YAAY,EAAE;;;;;;;;;;0CAgBjC,6bAAC,8IAAS;0CACP,MAAM,WAAW,GAAG,IAAI,EAAE,SACzB,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,oBAC5B,6bAAC,6IAAQ;wCAEP,cAAY,IAAI,aAAa,MAAM;kDAElC,IAAI,eAAe,GAAG,GAAG,CAAC,CAAC,qBAC1B,6bAAC,8IAAS;0DACP,IAAA,2VAAU,EAAC,KAAK,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,UAAU;+CADzC,KAAK,EAAE;;;;;uCAJpB,IAAI,EAAE;;;;8DAWf,6bAAC,6IAAQ;8CACP,cAAA,6bAAC,8IAAS;wCAAC,SAAS,QAAQ,MAAM;wCAAE,WAAU;kDAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAQ3E,6bAAC;gBAAI,WAAU;;oBAA+C;kCAC5D,6bAAC,4IAAM;wBACL,SAAQ;wBACR,MAAK;wBACL,SAAS,IAAM,MAAM,YAAY;wBACjC,UAAU,CAAC,MAAM,kBAAkB;kCACpC;;;;;;kCAGD,6bAAC,4IAAM;wBACL,SAAQ;wBACR,MAAK;wBACL,SAAS,IAAM,MAAM,QAAQ;wBAC7B,UAAU,CAAC,MAAM,cAAc;kCAChC;;;;;;;;;;;;;;;;;;AAMT","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/lib/actions.ts"],"sourcesContent":["// src/lib/actions.ts – Updated with async Supabase (align with layout fix; keeps Propstream CSV ready – test upload post-restart; fixed notes type by disabling dynamicTyping and explicit conversions – best practice: Treat CSV as strings to avoid surprises, manually Number() numerics for safety/scalability in imports/quests)\n'use server'; // Logic: Marks as server-only (no client bundle bloat – optimizes for internal app with leads/calls)\nimport { LeadSource, LeadType, PrismaClient, PropertyType } from '@prisma/client';  // Your DB client (async-safe in actions)\nimport { redirect } from 'next/navigation'; // Server redirect (reliable – no client hacks; best for post-auth flow to dashboard quests)\nimport Papa from 'papaparse'; // Logic: CSV parser (handles headers, errors – best for Propstream exports)\nimport Twilio from 'twilio'; // Logic: Twilio SDK for outbound calls (inexpensive, reliable integration)\nimport { z } from 'zod';  // Validation (type-safe inputs – prevents junk data in DB; no-brainer for prod)\nimport crypto from 'crypto';  // Built-in hash (no extra deps – for address_hash dedup)\nimport { createSupabaseServerClient } from '@/lib/supabaseServer'; // Use async helper (fixes warnings in actions too)\nimport type { Database } from '@/types/database.types'; // Types (autocompletes e.g., session.user.id for Prisma sync – now fixed via your gen)\n\nconst prisma = new PrismaClient();  // Global instance (efficient in Next.js actions – auto-closes; push back: Cache in lib/prisma.ts for hot reloads if issues)\n\nconst twilioClient = Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN); // Logic: Init Twilio (guard env in prod)\n\nconst importSchema = z.object({\n  source: z.literal('propstream'), // Logic: Locked to Propstream for now (expand later)\n});  // Logic: Zod for form (file handled separately)\n\n// Action: Sign in (logic: Basic stub – expand with your original zod/email/password validation; centralized for type-safety)\nexport async function signInAction(formData: FormData) {\n  const email = formData.get('email')?.toString() ?? '';\n  const password = formData.get('password')?.toString() ?? '';\n  // ... (add your validation/error returns here; e.g., zod schema for email/password)\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (Next 15 safe)\n  const { error } = await supabase.auth.signInWithPassword({ email, password });\n  if (error) {\n    return { error: error.message };\n  }\n  redirect('/dashboard'); // Logic: Post-login to HQ (quests await!)\n}\n\n// Action: Sign out (logic: Centralized mutation – avoids serialization issues in layout; redirects to signin)\nexport async function signOutAction() {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (consistent fix)\n  await supabase.auth.signOut(); // Logic: Clears session (middleware will redirect unauthed requests)\n  redirect('/auth/signin'); // Logic: Post-signout flow (back to login – update to '/' if public landing needed)\n}\n\n// Action: Import from Propstream CSV (logic: Parse file → per-row extract/map → batch upsert properties/create leads – returns results for UX)\n// New: Added enrichRealtors flag from form (optional – if true and env enabled, enrich after create; pushback: Gate to avoid costs; serial for now, batch later if scale)\n// New: After all, trigger quest checks (increment points by leads.length, check/complete quests via transaction – atomic/best practice to avoid partial fails)\nexport async function importDataAction(formData: FormData) {\n  const validated = importSchema.safeParse({\n    source: formData.get('source')?.toString() ?? 'propstream',\n  });\n  if (!validated.success) {\n    return { error: validated.error.format() };\n  }\n\n  const file = formData.get('file') as File | null; // Logic: Get uploaded CSV (from dropzone/form)\n  if (!file) {\n    return { error: 'No file uploaded' };\n  }\n\n  const enrichRealtors = formData.get('enrichRealtors') === 'true'; // New: Optional flag from checkbox (default false)\n\n  // Parse CSV (papaparse – async, handles large files stream-like)\n  const csvText = await file.text();\n  const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true, dynamicTyping: false }); // Fix: Disable dynamicTyping (all fields as strings – avoids number surprises like notes:1 as Int; explicit Number() below for numerics)\n  if (parsed.errors.length > 0) {\n    return { error: `CSV parse errors: ${parsed.errors.map(e => e.message).join('; ')}` }; // Logic: Early feedback (e.g., malformed rows)\n  }\n\n  const rows = parsed.data as Record<string, any>[]; // Logic: Typed rows (Propstream columns like 'Property Address', 'AVM', etc.)\n  const supabase = await createSupabaseServerClient(); // Logic: Hoist session fetch (efficiency – avoids per-row calls)\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session – login required' };\n  }\n\n  const results = await Promise.allSettled(rows.map(async (row, index) => { // Logic: Parallel for speed; settled for per-row errors\n    try {\n      // Map Propstream columns to schema (flexible – handle variants/missing; added equity/mortgage for creative financing)\n      const propertyTypeMap: Record<string, PropertyType> = { // Logic: Dict for safe enum mapping (pushback: Better than lowercase assume – handles variants)\n        'single family': 'single_family',\n        'multi family': 'multi_family',\n        'condo': 'condo',\n        'townhouse': 'townhouse',\n        'land': 'land',\n        'commercial': 'commercial',\n        'duplex (2 units, any combination)': 'multi_family', // Added: Matches your sample CSV value (normalize to enum; pushback: If more variants, expand or use AI fuzzy match later)\n        // Add more mappings as needed; default to 'other' below\n      };\n\n      const address = row['Address']?.trim() || null; // Logic: Trim (now strings)\n      const city = row['City']?.trim() || null;\n      const state = row['State']?.toUpperCase() || null; // Standardize to uppercase (e.g., 'FL' → 'FL')\n      const zip_code = row['Zip']?.trim() || null; // Keep as string for leading zeros\n      if (!address || !city || !state || !zip_code) {\n        throw new Error('Missing required address fields');\n      }\n\n      const address_hash = crypto.createHash('sha256').update(`${address}${city}${state}${zip_code}`.toLowerCase()).digest('hex'); // Logic: Normalized hash for dedup (lowercase for consistency)\n\n      const propertyData = {\n        address,\n        city,\n        state,\n        zip_code,\n        property_type: propertyTypeMap[row['Property Type']?.toLowerCase() || ''] || 'other' as PropertyType,\n        bedrooms: Number(row['Bedrooms']) || null, // Explicit Number (NaN → null)\n        bathrooms: Number(row['Total Bathrooms']) || null, // Matches CSV header 'Total Bathrooms'\n        square_feet: Number(row['Building Sqft']) || null,\n        year_built: Number(row['Effective Year Built']) || null,\n        avm: Number(row['Est. Value']) || null, // Matches 'Est. Value' for AVM\n        owner_occupied: row['Owner Occupied']?.toLowerCase() === 'yes' ? true : (row['Owner Occupied']?.toLowerCase() === 'no' ? false : null), // Boolean map from string\n        distress_signals: row['Foreclosure Factor'] ? { foreclosure: row['Foreclosure Factor'] } : null, // Json: Basic distress (expand with more CSV fields if available)\n        notes: row['Marketing Lists'] || null, // Now string (e.g., '1' instead of 1 – fixes validation error)\n        equity: Number(row['Est. Equity']) || null, // Matches 'Est. Equity' in CSV\n        remaining_balance: Number(row['Est. Remaining balance of Open Loans']) || null, // Matches CSV\n        loan_to_value: Number(row['Est. Loan-to-Value']) || null, // Matches CSV\n        open_loans: Number(row['Total Open Loans']) || null, // Matches CSV\n        metadata: { // Json: Extras for creative financing (add more if CSV has them; e.g., if 'Equity' column exists, parse here)\n        },\n      };\n\n      // Upsert property (dedup on hash – merge data)\n      const property = await prisma.properties.upsert({\n        where: { address_hash },\n        update: propertyData,\n        create: { ...propertyData, address_hash },\n      });\n\n      // Parse owner names (split first/last if combined; for owner leads)\n      const owner1First = row['Owner 1 First Name']?.trim() || null;\n      const owner1Last = row['Owner 1 Last Name']?.trim() || null;\n      const phone = row['Owner 1 Phone']?.trim() || null; // Assuming CSV has phone; add if present\n      const email = row['Owner 1 Email']?.trim() || null; // Add if CSV has email\n\n      const leadData = {\n        properties_id: property.id,\n        lead_type: 'owner' as LeadType, // Default to owner for Propstream (realtor enrich separate)\n        first_name: owner1First,\n        last_name: owner1Last,\n        phone,\n        email,\n        status: 'new' as const, // Default new\n        source: 'propstream_import' as LeadSource,\n        assigned_to: session.user.id, // Assign to importer (gamification: Their quest points)\n        points_earned: 1, // Per-lead points (expand logic for quality-based)\n        notes: row['Notes'] || null,\n        metadata: { imported_at: new Date(), county: row['County'] || null }, // Audit + extras\n      };\n\n      // Create lead (no unique – allow multiples per property if needed; pushback: Add unique constraint if 1:1 desired)\n      const lead = await prisma.leads.create({ data: leadData });\n\n      // New: Optional auto-enrich (gate with env to avoid bulk costs; pushback: Serial for simplicity, but if slow, add batch/queue later with Upstash)\n      if (enrichRealtors && process.env.ENABLE_AUTO_ENRICH === 'true') {\n        await enrichLeadRealtor(lead.id); // Call existing (handles errors internally – log, don't fail import)\n      }\n\n      return { success: true, row: index + 1, leadId: lead.id }; // For results list\n    } catch (error) {\n      console.error(`Import error for row ${index + 1}:`, error);\n      return { success: false, row: index + 1, error: (error as Error).message };\n    }\n  }));\n\n  // Filter fulfilled/rejected for summary (UX: Show counts in results)\n  const successful = results.filter(r => r.status === 'fulfilled' && (r.value as any).success).length;\n  const failed = results.length - successful;\n\n  // New: Trigger quests (after all imports – use transaction for atomic points/quests; best practice to prevent races)\n  if (successful > 0) {\n    await prisma.$transaction(async (tx) => {\n      // Get profile (by user_id from session)\n      const profile = await tx.profile.findUnique({ where: { user_id: session.user.id } });\n      if (!profile) throw new Error('Profile not found');\n\n      // Increment points (1 per successful lead; ties to leads.points_earned but aggregates to profile)\n      await tx.profile.update({\n        where: { user_id: session.user.id },\n        data: { points: { increment: successful } },\n      });\n\n      // Get active quests (for this user – check incomplete)\n      const quests = await tx.quest.findMany({\n        where: { active: true },\n      });\n\n      for (const quest of quests) {\n        // Check if already completed (unique constraint prevents dupes)\n        const existingCompletion = await tx.quest_completions.findUnique({\n          where: { quest_id_profile_id: { quest_id: quest.id, profile_id: profile.id } },\n        });\n        if (existingCompletion) continue;\n\n        // Parse criteria and check (basic for min_imports; expand for other types like min_calls)\n        const criteria = quest.criteria as { min_imports?: number } | null;\n        if (criteria?.min_imports) {\n          // Count total imports for user (ever; for one_time – adjust for daily/weekly with date filters)\n          const totalImports = await tx.leads.count({\n            where: { assigned_to: profile.id, source: LeadSource.propstream_import },\n          });\n          if (totalImports >= criteria.min_imports) {\n            // Complete quest (award extra points)\n            await tx.quest_completions.create({\n              data: {\n                quest_id: quest.id,\n                profile_id: profile.id,\n                evidence: { total_imports: totalImports, awarded_points: quest.points },\n              },\n            });\n            await tx.profile.update({\n              where: { id: profile.id },\n              data: { points: { increment: quest.points } },\n            });\n            // Optional: Unlock badge if requirements met (e.g., check badges.requirements – add similar loop if needed)\n          }\n        }\n        // Expand: Add cases for other criteria (e.g., if (criteria.min_calls) { count calls... })\n      }\n    });\n  }\n\n  if (failed === results.length) {\n    return { error: 'All rows failed – check CSV format/console logs' };\n  }\n\n  return { success: true, results, summary: { successful, failed } }; // Logic: Return array for display (no jobId yet; pushback: For long-running, add Upstash/edge func + return jobId for poll)\n}\n\n// Stub poll (replace with real DB query on 'import_jobs' table for prod; unblocks testing without Upstash)\nexport async function pollImportStatus(jobId: string) {\n  // Stub logic: Simulate progress (e.g., from memory or DB; here, random increment for testing)\n  // In real, query prisma.import_jobs.findUnique({ where: { id: jobId } }) for { progress, results, error }\n  const simulatedProgress = Math.min(100, (Math.random() * 20) + (await new Promise(r => setTimeout(r, 500)) as any || 0)); // Fake delay/increment\n  if (simulatedProgress >= 100) {\n    return { progress: 100, results: [], error: null }; // Replace with real results\n  }\n  return { progress: simulatedProgress, results: [], error: null };\n}\n\n// Action: Dial lead (logic: Twilio outbound call – from your Twilio number to lead phone; logs to calls table)\nexport async function dialLeadAction(leadId: number) {\n  try {\n    const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n    if (!lead?.phone) {\n      throw new Error('No phone for lead');\n    }\n\n    const supabase = await createSupabaseServerClient(); // Logic: Async client\n    const { data: { session } } = await supabase.auth.getSession();\n    if (!session?.user.id || lead.assigned_to !== session.user.id) {\n      throw new Error('Unauthorized or mismatched assignment');\n    }\n\n    // Twilio outbound (phone-to-phone; expand to browser via Voice SDK if web calls needed)\n    const call = await twilioClient.calls.create({\n      to: lead.phone, // Lead's number\n      from: process.env.TWILIO_PHONE_NUMBER!, // Your Twilio number\n      url: 'http://your-domain.com/api/twiml', // Logic: TwiML endpoint (create /api/twiml route for voice response – e.g., <Say>Hello, connecting to lead</Say>)\n      statusCallback: 'http://your-domain.com/api/call-status', // Logic: Webhook for metrics (update calls table on complete)\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'], // Track status\n    });\n\n    // Log call (for metrics/quests – expand with webhook for duration/points)\n    await prisma.calls.create({\n      data: {\n        leads_id: lead.id,\n        caller_id: session.user.id,\n        call_sid: call.sid, // Twilio ID for tracking\n        status: 'initiated',\n        metadata: { address: lead.properties.address },\n      },\n    });\n\n    return { success: true, callId: call.sid };\n  } catch (error) {\n    console.error('Dial error:', error);\n    return { success: false, error: (error as Error).message };\n  }\n}\n\n// Helper: Stubbed extractFromLink (removed for pivot – mock for non-CSV if needed)\n// async function extractFromLink(...) { return { /* mock data */ }; } // Comment out Zillow logic\n\n// Action: Enrich lead with realtor info (fix: Added for API call; uses RapidAPI key from .env – solves realtor missing in Propstream; push back: Cache results to avoid repeat costs)\n// New: Improved query with full address (address + city + state + zip – fixes partial failures; pushback: If API still flaky, add fallback or switch to another like Datafiniti)\n// New: Added detailed logging for debugging (query, status, raw data, parsed realtor – best practice for API issues; remove or gate in prod if verbose)\n// Suggestion: Alternate parsing to data.properties?.[0]?.listing_agent (common in Realtor APIs; adjust based on logs/raw data)\nexport async function enrichLeadRealtor(leadId: string) {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session' };\n  }\n\n  const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n  if (!lead || lead.assigned_to !== session.user.id) {\n    return { error: 'Unauthorized or lead not found' };\n  }\n\n  const fullAddress = `${lead.properties.address}, ${lead.properties.city}, ${lead.properties.state} ${lead.properties.zip_code}`; // New: Full query for better API accuracy (fixes partial address issues)\n\n  console.log(`Enriching lead ${leadId} with query: ${fullAddress}`); // New: Log the input query for verification\n\n  try {\n    const response = await fetch('https://realtor-com4.p.rapidapi.com/properties/v1/search', { // Logic: Endpoint for agents by location (adjust per API docs; e.g., /agents if separate)\n      method: 'POST', // Or GET—check docs\n      headers: {\n        'Content-Type': 'application/json',\n        'x-rapidapi-key': process.env.RAPIDAPI_KEY!, // Your key from .env (add to .env: RAPIDAPI_KEY=your_key)\n        'x-rapidapi-host': 'realtor-com4.p.rapidapi.com',\n      },\n      body: JSON.stringify({ // Params from docs (example—tweak for address search)\n        location: fullAddress,\n        limit: 1, // Top realtor\n      }),\n    });\n\n    console.log(`API response status: ${response.status}`); // New: Log status (e.g., 200 ok, 404 no match, 401 bad key)\n\n    if (!response.ok) {\n      console.log(`API error details: ${await response.text()}`); // New: Log error body if not ok (e.g., rate limit or invalid params)\n      return { error: `API error: ${response.status}` };\n    }\n\n    const data = await response.json();\n    console.log('Raw API response data:', JSON.stringify(data, null, 2)); // New: Log full response (inspect structure for agents)\n\n    const realtor = data.properties?.[0]?.listing_agent || {}; // New: Alternate parsing (common in Realtor APIs; fallback to {} if no match – adjust if logs show different path, e.g., data.agents?.[0])\n\n    console.log('Parsed realtor:', realtor); // New: Log what we're extracting (e.g., empty if no match)\n\n    await prisma.leads.update({\n      where: { id: leadId },\n      data: {\n        realtor_first_name: realtor.first_name || null,\n        realtor_last_name: realtor.last_name || null,\n        realtor_phone: realtor.phone || null,\n        metadata: { ...((typeof lead.metadata === 'object' && lead.metadata !== null) ? lead.metadata : {}), enriched_at: new Date(), api_source: 'realtor-com' }, // Cache/audit\n      },\n    });\n\n    return { success: true, realtor };\n  } catch (error) {\n    console.error('Enrich error:', error);\n    return { error: (error as Error).message };\n  }\n}"],"names":[],"mappings":";;;;;;;IA0CsB,mBAAA,WAAA,GAAA,IAAA,8bAAA,EAAA,8CAAA,mbAAA,EAAA,KAAA,GAAA,ybAAA,EAAA","debugId":null}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/lib/actions.ts"],"sourcesContent":["// src/lib/actions.ts – Updated with async Supabase (align with layout fix; keeps Propstream CSV ready – test upload post-restart; fixed notes type by disabling dynamicTyping and explicit conversions – best practice: Treat CSV as strings to avoid surprises, manually Number() numerics for safety/scalability in imports/quests)\n'use server'; // Logic: Marks as server-only (no client bundle bloat – optimizes for internal app with leads/calls)\nimport { LeadSource, LeadType, PrismaClient, PropertyType } from '@prisma/client';  // Your DB client (async-safe in actions)\nimport { redirect } from 'next/navigation'; // Server redirect (reliable – no client hacks; best for post-auth flow to dashboard quests)\nimport Papa from 'papaparse'; // Logic: CSV parser (handles headers, errors – best for Propstream exports)\nimport Twilio from 'twilio'; // Logic: Twilio SDK for outbound calls (inexpensive, reliable integration)\nimport { z } from 'zod';  // Validation (type-safe inputs – prevents junk data in DB; no-brainer for prod)\nimport crypto from 'crypto';  // Built-in hash (no extra deps – for address_hash dedup)\nimport { createSupabaseServerClient } from '@/lib/supabaseServer'; // Use async helper (fixes warnings in actions too)\nimport type { Database } from '@/types/database.types'; // Types (autocompletes e.g., session.user.id for Prisma sync – now fixed via your gen)\n\nconst prisma = new PrismaClient();  // Global instance (efficient in Next.js actions – auto-closes; push back: Cache in lib/prisma.ts for hot reloads if issues)\n\nconst twilioClient = Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN); // Logic: Init Twilio (guard env in prod)\n\nconst importSchema = z.object({\n  source: z.literal('propstream'), // Logic: Locked to Propstream for now (expand later)\n});  // Logic: Zod for form (file handled separately)\n\n// Action: Sign in (logic: Basic stub – expand with your original zod/email/password validation; centralized for type-safety)\nexport async function signInAction(formData: FormData) {\n  const email = formData.get('email')?.toString() ?? '';\n  const password = formData.get('password')?.toString() ?? '';\n  // ... (add your validation/error returns here; e.g., zod schema for email/password)\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (Next 15 safe)\n  const { error } = await supabase.auth.signInWithPassword({ email, password });\n  if (error) {\n    return { error: error.message };\n  }\n  redirect('/dashboard'); // Logic: Post-login to HQ (quests await!)\n}\n\n// Action: Sign out (logic: Centralized mutation – avoids serialization issues in layout; redirects to signin)\nexport async function signOutAction() {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (consistent fix)\n  await supabase.auth.signOut(); // Logic: Clears session (middleware will redirect unauthed requests)\n  redirect('/auth/signin'); // Logic: Post-signout flow (back to login – update to '/' if public landing needed)\n}\n\n// Action: Import from Propstream CSV (logic: Parse file → per-row extract/map → batch upsert properties/create leads – returns results for UX)\n// New: Added enrichRealtors flag from form (optional – if true and env enabled, enrich after create; pushback: Gate to avoid costs; serial for now, batch later if scale)\n// New: After all, trigger quest checks (increment points by leads.length, check/complete quests via transaction – atomic/best practice to avoid partial fails)\nexport async function importDataAction(formData: FormData) {\n  const validated = importSchema.safeParse({\n    source: formData.get('source')?.toString() ?? 'propstream',\n  });\n  if (!validated.success) {\n    return { error: validated.error.format() };\n  }\n\n  const file = formData.get('file') as File | null; // Logic: Get uploaded CSV (from dropzone/form)\n  if (!file) {\n    return { error: 'No file uploaded' };\n  }\n\n  const enrichRealtors = formData.get('enrichRealtors') === 'true'; // New: Optional flag from checkbox (default false)\n\n  // Parse CSV (papaparse – async, handles large files stream-like)\n  const csvText = await file.text();\n  const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true, dynamicTyping: false }); // Fix: Disable dynamicTyping (all fields as strings – avoids number surprises like notes:1 as Int; explicit Number() below for numerics)\n  if (parsed.errors.length > 0) {\n    return { error: `CSV parse errors: ${parsed.errors.map(e => e.message).join('; ')}` }; // Logic: Early feedback (e.g., malformed rows)\n  }\n\n  const rows = parsed.data as Record<string, any>[]; // Logic: Typed rows (Propstream columns like 'Property Address', 'AVM', etc.)\n  const supabase = await createSupabaseServerClient(); // Logic: Hoist session fetch (efficiency – avoids per-row calls)\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session – login required' };\n  }\n\n  const results = await Promise.allSettled(rows.map(async (row, index) => { // Logic: Parallel for speed; settled for per-row errors\n    try {\n      // Map Propstream columns to schema (flexible – handle variants/missing; added equity/mortgage for creative financing)\n      const propertyTypeMap: Record<string, PropertyType> = { // Logic: Dict for safe enum mapping (pushback: Better than lowercase assume – handles variants)\n        'single family': 'single_family',\n        'multi family': 'multi_family',\n        'condo': 'condo',\n        'townhouse': 'townhouse',\n        'land': 'land',\n        'commercial': 'commercial',\n        'duplex (2 units, any combination)': 'multi_family', // Added: Matches your sample CSV value (normalize to enum; pushback: If more variants, expand or use AI fuzzy match later)\n        // Add more mappings as needed; default to 'other' below\n      };\n\n      const address = row['Address']?.trim() || null; // Logic: Trim (now strings)\n      const city = row['City']?.trim() || null;\n      const state = row['State']?.toUpperCase() || null; // Standardize to uppercase (e.g., 'FL' → 'FL')\n      const zip_code = row['Zip']?.trim() || null; // Keep as string for leading zeros\n      if (!address || !city || !state || !zip_code) {\n        throw new Error('Missing required address fields');\n      }\n\n      const address_hash = crypto.createHash('sha256').update(`${address}${city}${state}${zip_code}`.toLowerCase()).digest('hex'); // Logic: Normalized hash for dedup (lowercase for consistency)\n\n      const propertyData = {\n        address,\n        city,\n        state,\n        zip_code,\n        property_type: propertyTypeMap[row['Property Type']?.toLowerCase() || ''] || 'other' as PropertyType,\n        bedrooms: Number(row['Bedrooms']) || null, // Explicit Number (NaN → null)\n        bathrooms: Number(row['Total Bathrooms']) || null, // Matches CSV header 'Total Bathrooms'\n        square_feet: Number(row['Building Sqft']) || null,\n        year_built: Number(row['Effective Year Built']) || null,\n        avm: Number(row['Est. Value']) || null, // Matches 'Est. Value' for AVM\n        owner_occupied: row['Owner Occupied']?.toLowerCase() === 'yes' ? true : (row['Owner Occupied']?.toLowerCase() === 'no' ? false : null), // Boolean map from string\n        distress_signals: row['Foreclosure Factor'] ? { foreclosure: row['Foreclosure Factor'] } : null, // Json: Basic distress (expand with more CSV fields if available)\n        notes: row['Marketing Lists'] || null, // Now string (e.g., '1' instead of 1 – fixes validation error)\n        equity: Number(row['Est. Equity']) || null, // Matches 'Est. Equity' in CSV\n        remaining_balance: Number(row['Est. Remaining balance of Open Loans']) || null, // Matches CSV\n        loan_to_value: Number(row['Est. Loan-to-Value']) || null, // Matches CSV\n        open_loans: Number(row['Total Open Loans']) || null, // Matches CSV\n        metadata: { // Json: Extras for creative financing (add more if CSV has them; e.g., if 'Equity' column exists, parse here)\n        },\n      };\n\n      // Upsert property (dedup on hash – merge data)\n      const property = await prisma.properties.upsert({\n        where: { address_hash },\n        update: propertyData,\n        create: { ...propertyData, address_hash },\n      });\n\n      // Parse owner names (split first/last if combined; for owner leads)\n      const owner1First = row['Owner 1 First Name']?.trim() || null;\n      const owner1Last = row['Owner 1 Last Name']?.trim() || null;\n      const phone = row['Owner 1 Phone']?.trim() || null; // Assuming CSV has phone; add if present\n      const email = row['Owner 1 Email']?.trim() || null; // Add if CSV has email\n\n      const leadData = {\n        properties_id: property.id,\n        lead_type: 'owner' as LeadType, // Default to owner for Propstream (realtor enrich separate)\n        first_name: owner1First,\n        last_name: owner1Last,\n        phone,\n        email,\n        status: 'new' as const, // Default new\n        source: 'propstream_import' as LeadSource,\n        assigned_to: session.user.id, // Assign to importer (gamification: Their quest points)\n        points_earned: 1, // Per-lead points (expand logic for quality-based)\n        notes: row['Notes'] || null,\n        metadata: { imported_at: new Date(), county: row['County'] || null }, // Audit + extras\n      };\n\n      // Create lead (no unique – allow multiples per property if needed; pushback: Add unique constraint if 1:1 desired)\n      const lead = await prisma.leads.create({ data: leadData });\n\n      // New: Optional auto-enrich (gate with env to avoid bulk costs; pushback: Serial for simplicity, but if slow, add batch/queue later with Upstash)\n      if (enrichRealtors && process.env.ENABLE_AUTO_ENRICH === 'true') {\n        await enrichLeadRealtor(lead.id); // Call existing (handles errors internally – log, don't fail import)\n      }\n\n      return { success: true, row: index + 1, leadId: lead.id }; // For results list\n    } catch (error) {\n      console.error(`Import error for row ${index + 1}:`, error);\n      return { success: false, row: index + 1, error: (error as Error).message };\n    }\n  }));\n\n  // Filter fulfilled/rejected for summary (UX: Show counts in results)\n  const successful = results.filter(r => r.status === 'fulfilled' && (r.value as any).success).length;\n  const failed = results.length - successful;\n\n  // New: Trigger quests (after all imports – use transaction for atomic points/quests; best practice to prevent races)\n  if (successful > 0) {\n    await prisma.$transaction(async (tx) => {\n      // Get profile (by user_id from session)\n      const profile = await tx.profile.findUnique({ where: { user_id: session.user.id } });\n      if (!profile) throw new Error('Profile not found');\n\n      // Increment points (1 per successful lead; ties to leads.points_earned but aggregates to profile)\n      await tx.profile.update({\n        where: { user_id: session.user.id },\n        data: { points: { increment: successful } },\n      });\n\n      // Get active quests (for this user – check incomplete)\n      const quests = await tx.quest.findMany({\n        where: { active: true },\n      });\n\n      for (const quest of quests) {\n        // Check if already completed (unique constraint prevents dupes)\n        const existingCompletion = await tx.quest_completions.findUnique({\n          where: { quest_id_profile_id: { quest_id: quest.id, profile_id: profile.id } },\n        });\n        if (existingCompletion) continue;\n\n        // Parse criteria and check (basic for min_imports; expand for other types like min_calls)\n        const criteria = quest.criteria as { min_imports?: number } | null;\n        if (criteria?.min_imports) {\n          // Count total imports for user (ever; for one_time – adjust for daily/weekly with date filters)\n          const totalImports = await tx.leads.count({\n            where: { assigned_to: profile.id, source: LeadSource.propstream_import },\n          });\n          if (totalImports >= criteria.min_imports) {\n            // Complete quest (award extra points)\n            await tx.quest_completions.create({\n              data: {\n                quest_id: quest.id,\n                profile_id: profile.id,\n                evidence: { total_imports: totalImports, awarded_points: quest.points },\n              },\n            });\n            await tx.profile.update({\n              where: { id: profile.id },\n              data: { points: { increment: quest.points } },\n            });\n            // Optional: Unlock badge if requirements met (e.g., check badges.requirements – add similar loop if needed)\n          }\n        }\n        // Expand: Add cases for other criteria (e.g., if (criteria.min_calls) { count calls... })\n      }\n    });\n  }\n\n  if (failed === results.length) {\n    return { error: 'All rows failed – check CSV format/console logs' };\n  }\n\n  return { success: true, results, summary: { successful, failed } }; // Logic: Return array for display (no jobId yet; pushback: For long-running, add Upstash/edge func + return jobId for poll)\n}\n\n// Stub poll (replace with real DB query on 'import_jobs' table for prod; unblocks testing without Upstash)\nexport async function pollImportStatus(jobId: string) {\n  // Stub logic: Simulate progress (e.g., from memory or DB; here, random increment for testing)\n  // In real, query prisma.import_jobs.findUnique({ where: { id: jobId } }) for { progress, results, error }\n  const simulatedProgress = Math.min(100, (Math.random() * 20) + (await new Promise(r => setTimeout(r, 500)) as any || 0)); // Fake delay/increment\n  if (simulatedProgress >= 100) {\n    return { progress: 100, results: [], error: null }; // Replace with real results\n  }\n  return { progress: simulatedProgress, results: [], error: null };\n}\n\n// Action: Dial lead (logic: Twilio outbound call – from your Twilio number to lead phone; logs to calls table)\nexport async function dialLeadAction(leadId: number) {\n  try {\n    const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n    if (!lead?.phone) {\n      throw new Error('No phone for lead');\n    }\n\n    const supabase = await createSupabaseServerClient(); // Logic: Async client\n    const { data: { session } } = await supabase.auth.getSession();\n    if (!session?.user.id || lead.assigned_to !== session.user.id) {\n      throw new Error('Unauthorized or mismatched assignment');\n    }\n\n    // Twilio outbound (phone-to-phone; expand to browser via Voice SDK if web calls needed)\n    const call = await twilioClient.calls.create({\n      to: lead.phone, // Lead's number\n      from: process.env.TWILIO_PHONE_NUMBER!, // Your Twilio number\n      url: 'http://your-domain.com/api/twiml', // Logic: TwiML endpoint (create /api/twiml route for voice response – e.g., <Say>Hello, connecting to lead</Say>)\n      statusCallback: 'http://your-domain.com/api/call-status', // Logic: Webhook for metrics (update calls table on complete)\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'], // Track status\n    });\n\n    // Log call (for metrics/quests – expand with webhook for duration/points)\n    await prisma.calls.create({\n      data: {\n        leads_id: lead.id,\n        caller_id: session.user.id,\n        call_sid: call.sid, // Twilio ID for tracking\n        status: 'initiated',\n        metadata: { address: lead.properties.address },\n      },\n    });\n\n    return { success: true, callId: call.sid };\n  } catch (error) {\n    console.error('Dial error:', error);\n    return { success: false, error: (error as Error).message };\n  }\n}\n\n// Helper: Stubbed extractFromLink (removed for pivot – mock for non-CSV if needed)\n// async function extractFromLink(...) { return { /* mock data */ }; } // Comment out Zillow logic\n\n// Action: Enrich lead with realtor info (fix: Added for API call; uses RapidAPI key from .env – solves realtor missing in Propstream; push back: Cache results to avoid repeat costs)\n// New: Improved query with full address (address + city + state + zip – fixes partial failures; pushback: If API still flaky, add fallback or switch to another like Datafiniti)\n// New: Added detailed logging for debugging (query, status, raw data, parsed realtor – best practice for API issues; remove or gate in prod if verbose)\n// Suggestion: Alternate parsing to data.properties?.[0]?.listing_agent (common in Realtor APIs; adjust based on logs/raw data)\nexport async function enrichLeadRealtor(leadId: string) {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session' };\n  }\n\n  const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n  if (!lead || lead.assigned_to !== session.user.id) {\n    return { error: 'Unauthorized or lead not found' };\n  }\n\n  const fullAddress = `${lead.properties.address}, ${lead.properties.city}, ${lead.properties.state} ${lead.properties.zip_code}`; // New: Full query for better API accuracy (fixes partial address issues)\n\n  console.log(`Enriching lead ${leadId} with query: ${fullAddress}`); // New: Log the input query for verification\n\n  try {\n    const response = await fetch('https://realtor-com4.p.rapidapi.com/properties/v1/search', { // Logic: Endpoint for agents by location (adjust per API docs; e.g., /agents if separate)\n      method: 'POST', // Or GET—check docs\n      headers: {\n        'Content-Type': 'application/json',\n        'x-rapidapi-key': process.env.RAPIDAPI_KEY!, // Your key from .env (add to .env: RAPIDAPI_KEY=your_key)\n        'x-rapidapi-host': 'realtor-com4.p.rapidapi.com',\n      },\n      body: JSON.stringify({ // Params from docs (example—tweak for address search)\n        location: fullAddress,\n        limit: 1, // Top realtor\n      }),\n    });\n\n    console.log(`API response status: ${response.status}`); // New: Log status (e.g., 200 ok, 404 no match, 401 bad key)\n\n    if (!response.ok) {\n      console.log(`API error details: ${await response.text()}`); // New: Log error body if not ok (e.g., rate limit or invalid params)\n      return { error: `API error: ${response.status}` };\n    }\n\n    const data = await response.json();\n    console.log('Raw API response data:', JSON.stringify(data, null, 2)); // New: Log full response (inspect structure for agents)\n\n    const realtor = data.properties?.[0]?.listing_agent || {}; // New: Alternate parsing (common in Realtor APIs; fallback to {} if no match – adjust if logs show different path, e.g., data.agents?.[0])\n\n    console.log('Parsed realtor:', realtor); // New: Log what we're extracting (e.g., empty if no match)\n\n    await prisma.leads.update({\n      where: { id: leadId },\n      data: {\n        realtor_first_name: realtor.first_name || null,\n        realtor_last_name: realtor.last_name || null,\n        realtor_phone: realtor.phone || null,\n        metadata: { ...((typeof lead.metadata === 'object' && lead.metadata !== null) ? lead.metadata : {}), enriched_at: new Date(), api_source: 'realtor-com' }, // Cache/audit\n      },\n    });\n\n    return { success: true, realtor };\n  } catch (error) {\n    console.error('Enrich error:', error);\n    return { error: (error as Error).message };\n  }\n}"],"names":[],"mappings":";;;;;;;IAiOsB,mBAAA,WAAA,GAAA,IAAA,8bAAA,EAAA,8CAAA,mbAAA,EAAA,KAAA,GAAA,ybAAA,EAAA","debugId":null}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/app/extract/page.tsx"],"sourcesContent":["// src/app/extract/page.tsx – Client page for Propstream import (with progress bar, polling, always-on leads table; gamified UX – see imports progress like quest loading, review leads for dialing; best practice: Polling for status unblocks without complexity; realtime sub for table)\n// New: Switched to @tanstack/react-table with Shadcn DataTable wrapper (replaces old Shadcn Table – headless, React-native; features like sort/pagination without jQuery). Aligned columns to properties schema (accessorKey matches DB fields). Fetch/sub updated for properties (per request; all schema cols). Assumes `npx shadcn-ui add data-table` ran (adds components/ui/data-table.tsx – if not, run it; provides full features). No removals – old table commented.\n'use client'; // Logic: Client for interactivity (dropzone, form state, polling, realtime sub)\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { createClientComponentClient } from '@supabase/auth-helpers-nextjs'; // For realtime client sub\nimport { ColumnDef } from '@tanstack/react-table';\nimport { useEffect, useState } from 'react';\nimport { useDropzone } from 'react-dropzone'; // Logic: Drag-drop (gamified UX – better than plain input)\nimport { useForm } from 'react-hook-form';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button'; // Import Button component\nimport { DataTable } from '@/components/ui/data-table'; // New: Shadcn DataTable (assumes added via CLI; tanstack under hood – sort/search/pagination)\nimport { Progress } from '@/components/ui/progress'; // Shadcn for import progress\n// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'; // Comment out old plain Table (replaced with DataTable – easy revert)\nimport { enrichLeadRealtor, importDataAction, pollImportStatus } from '@/lib/actions'; // Updated actions (add poll below)\n// New: Tanstack types for columns (install: pnpm add @tanstack/react-table)\n\nconst importSchema = z.object({ source: z.literal('propstream') });\ntype FormData = z.infer<typeof importSchema>;\n\n// New: Properties type from schema (for type-safe columns; expand if Prisma types gen available)\ntype Property = {\n  id: string;\n  address: string;\n  city: string;\n  state: string;\n  zip_code: string;\n  property_type: string | null;\n  bedrooms: number | null;\n  bathrooms: number | null;\n  square_feet: number | null;\n  year_built: number | null;\n  avm: number | null;\n  equity: number | null;\n  remaining_balance: number | null;\n  loan_to_value: number | null;\n  open_loans: number | null;\n  owner_occupied: boolean | null;\n  notes: string | null;\n  created_at: string; // Date as string for display\n  // Add more schema fields (e.g., metadata: object – render as JSON.stringify in cell)\n};\n\nexport default function ExtractPage() {\n  const [importResults, setImportResults] = useState<any[]>([]); // Logic: Import outcomes\n  const [error, setError] = useState<string | null>(null);\n  const [file, setFile] = useState<File | null>(null); // Logic: Hold uploaded file\n  const [properties, setProperties] = useState<Property[]>([]); // Updated: State for properties (fetched/realtime – aligned to schema; was leads)\n  const [importProgress, setImportProgress] = useState(0); // Logic: Progress % (0-100)\n  const [importJobId, setImportJobId] = useState<string | null>(null); // Logic: Job ID for polling\n  const [enrichRealtors, setEnrichRealtors] = useState(false); // New: Checkbox state for optional enrichment (default false – cost-aware)\n  const { handleSubmit, formState: { isSubmitting } } = useForm<FormData>({\n    resolver: zodResolver(importSchema),\n    defaultValues: { source: 'propstream' },\n  });\n\n  const supabase = createClientComponentClient(); // Logic: Client Supabase for realtime subs/fetch (secure with RLS)\n\n  // Fetch initial properties + sub for realtime (always show – gamified review; pushback: Pagination for >100 items later via tanstack)\n  // New: Fetch properties (all schema fields via select('*')). Sub on properties table.\n  useEffect(() => {\n    const fetchProperties = async () => {\n      const { data: { user } } = await supabase.auth.getUser(); // Secure client auth\n      if (user?.id) {\n        const { data } = await supabase.from('properties').select('*').order('created_at', { ascending: false }).limit(100); // New: Fetch properties (eq filter if owned, e.g., .eq('assigned_to', user.id) if schema has it)\n        setProperties(data || []);\n      }\n    };\n\n    fetchProperties();\n\n    // Realtime sub (pushback: Efficient for gamification – live updates like MMO quest log; unsub on unmount)\n    const propertiesSub = supabase.channel('properties_changes').on('postgres_changes', { event: '*', schema: 'public', table: 'properties' }, async (payload) => {\n      // New: For changes, refetch or update state (simple prepend for INSERT; handle UPDATE/DELETE similarly if needed)\n      if (payload.eventType === 'INSERT') {\n        setProperties((prev) => [payload.new, ...prev.slice(0, 99)]); // Prepend new\n      } else if (payload.eventType === 'UPDATE') {\n        setProperties((prev) => prev.map((p) => p.id === payload.new.id ? payload.new : p));\n      } else if (payload.eventType === 'DELETE') {\n        setProperties((prev) => prev.filter((p) => p.id !== payload.old.id));\n      }\n    }).subscribe();\n\n    return () => { supabase.removeChannel(propertiesSub); }; // Cleanup\n  }, [supabase]);\n\n  // Polling for import progress (if jobId set; interval 1s, stop on 100% or error)\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    if (importJobId) {\n      interval = setInterval(async () => {\n        const status = await pollImportStatus(importJobId); // Logic: New action (below)\n        setImportProgress(status.progress);\n        setImportResults(status.results || []);\n        if (status.error) setError(status.error);\n        if (status.progress >= 100 || status.error) {\n          clearInterval(interval);\n          setImportJobId(null); // Reset\n        }\n      }, 1000);\n    }\n    return () => clearInterval(interval);\n  }, [importJobId]);\n\n  const onSubmit = async () => {\n    setError(null);\n    setImportResults([]);\n    setImportProgress(0);\n    if (!file) {\n      setError('Upload a Propstream CSV first');\n      return;\n    }\n    if (file.size > 5 * 1024 * 1024) { // Logic: Security/perf – limit 5MB\n      setError('File too large – max 5MB');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('source', 'propstream');\n    formData.append('enrichRealtors', enrichRealtors.toString()); // New: Pass flag to action\n    const result = await importDataAction(formData); // Logic: Now returns jobId for long-running (update action to support)\n\n    if (result.error) {\n      setError('Import failed: ' + JSON.stringify(result.error));\n    } else {\n      setImportJobId(result.jobId); // Start polling\n    }\n  };\n\n  const { getRootProps, getInputProps } = useDropzone({\n    accept: { 'text/csv': ['.csv'] },\n    onDrop: (acceptedFiles) => setFile(acceptedFiles[0] || null), // Logic: Take first file\n  });\n\n  // New: Define columns for DataTable (match properties schema – accessorKey: 'db_field', header/title, cell for custom render like bool Yes/No or format numbers)\n  const columns: ColumnDef<Property>[] = [\n    { accessorKey: 'address', header: 'Address' },\n    { accessorKey: 'city', header: 'City' },\n    { accessorKey: 'state', header: 'State' },\n    { accessorKey: 'zip_code', header: 'Zip Code' },\n    { accessorKey: 'property_type', header: 'Property Type' },\n    { accessorKey: 'bedrooms', header: 'Bedrooms' },\n    { accessorKey: 'bathrooms', header: 'Bathrooms' },\n    { accessorKey: 'square_feet', header: 'Square Feet' },\n    { accessorKey: 'year_built', header: 'Year Built' },\n    { accessorKey: 'avm', header: 'AVM', cell: ({ row }) => row.original.avm ? `$${row.original.avm.toFixed(0)}` : 'N/A' }, // Custom cell (format as currency)\n    { accessorKey: 'equity', header: 'Equity', cell: ({ row }) => row.original.equity ? `$${row.original.equity.toFixed(0)}` : 'N/A' },\n    { accessorKey: 'remaining_balance', header: 'Remaining Balance', cell: ({ row }) => row.original.remaining_balance ? `$${row.original.remaining_balance.toFixed(0)}` : 'N/A' },\n    { accessorKey: 'loan_to_value', header: 'Loan to Value', cell: ({ row }) => row.original.loan_to_value ? `${row.original.loan_to_value.toFixed(2)}%` : 'N/A' },\n    { accessorKey: 'open_loans', header: 'Open Loans' },\n    { accessorKey: 'owner_occupied', header: 'Owner Occupied', cell: ({ row }) => row.original.owner_occupied ? 'Yes' : 'No' }, // Bool render\n    { accessorKey: 'notes', header: 'Notes' },\n    { accessorKey: 'created_at', header: 'Created At', cell: ({ row }) => new Date(row.original.created_at).toLocaleString() }, // Date format\n    // Add more (e.g., { id: 'actions', cell: ({ row }) => <Button>Enrich</Button> } for custom actions like realtor enrich – tie to leads if needed via relation)\n  ];\n\n  return (\n    <div className=\"flex flex-col min-h-screen items-center bg-black text-green-400 font-mono p-8\">\n      <form onSubmit={handleSubmit(onSubmit)} className=\"p-8 border-2 border-green-500 rounded-lg shadow-[0_0_15px_rgba(0,255,0,0.7)] bg-black/80 w-full max-w-md mb-8\">\n        <h2 className=\"text-2xl mb-6 text-center\">Import Leads Quest (Propstream CSV)</h2>\n        <div {...getRootProps()} className=\"w-full mb-4 p-4 bg-black border border-dashed border-green-500 text-center cursor-pointer\">\n          <input {...getInputProps()} />\n          <p>{file ? file.name : 'Drag-drop CSV or click to upload'}</p>\n        </div>\n        {/* New: Checkbox for optional enrichment (UX: Warn on costs; ties to formData) */}\n        <label className=\"flex items-center mb-4\">\n          <input type=\"checkbox\" checked={enrichRealtors} onChange={(e) => setEnrichRealtors(e.target.checked)} className=\"mr-2\" />\n          Auto-enrich realtor info? (May incur API costs for bulk)\n        </label>\n        <button type=\"submit\" disabled={isSubmitting || !file} className=\"w-full p-2 bg-green-500 text-black hover:bg-green-600\">\n          {isSubmitting ? 'Importing...' : 'Start Import'}\n        </button>\n        {importProgress > 0 && <Progress value={importProgress} className=\"mt-4\" />} {/* Logic: Gamified progress bar */}\n        {error && <p className=\"text-red-500 mt-4\">{error}</p>}\n        {importResults.length > 0 && (\n          <ul className=\"mt-4 max-h-40 overflow-y-auto\">\n            {importResults.map((res, i) => (\n              <li key={i} className={res.success ? 'text-green-400' : 'text-red-500'}>\n                {res.success ? `Row ${res.row} imported (Lead ${res.leadId})` : `Error on row ${res.row}: ${res.error}`}\n              </li>\n            ))}\n          </ul>\n        )}\n      </form>\n\n      {/* Properties Table (always show – DataTable for enhanced features; realtime updates) */}\n      <div className=\"w-full max-w-4xl\">\n        <h2 className=\"text-2xl mb-4\">Your Current Properties (From Imports)</h2>\n        {/* Comment out old Shadcn Table (replaced with DataTable – easy revert; no removal) */}\n        {/* <Table>\n          <TableHeader><TableRow> \n              <TableHead>Address</TableHead><TableHead>Name</TableHead><TableHead>Phone</TableHead><TableHead>Status</TableHead><TableHead>Source</TableHead><TableHead>Points Earned</TableHead><TableHead>Equity % (Creative)</TableHead><TableHead>AVM</TableHead><TableHead>Realtor First</TableHead><TableHead>Realtor Last</TableHead><TableHead>Realtor Phone</TableHead><TableHead>Actions</TableHead>\n            </TableRow></TableHeader>\n          <TableBody>\n            {leads.map((lead) => (\n              <TableRow key={lead.id}>\n                <TableCell>{lead.properties?.address || 'N/A'}</TableCell> \n                <TableCell>{`${lead.first_name || ''} ${lead.last_name || ''}`.trim() || 'N/A'}</TableCell>\n                <TableCell>{lead.phone || 'N/A'}</TableCell>\n                <TableCell>{lead.status}</TableCell>\n                <TableCell>{lead.source}</TableCell>\n                <TableCell>{lead.points_earned}</TableCell>\n                <TableCell>{lead.properties?.equity ? `${lead.properties.equity.toFixed(2)}%` : 'N/A'}</TableCell> \n                <TableCell>{lead.properties?.avm ? `$${lead.properties.avm.toFixed(0)}` : 'N/A'}</TableCell> \n                <TableCell>{lead.realtor_first_name || 'N/A'}</TableCell>\n                <TableCell>{lead.realtor_last_name || 'N/A'}</TableCell>\n                <TableCell>{lead.realtor_phone || 'N/A'}</TableCell>\n                <TableCell>\n                  <Button onClick={async () => {\n                    const result = await enrichLeadRealtor(lead.id);\n                    if (result.success) {\n                      // Update local state (or rely on realtime sub)\n                      setLeads(prev => prev.map(l => l.id === lead.id ? { ...l, ...result.realtor } : l));\n                    } else {\n                      alert(result.error); // Simple error UX; use toast later\n                    }\n                  }}>Enrich Realtor</Button>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table> */}\n        <DataTable columns={columns} data={properties} /> {/* New: Shadcn DataTable (tanstack-based – pass columns/data; auto-handles sort/pagination/search if configured in data-table.tsx) */}\n      </div>\n    </div>\n  );\n}"],"names":[],"mappings":"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","debugId":null}}]
}