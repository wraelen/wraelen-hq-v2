{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/lib/actions.ts"],"sourcesContent":["// src/lib/actions.ts – Updated with async Supabase (align with layout fix; keeps Propstream CSV ready – test upload post-restart; fixed notes type by disabling dynamicTyping and explicit conversions – best practice: Treat CSV as strings to avoid surprises, manually Number() numerics for safety/scalability in imports/quests)\n'use server'; // Logic: Marks as server-only (no client bundle bloat – optimizes for internal app with leads/calls)\nimport { LeadSource, LeadType, PrismaClient, PropertyType } from '@prisma/client';  // Your DB client (async-safe in actions)\nimport { redirect } from 'next/navigation'; // Server redirect (reliable – no client hacks; best for post-auth flow to dashboard quests)\nimport Papa from 'papaparse'; // Logic: CSV parser (handles headers, errors – best for Propstream exports)\nimport Twilio from 'twilio'; // Logic: Twilio SDK for outbound calls (inexpensive, reliable integration)\nimport { z } from 'zod';  // Validation (type-safe inputs – prevents junk data in DB; no-brainer for prod)\nimport crypto from 'crypto';  // Built-in hash (no extra deps – for address_hash dedup)\nimport { createSupabaseServerClient } from '@/lib/supabaseServer'; // Use async helper (fixes warnings in actions too)\nimport type { Database } from '@/types/database.types'; // Types (autocompletes e.g., session.user.id for Prisma sync – now fixed via your gen)\n\nconst prisma = new PrismaClient();  // Global instance (efficient in Next.js actions – auto-closes; push back: Cache in lib/prisma.ts for hot reloads if issues)\n\nconst twilioClient = Twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN); // Logic: Init Twilio (guard env in prod)\n\nconst importSchema = z.object({\n  source: z.literal('propstream'), // Logic: Locked to Propstream for now (expand later)\n});  // Logic: Zod for form (file handled separately)\n\n// Action: Sign in (logic: Basic stub – expand with your original zod/email/password validation; centralized for type-safety)\nexport async function signInAction(formData: FormData) {\n  const email = formData.get('email')?.toString() ?? '';\n  const password = formData.get('password')?.toString() ?? '';\n  // ... (add your validation/error returns here; e.g., zod schema for email/password)\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (Next 15 safe)\n  const { error } = await supabase.auth.signInWithPassword({ email, password });\n  if (error) {\n    return { error: error.message };\n  }\n  redirect('/dashboard'); // Logic: Post-login to HQ (quests await!)\n}\n\n// Action: Sign out (logic: Centralized mutation – avoids serialization issues in layout; redirects to signin)\nexport async function signOutAction() {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client (consistent fix)\n  await supabase.auth.signOut(); // Logic: Clears session (middleware will redirect unauthed requests)\n  redirect('/auth/signin'); // Logic: Post-signout flow (back to login – update to '/' if public landing needed)\n}\n\n// Action: Import from Propstream CSV (logic: Parse file → per-row extract/map → batch upsert properties/create leads – returns results for UX)\n// New: Added enrichRealtors flag from form (optional – if true and env enabled, enrich after create; pushback: Gate to avoid costs; serial for now, batch later if scale)\n// New: After all, trigger quest checks (increment points by leads.length, check/complete quests via transaction – atomic/best practice to avoid partial fails)\nexport async function importDataAction(formData: FormData) {\n  const validated = importSchema.safeParse({\n    source: formData.get('source')?.toString() ?? 'propstream',\n  });\n  if (!validated.success) {\n    return { error: validated.error.format() };\n  }\n\n  const file = formData.get('file') as File | null; // Logic: Get uploaded CSV (from dropzone/form)\n  if (!file) {\n    return { error: 'No file uploaded' };\n  }\n\n  const enrichRealtors = formData.get('enrichRealtors') === 'true'; // New: Optional flag from checkbox (default false)\n\n  // Parse CSV (papaparse – async, handles large files stream-like)\n  const csvText = await file.text();\n  const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true, dynamicTyping: false }); // Fix: Disable dynamicTyping (all fields as strings – avoids number surprises like notes:1 as Int; explicit Number() below for numerics)\n  if (parsed.errors.length > 0) {\n    return { error: `CSV parse errors: ${parsed.errors.map(e => e.message).join('; ')}` }; // Logic: Early feedback (e.g., malformed rows)\n  }\n\n  const rows = parsed.data as Record<string, any>[]; // Logic: Typed rows (Propstream columns like 'Property Address', 'AVM', etc.)\n  const supabase = await createSupabaseServerClient(); // Logic: Hoist session fetch (efficiency – avoids per-row calls)\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session – login required' };\n  }\n\n  const results = await Promise.allSettled(rows.map(async (row, index) => { // Logic: Parallel for speed; settled for per-row errors\n    try {\n      // Map Propstream columns to schema (flexible – handle variants/missing; added equity/mortgage for creative financing)\n      const propertyTypeMap: Record<string, PropertyType> = { // Logic: Dict for safe enum mapping (pushback: Better than lowercase assume – handles variants)\n        'single family': 'single_family',\n        'multi family': 'multi_family',\n        'condo': 'condo',\n        'townhouse': 'townhouse',\n        'land': 'land',\n        'commercial': 'commercial',\n        'duplex (2 units, any combination)': 'multi_family', // Added: Matches your sample CSV value (normalize to enum; pushback: If more variants, expand or use AI fuzzy match later)\n        // Add more mappings as needed; default to 'other' below\n      };\n\n      const address = row['Address']?.trim() || null; // Logic: Trim (now strings)\n      const city = row['City']?.trim() || null;\n      const state = row['State']?.toUpperCase() || null; // Standardize to uppercase (e.g., 'FL' → 'FL')\n      const zip_code = row['Zip']?.trim() || null; // Keep as string for leading zeros\n      if (!address || !city || !state || !zip_code) {\n        throw new Error('Missing required address fields');\n      }\n\n      const address_hash = crypto.createHash('sha256').update(`${address}${city}${state}${zip_code}`.toLowerCase()).digest('hex'); // Logic: Normalized hash for dedup (lowercase for consistency)\n\n      const propertyData = {\n        address,\n        city,\n        state,\n        zip_code,\n        property_type: propertyTypeMap[row['Property Type']?.toLowerCase() || ''] || 'other' as PropertyType,\n        bedrooms: Number(row['Bedrooms']) || null, // Explicit Number (NaN → null)\n        bathrooms: Number(row['Total Bathrooms']) || null, // Matches CSV header 'Total Bathrooms'\n        square_feet: Number(row['Building Sqft']) || null,\n        year_built: Number(row['Effective Year Built']) || null,\n        avm: Number(row['Est. Value']) || null, // Matches 'Est. Value' for AVM\n        owner_occupied: row['Owner Occupied']?.toLowerCase() === 'yes' ? true : (row['Owner Occupied']?.toLowerCase() === 'no' ? false : null), // Boolean map from string\n        distress_signals: row['Foreclosure Factor'] ? { foreclosure: row['Foreclosure Factor'] } : null, // Json: Basic distress (expand with more CSV fields if available)\n        notes: row['Marketing Lists'] || null, // Now string (e.g., '1' instead of 1 – fixes validation error)\n        equity: Number(row['Est. Equity']) || null, // Matches 'Est. Equity' in CSV\n        remaining_balance: Number(row['Est. Remaining balance of Open Loans']) || null, // Matches CSV\n        loan_to_value: Number(row['Est. Loan-to-Value']) || null, // Matches CSV\n        open_loans: Number(row['Total Open Loans']) || null, // Matches CSV\n        metadata: { // Json: Extras for creative financing (add more if CSV has them; e.g., if 'Equity' column exists, parse here)\n        },\n      };\n\n      // Upsert property (dedup on hash – merge data)\n      const property = await prisma.properties.upsert({\n        where: { address_hash },\n        update: propertyData,\n        create: { ...propertyData, address_hash },\n      });\n\n      // Parse owner names (split first/last if combined; for owner leads)\n      const owner1First = row['Owner 1 First Name']?.trim() || null;\n      const owner1Last = row['Owner 1 Last Name']?.trim() || null;\n      const phone = row['Owner 1 Phone']?.trim() || null; // Assuming CSV has phone; add if present\n      const email = row['Owner 1 Email']?.trim() || null; // Add if CSV has email\n\n      const leadData = {\n        properties_id: property.id,\n        lead_type: 'owner' as LeadType, // Default to owner for Propstream (realtor enrich separate)\n        first_name: owner1First,\n        last_name: owner1Last,\n        phone,\n        email,\n        status: 'new' as const, // Default new\n        source: 'propstream_import' as LeadSource,\n        assigned_to: session.user.id, // Assign to importer (gamification: Their quest points)\n        points_earned: 1, // Per-lead points (expand logic for quality-based)\n        notes: row['Notes'] || null,\n        metadata: { imported_at: new Date(), county: row['County'] || null }, // Audit + extras\n      };\n\n      // Create lead (no unique – allow multiples per property if needed; pushback: Add unique constraint if 1:1 desired)\n      const lead = await prisma.leads.create({ data: leadData });\n\n      // New: Optional auto-enrich (gate with env to avoid bulk costs; pushback: Serial for simplicity, but if slow, add batch/queue later with Upstash)\n      if (enrichRealtors && process.env.ENABLE_AUTO_ENRICH === 'true') {\n        await enrichLeadRealtor(lead.id); // Call existing (handles errors internally – log, don't fail import)\n      }\n\n      return { success: true, row: index + 1, leadId: lead.id }; // For results list\n    } catch (error) {\n      console.error(`Import error for row ${index + 1}:`, error);\n      return { success: false, row: index + 1, error: (error as Error).message };\n    }\n  }));\n\n  // Filter fulfilled/rejected for summary (UX: Show counts in results)\n  const successful = results.filter(r => r.status === 'fulfilled' && (r.value as any).success).length;\n  const failed = results.length - successful;\n\n  // New: Trigger quests (after all imports – use transaction for atomic points/quests; best practice to prevent races)\n  if (successful > 0) {\n    await prisma.$transaction(async (tx) => {\n      // Get profile (by user_id from session)\n      const profile = await tx.profile.findUnique({ where: { user_id: session.user.id } });\n      if (!profile) throw new Error('Profile not found');\n\n      // Increment points (1 per successful lead; ties to leads.points_earned but aggregates to profile)\n      await tx.profile.update({\n        where: { user_id: session.user.id },\n        data: { points: { increment: successful } },\n      });\n\n      // Get active quests (for this user – check incomplete)\n      const quests = await tx.quest.findMany({\n        where: { active: true },\n      });\n\n      for (const quest of quests) {\n        // Check if already completed (unique constraint prevents dupes)\n        const existingCompletion = await tx.quest_completions.findUnique({\n          where: { quest_id_profile_id: { quest_id: quest.id, profile_id: profile.id } },\n        });\n        if (existingCompletion) continue;\n\n        // Parse criteria and check (basic for min_imports; expand for other types like min_calls)\n        const criteria = quest.criteria as { min_imports?: number } | null;\n        if (criteria?.min_imports) {\n          // Count total imports for user (ever; for one_time – adjust for daily/weekly with date filters)\n          const totalImports = await tx.leads.count({\n            where: { assigned_to: profile.id, source: LeadSource.propstream_import },\n          });\n          if (totalImports >= criteria.min_imports) {\n            // Complete quest (award extra points)\n            await tx.quest_completions.create({\n              data: {\n                quest_id: quest.id,\n                profile_id: profile.id,\n                evidence: { total_imports: totalImports, awarded_points: quest.points },\n              },\n            });\n            await tx.profile.update({\n              where: { id: profile.id },\n              data: { points: { increment: quest.points } },\n            });\n            // Optional: Unlock badge if requirements met (e.g., check badges.requirements – add similar loop if needed)\n          }\n        }\n        // Expand: Add cases for other criteria (e.g., if (criteria.min_calls) { count calls... })\n      }\n    });\n  }\n\n  if (failed === results.length) {\n    return { error: 'All rows failed – check CSV format/console logs' };\n  }\n\n  return { success: true, results, summary: { successful, failed } }; // Logic: Return array for display (no jobId yet; pushback: For long-running, add Upstash/edge func + return jobId for poll)\n}\n\n// Stub poll (replace with real DB query on 'import_jobs' table for prod; unblocks testing without Upstash)\nexport async function pollImportStatus(jobId: string) {\n  // Stub logic: Simulate progress (e.g., from memory or DB; here, random increment for testing)\n  // In real, query prisma.import_jobs.findUnique({ where: { id: jobId } }) for { progress, results, error }\n  const simulatedProgress = Math.min(100, (Math.random() * 20) + (await new Promise(r => setTimeout(r, 500)) as any || 0)); // Fake delay/increment\n  if (simulatedProgress >= 100) {\n    return { progress: 100, results: [], error: null }; // Replace with real results\n  }\n  return { progress: simulatedProgress, results: [], error: null };\n}\n\n// Action: Dial lead (logic: Twilio outbound call – from your Twilio number to lead phone; logs to calls table)\nexport async function dialLeadAction(leadId: number) {\n  try {\n    const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n    if (!lead?.phone) {\n      throw new Error('No phone for lead');\n    }\n\n    const supabase = await createSupabaseServerClient(); // Logic: Async client\n    const { data: { session } } = await supabase.auth.getSession();\n    if (!session?.user.id || lead.assigned_to !== session.user.id) {\n      throw new Error('Unauthorized or mismatched assignment');\n    }\n\n    // Twilio outbound (phone-to-phone; expand to browser via Voice SDK if web calls needed)\n    const call = await twilioClient.calls.create({\n      to: lead.phone, // Lead's number\n      from: process.env.TWILIO_PHONE_NUMBER!, // Your Twilio number\n      url: 'http://your-domain.com/api/twiml', // Logic: TwiML endpoint (create /api/twiml route for voice response – e.g., <Say>Hello, connecting to lead</Say>)\n      statusCallback: 'http://your-domain.com/api/call-status', // Logic: Webhook for metrics (update calls table on complete)\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'], // Track status\n    });\n\n    // Log call (for metrics/quests – expand with webhook for duration/points)\n    await prisma.calls.create({\n      data: {\n        leads_id: lead.id,\n        caller_id: session.user.id,\n        call_sid: call.sid, // Twilio ID for tracking\n        status: 'initiated',\n        metadata: { address: lead.properties.address },\n      },\n    });\n\n    return { success: true, callId: call.sid };\n  } catch (error) {\n    console.error('Dial error:', error);\n    return { success: false, error: (error as Error).message };\n  }\n}\n\n// Helper: Stubbed extractFromLink (removed for pivot – mock for non-CSV if needed)\n// async function extractFromLink(...) { return { /* mock data */ }; } // Comment out Zillow logic\n\n// Action: Enrich lead with realtor info (fix: Added for API call; uses RapidAPI key from .env – solves realtor missing in Propstream; push back: Cache results to avoid repeat costs)\n// New: Improved query with full address (address + city + state + zip – fixes partial failures; pushback: If API still flaky, add fallback or switch to another like Datafiniti)\n// New: Added detailed logging for debugging (query, status, raw data, parsed realtor – best practice for API issues; remove or gate in prod if verbose)\n// Suggestion: Alternate parsing to data.properties?.[0]?.listing_agent (common in Realtor APIs; adjust based on logs/raw data)\nexport async function enrichLeadRealtor(leadId: string) {\n  const supabase = await createSupabaseServerClient(); // Logic: Async client\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session?.user.id) {\n    return { error: 'No session' };\n  }\n\n  const lead = await prisma.leads.findUnique({ where: { id: leadId }, include: { properties: true } });\n  if (!lead || lead.assigned_to !== session.user.id) {\n    return { error: 'Unauthorized or lead not found' };\n  }\n\n  const fullAddress = `${lead.properties.address}, ${lead.properties.city}, ${lead.properties.state} ${lead.properties.zip_code}`; // New: Full query for better API accuracy (fixes partial address issues)\n\n  console.log(`Enriching lead ${leadId} with query: ${fullAddress}`); // New: Log the input query for verification\n\n  try {\n    const response = await fetch('https://realtor-com4.p.rapidapi.com/properties/v1/search', { // Logic: Endpoint for agents by location (adjust per API docs; e.g., /agents if separate)\n      method: 'POST', // Or GET—check docs\n      headers: {\n        'Content-Type': 'application/json',\n        'x-rapidapi-key': process.env.RAPIDAPI_KEY!, // Your key from .env (add to .env: RAPIDAPI_KEY=your_key)\n        'x-rapidapi-host': 'realtor-com4.p.rapidapi.com',\n      },\n      body: JSON.stringify({ // Params from docs (example—tweak for address search)\n        location: fullAddress,\n        limit: 1, // Top realtor\n      }),\n    });\n\n    console.log(`API response status: ${response.status}`); // New: Log status (e.g., 200 ok, 404 no match, 401 bad key)\n\n    if (!response.ok) {\n      console.log(`API error details: ${await response.text()}`); // New: Log error body if not ok (e.g., rate limit or invalid params)\n      return { error: `API error: ${response.status}` };\n    }\n\n    const data = await response.json();\n    console.log('Raw API response data:', JSON.stringify(data, null, 2)); // New: Log full response (inspect structure for agents)\n\n    const realtor = data.properties?.[0]?.listing_agent || {}; // New: Alternate parsing (common in Realtor APIs; fallback to {} if no match – adjust if logs show different path, e.g., data.agents?.[0])\n\n    console.log('Parsed realtor:', realtor); // New: Log what we're extracting (e.g., empty if no match)\n\n    await prisma.leads.update({\n      where: { id: leadId },\n      data: {\n        realtor_first_name: realtor.first_name || null,\n        realtor_last_name: realtor.last_name || null,\n        realtor_phone: realtor.phone || null,\n        metadata: { ...((typeof lead.metadata === 'object' && lead.metadata !== null) ? lead.metadata : {}), enriched_at: new Date(), api_source: 'realtor-com' }, // Cache/audit\n      },\n    });\n\n    return { success: true, realtor };\n  } catch (error) {\n    console.error('Enrich error:', error);\n    return { error: (error as Error).message };\n  }\n}"],"names":[],"mappings":";;;;;;;IAoBsB,eAAA,WAAA,GAAA,IAAA,8bAAA,EAAA,8CAAA,mbAAA,EAAA,KAAA,GAAA,ybAAA,EAAA","debugId":null}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/src/app/auth/signin/page.tsx"],"sourcesContent":["// src/app/auth/signin/page.tsx – Login form (client-side for state/UX; binds server action for mutation – best hybrid for Next.js, fixes cookie bug without full server component)\n'use client';  // Logic: Client (enables hooks like useState/useRouter – interactive errors without reload; push back: If no complex state, could go full server for perf)\n\nimport { useRouter } from 'next/navigation';  // Logic: Router for client push/refresh (smooth transition – e.g., to leaderboard; no reload on success; satisfies ESLint by using refresh() fallback)\nimport { useState } from 'react';\nimport { signInAction } from '@/lib/actions';  // Imported server action (executes server-side – handles cookies/redirect; scalable for more forms)\n\nexport default function SignIn() {\n  const router = useRouter();  // Logic: Used for success push + refresh (avoids stale UI post-auth – better for game-like flow; fixes \"assigned but unused\")\n  const [email, setEmail] = useState('');  // Logic: Controlled input (realtime validation if expanded – e.g., email format check for \"quest eligibility\")\n  const [password, setPassword] = useState('');  // Logic: Controlled input (same as above)\n  const [error, setError] = useState<string | null>(null);  // Logic: Local error state (displays without reload – improves rep login experience; fixes \"assigned but unused\" by setting conditionally)\n\n  const handleSignIn = async (e: React.FormEvent<HTMLFormElement>) => {  // Logic: Async handler (waits for action – sets local error if fails)\n    e.preventDefault();\n    if (!email || !password) {  // Logic: Client validation (quick feedback – prevents unnecessary server calls; duplicates server for speed; uses state vars to satisfy ESLint)\n      setError('Email and password are required');\n      return;\n    }\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters');\n      return;\n    }\n\n    const formData = new FormData(e.currentTarget);  // Logic: Native FormData (binds inputs – no manual state sync; efficient)\n    const result = await signInAction(formData);  // Logic: Call server action (runs server-side – returns { error } or redirects on success)\n\n    if (result?.error) {\n      setError(result.error);  // Logic: Display error client-side (no reload – e.g., \"Invalid credentials\"; ties to game theme, like \"Access Denied: Retry Quest\")\n    } else {\n      router.refresh();  // Logic: Optimistic refresh (syncs any server data if dashboard has SSR fetches – e.g., load quests; satisfies ESLint usage)\n      router.push('/dashboard');  // Logic: Client push on success (smooth – cookies sync'd via middleware; fallback if redirect fails)\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-black text-green-400 font-mono\">\n      <form onSubmit={handleSignIn} className=\"p-8 border-2 border-green-500 rounded-lg shadow-[0_0_15px_rgba(0,255,0,0.7)] bg-black/80\">\n        <h2 className=\"text-2xl mb-6 text-center\">Enter Wraelen HQ</h2>\n        {error && <p className=\"text-red-500 mb-4\">{error}</p>}  // Logic: Displays from state (clear feedback – no query params needed)\n        <input\n          name=\"email\"  // Logic: Name attrs (for FormData – kept onChange for controlled inputs/realtime validation if expanded)\n          type=\"email\"\n          placeholder=\"Email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n          className=\"w-full mb-4 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\"\n        />\n        <input\n          name=\"password\"\n          type=\"password\"\n          placeholder=\"Password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          className=\"w-full mb-6 p-2 bg-black border border-green-500 text-green-400 focus:outline-none focus:border-green-300\"\n        />\n        <button type=\"submit\" className=\"w-full p-2 bg-green-500 text-black hover:bg-green-600\">Login</button>\n      </form>\n    </div>\n  );\n}"],"names":[],"mappings":"AAAA,mLAAmL;;;;;;AAGnL,ikBAA8C,uJAAuJ;AACrM;AACA,4PAA+C,oGAAoG;AAJnJ,cAAe,2JAA2J;;;;;AAM3J,SAAS;IACtB,MAAM,SAAS,IAAA,8VAAS,KAAK,8HAA8H;IAC3J,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,gaAAQ,EAAC,KAAM,+GAA+G;IACxJ,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,gaAAQ,EAAC,KAAM,0CAA0C;IACzF,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,gaAAQ,EAAgB,OAAQ,2IAA2I;IAErM,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,SAAS;YACT;QACF;QACA,IAAI,SAAS,MAAM,GAAG,GAAG;YACvB,SAAS;YACT;QACF;QAEA,MAAM,WAAW,IAAI,SAAS,EAAE,aAAa,GAAI,0EAA0E;QAC3H,MAAM,SAAS,MAAM,IAAA,kKAAY,EAAC,WAAY,2FAA2F;QAEzI,IAAI,QAAQ,OAAO;YACjB,SAAS,OAAO,KAAK,GAAI,oIAAoI;QAC/J,OAAO;YACL,OAAO,OAAO,IAAK,6HAA6H;YAChJ,OAAO,IAAI,CAAC,eAAgB,qGAAqG;QACnI;IACF;IAEA,qBACE,6bAAC;QAAI,WAAU;kBACb,cAAA,6bAAC;YAAK,UAAU;YAAc,WAAU;;8BACtC,6bAAC;oBAAG,WAAU;8BAA4B;;;;;;gBACzC,uBAAS,6bAAC;oBAAE,WAAU;8BAAqB;;;;;;gBAAW;8BACvD,6bAAC;oBACC,MAAK;oBACL,MAAK;oBACL,aAAY;oBACZ,OAAO;oBACP,UAAU,CAAC,IAAM,SAAS,EAAE,MAAM,CAAC,KAAK;oBACxC,WAAU;;;;;;8BAEZ,6bAAC;oBACC,MAAK;oBACL,MAAK;oBACL,aAAY;oBACZ,OAAO;oBACP,UAAU,CAAC,IAAM,YAAY,EAAE,MAAM,CAAC,KAAK;oBAC3C,WAAU;;;;;;8BAEZ,6bAAC;oBAAO,MAAK;oBAAS,WAAU;8BAAwD;;;;;;;;;;;;;;;;;AAIhG","debugId":null}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/next%4015.5.4_%40babel%2Bcore%407.27.1_%40opentelemetry%2Bapi%401.7.0_%40playwright%2Btest%401.52.0_babel-p_68e8c185df7d969f063bfb2ef00a51ed/node_modules/next/navigation.js"],"sourcesContent":["module.exports = require('./dist/client/components/navigation')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///home/wraelen/wraelen/wraelen-internal-boilerplate/node_modules/.pnpm/next%4015.5.4_%40babel%2Bcore%407.27.1_%40opentelemetry%2Bapi%401.7.0_%40playwright%2Btest%401.52.0_babel-p_68e8c185df7d969f063bfb2ef00a51ed/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0],"debugId":null}}]
}